{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"APIs-introduction/","text":"To enable users to run a collaboration, Grid Singularity has developed a Software Development Kit - SDK ( gsy-e-sdk ), that allows users to perform the following functions; Asset Trading : The Asset API allows aggregators who manage individual and community energy assets to connect to the Grid Singularity Exchange and actively place bids and offers on their behalf. Aggregators can create custom strategies with the goal of optimizing trading for managed assets (Learn more about default trading strategies here); Grid Management : The Grid Operator API allows grid operators (DSO, DNO and TSO) to oversee multiple (sub)markets\u2019 statistics and results in real-time and influence trading behavior by implementing custom (dynamic) grid fee strategies. Examples of template agent scripts (flexible Python scripts) to connect to the Grid Singularity Exchange through the Software Development Kit are available in the Grid Singularity\u2019s GitHub repository for the Asset API and Grid Operator API and are explained in sections below (respectively here and here ). Figure 4.1 . Asset API and Grid Operator API interfacing with energy assets and markets in the Grid Singularity Exchange.","title":"Introduction"},{"location":"aggregate-market-summary/","text":"This market summary shows the net energy and volume in kWh for each 15 minute market slot. The average energy price and grid fees, if applied to this market are also shown in \u20ac/kWh. Figure 2.27 . Summary of volume traded, net energy, average price and grid fee.","title":"Aggregate Market Summary"},{"location":"asset-api-commands/","text":"An Oracle (see above ) is able to request information and post bids and offers for multiple assets at the same time by aggregating multiple commands in a single batch to be executed at the same time. The following are the different commands available for the Asset API: bid_energy() \u00b6 It sends an energy bid to the exchange. This command receives 4 arguments : asset_uuid : Universal Unique Identifier of the selected asset energy : energy in kWh price : price in Euro cents replace_existing : if set to TRUE replace all existing bids with a new one attributes (optional) : a dictionary of attributes that describes the bid (not supported at the moment) requirements (optional) : a list of dictionaries containing requirements for the bid. At least one of the provided dictionaries needs to be satisfied in the matching process. Currently supported requirements for bids are: energy_type: energy type (e.g., \u201cPV\u201d) that the bid prefers to consume trading_partners: IDs of the market or asset owner with which the bid prefers to be matched energy: energy quantity (expressed in kWh) that the bid prefers to consume price: trade price (expressed in Euro cents) that the bid prefers to accept time_slot (optional) : the time slot where the bid is going to be posted (to be used to trade post-delivery in the Settlement Market ) Here is an example: self.add_to_batch_commands.bid_energy(asset_uuid = \"2e7866d8-34c6-49ad-a388-fd5876a3e679\", energy = 2, price = 60, replace_existing = True, attributes = None, requirements = [{\u201cenergy_type\u201d: \u201cPV\u201d, \u201ctrading_partners\u201d = [], \u201cenergy\u201d = 5, \u201cprice\u201d: 28}], \u201ctime_slot\u201d = None) If the bid is placed successfully, it returns the detailed information about the bid. If not, it returns the reason for the error. bid_energy_rate() \u00b6 It sends an energy bid to the exchange. This batch command receives 4 arguments : asset_uuid : Universal Unique Identifier of the selected asset energy : energy in kWh rate : price per volume in Euro cents/kWh replace_existing : if set to TRUE replace all existing bids with a new one attributes (optional) : a dictionary of attributes that describes the bid (not supported at the moment) requirements (optional) : a list of dictionaries containing requirements for the bid. At least one of the provided dictionaries needs to be satisfied in the matching process. Currently supported requirements for bids are: energy_type: energy type (e.g., \u201cPV\u201d) that the bid prefers to consume trading_partners: IDs of the market or asset owner with which the bid prefers to be matched energy: energy quantity (expressed in kWh) that the bid prefers to consume price: trade price (expressed in Euro cents) that the bid prefers to accept time_slot (optional) : the time slot where the bid is going to be posted (to be used to trade post-delivery in the Settlement Market ) Here is an example: self.add_to_batch_commands.bid_energy_rate(asset_uuid = \"2e7866d8-34c6-49ad-a388-fd5876a3e679\", energy = 2, rate = 30, replace_existing = True, attributes = None, requirements = [{\u201cenergy_type\u201d: \u201cPV\u201d, \u201ctrading_partners\u201d = [], \u201cenergy\u201d = 5, \u201cprice\u201d: 28}], \u201ctime_slot\u201d = None) lists_bids() \u00b6 It lists all posted bids on the selected market. This command takes one argument: area_uuid, which is the Universal Unique Identifier of the selected market. Here is an example: self.add_to_batch_commands.list_bids(asset_uuid=\"62f827ec-ef86-4782-b5c3-88327751d97d\") delete_bid() \u00b6 It deletes a bid posted on the market using its ID. This command receives two arguments : asset_uuid : Universal Unique Identifier of the selected asset bid_id : ID of the selected bid. If None, all the bids posted by the selected asset will be deleted. Here is an example: self.add_to_batch_commands.delete_bid(asset_uuid=\"62f827ec-ef86-4782-b5c3-88327751d97d\", bid_id = \"2e7866d8-3dg6-49ad-afe8-fd5876a3e679\") offer_energy() \u00b6 It sends an energy offer to the exchange. This command receives 4 arguments : asset_uuid : Universal Unique Identifier of the selected asset energy : energy in kWh price : price in Euro cents replace_existing : if set to TRUE replace all existing bids with a new one attributes (optional) : a dictionary of attributes that describes the bid (not supported at the moment) requirements (optional) : a list of dictionaries containing requirements for the bid. At least one of the provided dictionaries needs to be satisfied in the matching process. Currently supported requirements for bids are: energy_type: energy type of the offer (e.g. solar) time_slot (optional) : the time slot where the bid is going to be posted (to be used to trade post-delivery in the Settlement Market ) Here is an example: self.add_to_batch_commands.offer_energy(asset_uuid = \"2e7866d8-34c6-49ad-a388-fd5876a3e679\", energy = 2, price_cents = 60, replace_existing = True, attributes = \u201cPV\u201d, requirements = [{ \u201ctrading_partners\u201d: \"62f827ec-ef86-4782-b5c3-88327751d97d\u201d}], \u201ctime_slot\u201d = None) If the offer is placed successfully, it returns the detailed information about the bid. If not, it returns the reason for the error. offer_energy_rate() \u00b6 It sends an energy offer to the exchange. This command receives four arguments : asset_uuid : Universal Unique Identifier of the selected asset energy : energy in kWh rate : price per volume in Euro cents/kWh replace_existing : if set to TRUE replace all existing offers with a new one requirements (optional) : a list of dictionaries containing requirements for the bid. At least one of the provided dictionaries needs to be satisfied in the matching process. Currently supported requirements for bids are: energy_type: energy type of the offer (e.g. solar) time_slot (optional) : the time slot where the bid is going to be posted (to be used to trade post-delivery in the Settlement Market ) Here is an example: self.add_to_batch_commands.offer_energy_rate(asset_uuid = \"2e7866d8-34c6-49ad-a388-fd5876a3e679\", energy = 2, rate = 30, replace_existing = True, attributes = \u201cPV\u201d, requirements = [{ \u201ctrading_partners\u201d: \"62f827ec-ef86-4782-b5c3-88327751d97d\u201d}], \u201ctime_slot\u201d = None) lists_offers() \u00b6 It lists all posted offers on the selected market. This command takes one argument: area_uuid, which is the Universal Unique Identifier of the selected market. Here is an example: self.add_to_batch_commands.list_offers(asset_uuid=\"62f827ec-ef86-4782-b5c3-88327751d97d\") delete_offer() \u00b6 It deletes an offer posted on the market using its ID. This command receives two arguments : asset_uuid : Universal Unique Identifier of the selected asset offer_id : ID of the selected offer. If None, all the bids posted by the selected asset will be deleted. Here is an example: self.add_to_batch_commands.delete_offer(asset_uuid=\"62f827ec-ef86-4782-b5c3-88327751d97d\", bid_id = \"2e7866d8-3dg6-49ad-afe8-fd5876a3e679\") asset_info() \u00b6 It gets asset information(returns required energy for Loads, available energy for PVs and energy to buy/sell for storages). This command receives one argument: asset_uuid, which is the Universal Unique Identifier of the selected asset. Here is an example: self.add_to_batch_commands.asset_info(asset_uuid=\"62f827ec-ef86-4782-b5c3-88327751d97d\") After adding all the wanted commands in the batch, the API can execute it with the following command: response = self.execute_batch_commands() In return the simulation will provide a detailed response for all commands submitted. Note: The total amount of energy to bid/offer at any point is limited to the energy requirement/available of the asset. Replacing/updating a bid/offer during a market slot deletes other active bids/offers. Additionally, the price of your bids/offers must be a positive float otherwise it will get rejected by the market.","title":"Asset API Commands"},{"location":"asset-api-commands/#bid_energy","text":"It sends an energy bid to the exchange. This command receives 4 arguments : asset_uuid : Universal Unique Identifier of the selected asset energy : energy in kWh price : price in Euro cents replace_existing : if set to TRUE replace all existing bids with a new one attributes (optional) : a dictionary of attributes that describes the bid (not supported at the moment) requirements (optional) : a list of dictionaries containing requirements for the bid. At least one of the provided dictionaries needs to be satisfied in the matching process. Currently supported requirements for bids are: energy_type: energy type (e.g., \u201cPV\u201d) that the bid prefers to consume trading_partners: IDs of the market or asset owner with which the bid prefers to be matched energy: energy quantity (expressed in kWh) that the bid prefers to consume price: trade price (expressed in Euro cents) that the bid prefers to accept time_slot (optional) : the time slot where the bid is going to be posted (to be used to trade post-delivery in the Settlement Market ) Here is an example: self.add_to_batch_commands.bid_energy(asset_uuid = \"2e7866d8-34c6-49ad-a388-fd5876a3e679\", energy = 2, price = 60, replace_existing = True, attributes = None, requirements = [{\u201cenergy_type\u201d: \u201cPV\u201d, \u201ctrading_partners\u201d = [], \u201cenergy\u201d = 5, \u201cprice\u201d: 28}], \u201ctime_slot\u201d = None) If the bid is placed successfully, it returns the detailed information about the bid. If not, it returns the reason for the error.","title":"bid_energy()"},{"location":"asset-api-commands/#bid_energy_rate","text":"It sends an energy bid to the exchange. This batch command receives 4 arguments : asset_uuid : Universal Unique Identifier of the selected asset energy : energy in kWh rate : price per volume in Euro cents/kWh replace_existing : if set to TRUE replace all existing bids with a new one attributes (optional) : a dictionary of attributes that describes the bid (not supported at the moment) requirements (optional) : a list of dictionaries containing requirements for the bid. At least one of the provided dictionaries needs to be satisfied in the matching process. Currently supported requirements for bids are: energy_type: energy type (e.g., \u201cPV\u201d) that the bid prefers to consume trading_partners: IDs of the market or asset owner with which the bid prefers to be matched energy: energy quantity (expressed in kWh) that the bid prefers to consume price: trade price (expressed in Euro cents) that the bid prefers to accept time_slot (optional) : the time slot where the bid is going to be posted (to be used to trade post-delivery in the Settlement Market ) Here is an example: self.add_to_batch_commands.bid_energy_rate(asset_uuid = \"2e7866d8-34c6-49ad-a388-fd5876a3e679\", energy = 2, rate = 30, replace_existing = True, attributes = None, requirements = [{\u201cenergy_type\u201d: \u201cPV\u201d, \u201ctrading_partners\u201d = [], \u201cenergy\u201d = 5, \u201cprice\u201d: 28}], \u201ctime_slot\u201d = None)","title":"bid_energy_rate()"},{"location":"asset-api-commands/#lists_bids","text":"It lists all posted bids on the selected market. This command takes one argument: area_uuid, which is the Universal Unique Identifier of the selected market. Here is an example: self.add_to_batch_commands.list_bids(asset_uuid=\"62f827ec-ef86-4782-b5c3-88327751d97d\")","title":"lists_bids()"},{"location":"asset-api-commands/#delete_bid","text":"It deletes a bid posted on the market using its ID. This command receives two arguments : asset_uuid : Universal Unique Identifier of the selected asset bid_id : ID of the selected bid. If None, all the bids posted by the selected asset will be deleted. Here is an example: self.add_to_batch_commands.delete_bid(asset_uuid=\"62f827ec-ef86-4782-b5c3-88327751d97d\", bid_id = \"2e7866d8-3dg6-49ad-afe8-fd5876a3e679\")","title":"delete_bid()"},{"location":"asset-api-commands/#offer_energy","text":"It sends an energy offer to the exchange. This command receives 4 arguments : asset_uuid : Universal Unique Identifier of the selected asset energy : energy in kWh price : price in Euro cents replace_existing : if set to TRUE replace all existing bids with a new one attributes (optional) : a dictionary of attributes that describes the bid (not supported at the moment) requirements (optional) : a list of dictionaries containing requirements for the bid. At least one of the provided dictionaries needs to be satisfied in the matching process. Currently supported requirements for bids are: energy_type: energy type of the offer (e.g. solar) time_slot (optional) : the time slot where the bid is going to be posted (to be used to trade post-delivery in the Settlement Market ) Here is an example: self.add_to_batch_commands.offer_energy(asset_uuid = \"2e7866d8-34c6-49ad-a388-fd5876a3e679\", energy = 2, price_cents = 60, replace_existing = True, attributes = \u201cPV\u201d, requirements = [{ \u201ctrading_partners\u201d: \"62f827ec-ef86-4782-b5c3-88327751d97d\u201d}], \u201ctime_slot\u201d = None) If the offer is placed successfully, it returns the detailed information about the bid. If not, it returns the reason for the error.","title":"offer_energy()"},{"location":"asset-api-commands/#offer_energy_rate","text":"It sends an energy offer to the exchange. This command receives four arguments : asset_uuid : Universal Unique Identifier of the selected asset energy : energy in kWh rate : price per volume in Euro cents/kWh replace_existing : if set to TRUE replace all existing offers with a new one requirements (optional) : a list of dictionaries containing requirements for the bid. At least one of the provided dictionaries needs to be satisfied in the matching process. Currently supported requirements for bids are: energy_type: energy type of the offer (e.g. solar) time_slot (optional) : the time slot where the bid is going to be posted (to be used to trade post-delivery in the Settlement Market ) Here is an example: self.add_to_batch_commands.offer_energy_rate(asset_uuid = \"2e7866d8-34c6-49ad-a388-fd5876a3e679\", energy = 2, rate = 30, replace_existing = True, attributes = \u201cPV\u201d, requirements = [{ \u201ctrading_partners\u201d: \"62f827ec-ef86-4782-b5c3-88327751d97d\u201d}], \u201ctime_slot\u201d = None)","title":"offer_energy_rate()"},{"location":"asset-api-commands/#lists_offers","text":"It lists all posted offers on the selected market. This command takes one argument: area_uuid, which is the Universal Unique Identifier of the selected market. Here is an example: self.add_to_batch_commands.list_offers(asset_uuid=\"62f827ec-ef86-4782-b5c3-88327751d97d\")","title":"lists_offers()"},{"location":"asset-api-commands/#delete_offer","text":"It deletes an offer posted on the market using its ID. This command receives two arguments : asset_uuid : Universal Unique Identifier of the selected asset offer_id : ID of the selected offer. If None, all the bids posted by the selected asset will be deleted. Here is an example: self.add_to_batch_commands.delete_offer(asset_uuid=\"62f827ec-ef86-4782-b5c3-88327751d97d\", bid_id = \"2e7866d8-3dg6-49ad-afe8-fd5876a3e679\")","title":"delete_offer()"},{"location":"asset-api-commands/#asset_info","text":"It gets asset information(returns required energy for Loads, available energy for PVs and energy to buy/sell for storages). This command receives one argument: asset_uuid, which is the Universal Unique Identifier of the selected asset. Here is an example: self.add_to_batch_commands.asset_info(asset_uuid=\"62f827ec-ef86-4782-b5c3-88327751d97d\") After adding all the wanted commands in the batch, the API can execute it with the following command: response = self.execute_batch_commands() In return the simulation will provide a detailed response for all commands submitted. Note: The total amount of energy to bid/offer at any point is limited to the energy requirement/available of the asset. Replacing/updating a bid/offer during a market slot deletes other active bids/offers. Additionally, the price of your bids/offers must be a positive float otherwise it will get rejected by the market.","title":"asset_info()"},{"location":"asset-api-events/","text":"Each market cycle lasts 15 minutes and is divided into 10 ticks until it ends. The bids and offers are posted within the market cycle at each tick until the cycle ends. Figure 4.2 . Market slot overall structure and Asset API events. At the beginning of each market slot, the Asset API receives markets and assets information structured in a nested dictionary according to the grid hierarchy. Each market provides statistics such as minimum, median and maximum trade rates, total energy volume traded, grid fees and each asset returns the last bills and energy volume traded in the previous market slot. At each tick of the market slot, the Asset API receives updated asset information (e.g. remaining energy to buy/sell) and can post/update/delete bids and offers. When the trade occurs, trade details are sent by the Asset API. If there are unmatched bids or offers, they are not carried to the next market cycle. In order to facilitate bid and offer management and scheduling, a python file with the class Oracle is provided. The Oracle class acts as an information aggregator for all of the energy assets (e.g. loads, PVs and storage) managed by the user, and allows the user to post bids and offers on their behalf. Several functions are triggered for different types of events , and can be overridden. Each new market slot \u00b6 def on_market_cycle(self, market_info): When a new market slot is available the client will get notified via an event. It is possible to capture this event and perform operations after it by overriding the on_market_cycle method, used to gather aggregated information about the assets and last market slot statistics, define the trading strategy and place the first bids/offers. In the variable market_info the user will get a dictionary with information on the market and assets. The user receives information for each asset he/she manages. The return values have the following structure: {'slot_completion': '0%', 'market_slot': '2014-10-01T00:15', 'grid_tree': {'477999f1-fd6e-4c68-8cc8-e8e52049de8e': {'last_market_bill': {'accumulated_trades': {}, 'external_trades': {}}, 'last_market_stats': {'min_trade_rate': 26.0, 'max_trade_rate': 26.0, 'avg_trade_rate': 26.0, 'median_trade_rate': 26.0, 'total_traded_energy_kWh': 7.5239405}, 'last_market_fee': 4, 'current_market_fee': 4, 'area_name': 'Grid', 'children': {'f02313bb-16c4-427b-90d2-d753822fe21c': {'last_market_bill': {'accumulated_trades': {}, 'external_trades': {}}, 'last_market_stats': {'min_trade_rate': 30.0, 'max_trade_rate': 30.0, 'avg_trade_rate': 30.0, 'median_trade_rate': 30.0, 'total_traded_energy_kWh': 7.5239405}, 'last_market_fee': 4, 'current_market_fee': 4, 'area_name': 'Community', 'children': {'44d19495-39e8-42e0-be2f-0432e644e5e5': {'last_market_bill': {'accumulated_trades': {}, 'external_trades': {}}, 'last_market_stats': {'min_trade_rate': None, 'max_trade_rate': None, 'avg_trade_rate': None, 'median_trade_rate': None, 'total_traded_energy_kWh': None}, 'last_market_fee': 0.0, 'current_market_fee': None, 'area_name': 'Member 1', 'children': {'075834dd-5438-4287-8393-781a4a8068f5': {'asset_info': {'energy_requirement_kWh': 0.06802025, 'energy_active_in_bids': 0.0, 'energy_traded': 0.0, 'total_cost': 0.0}, 'last_slot_asset_info': {'energy_traded': 0.0, 'total_cost': 0.0}, 'asset_bill': {}, 'area_name': 'Load 1'}, '2e7866d8-34c6-49ad-a388-fd5876a3e679': {'asset_info': {'available_energy_kWh': 0.0, 'energy_active_in_offers': 0, 'energy_traded': 0, 'total_cost': 0}, 'last_slot_asset_info': {'energy_traded': 0, 'total_cost': 0}, 'asset_bill': {}, 'area_name': 'PV 1'}, '22c495b2-4b2b-43ba-8c76-3eb956014975': {'asset_info': {'energy_to_sell': 0.0, 'energy_active_in_bids': 0, 'energy_to_buy': 1.36275, 'energy_active_in_offers': 0, 'free_storage': 10.0, 'used_storage': 0.0, 'energy_traded': 0.0, 'total_cost': 0.0}, 'last_slot_asset_info': {'energy_traded': 0.0, 'total_cost': 0.0}, 'asset_bill': {}, 'area_name': 'Storage 1'}}}, '5c0c05dd-2e23-4866-a113-e08797a2094e': {'last_market_bill': {'accumulated_trades': {}, 'external_trades': {}}, 'last_market_stats': {'min_trade_rate': 30.0, 'max_trade_rate': 30.0, 'avg_trade_rate': 30.0, 'median_trade_rate': 30.0, 'total_traded_energy_kWh': 0.064779}, 'last_market_fee': 0.0, 'current_market_fee': None, 'feed_in_tariff_rate': 21.9, 'market_maker_rate': 22, 'event': 'market', 'num_ticks': 10.0, 'simulation_id': None 'feed_in_tariff_rate': 21.9, 'market_maker_rate': 22, 'event': 'market', 'num_ticks': 10.0, 'simulation_id': None } On % of market completion \u00b6 def on_tick(self, tick_info): At each 10% of market slot completion (e.g. 10%, 20%, 30%, \u2026), the same information as market_info will be passed, with updated asset energy requirements based on trades. This can be used to update the user\u2019s bid or offer price at these milestones. On event or response \u00b6 def on_event_or_response(self, message): Each time the managed assets are triggered with an event or get any responses (from sending the batch commands such as trades confirmations), this information is repassed through on_event_or_response. This information can be stored locally or acted upon. On finish \u00b6 def on_finish(self, finish_info): This executes when the simulation finishes, and can be used to trigger exporting data, training a model or exiting the code.","title":"Asset API Events"},{"location":"asset-api-events/#each-new-market-slot","text":"def on_market_cycle(self, market_info): When a new market slot is available the client will get notified via an event. It is possible to capture this event and perform operations after it by overriding the on_market_cycle method, used to gather aggregated information about the assets and last market slot statistics, define the trading strategy and place the first bids/offers. In the variable market_info the user will get a dictionary with information on the market and assets. The user receives information for each asset he/she manages. The return values have the following structure: {'slot_completion': '0%', 'market_slot': '2014-10-01T00:15', 'grid_tree': {'477999f1-fd6e-4c68-8cc8-e8e52049de8e': {'last_market_bill': {'accumulated_trades': {}, 'external_trades': {}}, 'last_market_stats': {'min_trade_rate': 26.0, 'max_trade_rate': 26.0, 'avg_trade_rate': 26.0, 'median_trade_rate': 26.0, 'total_traded_energy_kWh': 7.5239405}, 'last_market_fee': 4, 'current_market_fee': 4, 'area_name': 'Grid', 'children': {'f02313bb-16c4-427b-90d2-d753822fe21c': {'last_market_bill': {'accumulated_trades': {}, 'external_trades': {}}, 'last_market_stats': {'min_trade_rate': 30.0, 'max_trade_rate': 30.0, 'avg_trade_rate': 30.0, 'median_trade_rate': 30.0, 'total_traded_energy_kWh': 7.5239405}, 'last_market_fee': 4, 'current_market_fee': 4, 'area_name': 'Community', 'children': {'44d19495-39e8-42e0-be2f-0432e644e5e5': {'last_market_bill': {'accumulated_trades': {}, 'external_trades': {}}, 'last_market_stats': {'min_trade_rate': None, 'max_trade_rate': None, 'avg_trade_rate': None, 'median_trade_rate': None, 'total_traded_energy_kWh': None}, 'last_market_fee': 0.0, 'current_market_fee': None, 'area_name': 'Member 1', 'children': {'075834dd-5438-4287-8393-781a4a8068f5': {'asset_info': {'energy_requirement_kWh': 0.06802025, 'energy_active_in_bids': 0.0, 'energy_traded': 0.0, 'total_cost': 0.0}, 'last_slot_asset_info': {'energy_traded': 0.0, 'total_cost': 0.0}, 'asset_bill': {}, 'area_name': 'Load 1'}, '2e7866d8-34c6-49ad-a388-fd5876a3e679': {'asset_info': {'available_energy_kWh': 0.0, 'energy_active_in_offers': 0, 'energy_traded': 0, 'total_cost': 0}, 'last_slot_asset_info': {'energy_traded': 0, 'total_cost': 0}, 'asset_bill': {}, 'area_name': 'PV 1'}, '22c495b2-4b2b-43ba-8c76-3eb956014975': {'asset_info': {'energy_to_sell': 0.0, 'energy_active_in_bids': 0, 'energy_to_buy': 1.36275, 'energy_active_in_offers': 0, 'free_storage': 10.0, 'used_storage': 0.0, 'energy_traded': 0.0, 'total_cost': 0.0}, 'last_slot_asset_info': {'energy_traded': 0.0, 'total_cost': 0.0}, 'asset_bill': {}, 'area_name': 'Storage 1'}}}, '5c0c05dd-2e23-4866-a113-e08797a2094e': {'last_market_bill': {'accumulated_trades': {}, 'external_trades': {}}, 'last_market_stats': {'min_trade_rate': 30.0, 'max_trade_rate': 30.0, 'avg_trade_rate': 30.0, 'median_trade_rate': 30.0, 'total_traded_energy_kWh': 0.064779}, 'last_market_fee': 0.0, 'current_market_fee': None, 'feed_in_tariff_rate': 21.9, 'market_maker_rate': 22, 'event': 'market', 'num_ticks': 10.0, 'simulation_id': None 'feed_in_tariff_rate': 21.9, 'market_maker_rate': 22, 'event': 'market', 'num_ticks': 10.0, 'simulation_id': None }","title":"Each new market slot"},{"location":"asset-api-events/#on-of-market-completion","text":"def on_tick(self, tick_info): At each 10% of market slot completion (e.g. 10%, 20%, 30%, \u2026), the same information as market_info will be passed, with updated asset energy requirements based on trades. This can be used to update the user\u2019s bid or offer price at these milestones.","title":"On % of market completion"},{"location":"asset-api-events/#on-event-or-response","text":"def on_event_or_response(self, message): Each time the managed assets are triggered with an event or get any responses (from sending the batch commands such as trades confirmations), this information is repassed through on_event_or_response. This information can be stored locally or acted upon.","title":"On event or response"},{"location":"asset-api-events/#on-finish","text":"def on_finish(self, finish_info): This executes when the simulation finishes, and can be used to trigger exporting data, training a model or exiting the code.","title":"On finish"},{"location":"asset-api-template-script/","text":"Asset API template scripts are flexible and versatile Python scripts that can be easily modified for the implementation of custom smart trading strategies, integration of trading preferences ( Degrees of Freedom ), interaction with the Settlement Market and other uses. In this section, each script will be described along with its functionalities, in order of complexity. Post bids and offers to the Grid Singularity Exchange \u00b6 The key functionality of the Asset API is to post bids or offers to the Grid Singularity Exchange on behalf of energy asset owners based on their preferences. A template script can be found here . Users need to list the names of the assets to be connected with the Asset API, as shown in the following example. For simulations launched from the user-interface (UI), the CONNECT_TO_ALL_ASSETS parameter is available. If set to True, the Asset API connects automatically to all the assets the aggregator is connected to. # List of assets' names to be connected with the API LOAD_NAMES = [\"Load 1 L13\", \"Load 2 L21\", \"Load 3 L17\"] PV_NAMES = [\"PV 1 (4kW)\", \"PV 3 (5kW)\"] STORAGE_NAMES = [\"Tesla Powerwall 3\"] CONNECT_TO_ALL_ASSETS = True The goal of this template script is to send, at each market slot , a bid and/or an offer for each energy asset. This is performed by the post_bid_offer function, which loops through all the assets connected with the Asset API, extracts their required or available energy and posts these values along with an associated rate for clearance and settlement by the Grid Singularity Exchange. As shown in the snippet below, the process is separated for consumption, generation and storage assets. def post_bid_offer(self): \"\"\"Post a bid or an offer to the exchange.\"\"\" for area_uuid, area_dict in self.latest_grid_tree_flat.items(): asset_info = area_dict.get(\"asset_info\") if not asset_info: continue # Consumption assets required_energy = asset_info.get(\"energy_requirement_kWh\") if required_energy: self.add_to_batch_commands.bid_energy_rate( asset_uuid=area_uuid, rate=10, energy=required_energy ) # Generation assets available_energy = asset_info.get(\"available_energy_kWh\") if available_energy: self.add_to_batch_commands.offer_energy_rate( asset_uuid=area_uuid, rate=10, energy=available_energy ) # Storage assets buy_energy = asset_info.get(\"energy_to_buy\") if buy_energy: self.add_to_batch_commands.bid_energy_rate( asset_uuid=area_uuid, rate=10, energy=buy_energy ) sell_energy = asset_info.get(\"energy_to_sell\") if sell_energy: self.add_to_batch_commands.offer_energy_rate( asset_uuid=area_uuid, rate=10, energy=sell_energy ) self.execute_batch_commands() Later in the script, the on_event_or_response is called. By default, the Asset API template does not perform any operation here but the user can add events . For instance, the user could record all the trades occurring in that event. Lastly, the script overwrites the on_finish event so that when this function is triggered, the script stops. If the user wishes to save any information reported in the logs, this can be done by exporting it to an external file. def on_event_or_response(self, message): pass def on_finish(self, finish_info): self.is_finished = True The rest of the script is used to connect to the energy assets of a running simulation / collaboration / Canary Test Network , with the purpose of actively placing bids and offers on their behalf. aggregator = Oracle(aggregator_name=ORACLE_NAME) simulation_id = os.environ[\"API_CLIENT_SIMULATION_ID\"] domain_name = os.environ[\"API_CLIENT_DOMAIN_NAME\"] websockets_domain_name = os.environ[\"API_CLIENT_WEBSOCKET_DOMAIN_NAME\"] asset_args = {\"autoregister\": False, \"start_websocket\": False} if CONNECT_TO_ALL_ASSETS: registry = aggregator.get_configuration_registry() registered_assets = get_assets_name(registry) LOAD_NAMES = registered_assets[\"Load\"] PV_NAMES = registered_assets[\"PV\"] STORAGE_NAMES = registered_assets[\"Storage\"] def register_asset_list(asset_names: List, asset_params: Dict, asset_uuid_map: Dict) -> Dict: \"\"\"Register the provided list of assets with the aggregator.\"\"\" for asset_name in asset_names: print(\"Registered asset:\", asset_name) uuid = get_area_uuid_from_area_name_and_collaboration_id( simulation_id, asset_name, domain_name ) asset_params[\"asset_uuid\"] = uuid asset_uuid_map[uuid] = asset_name asset = RestAssetClient(**asset_params) asset.select_aggregator(aggregator.aggregator_uuid) return asset_uuid_map print() print(\"Registering assets ...\") asset_uuid_mapping = {} asset_uuid_mapping = register_asset_list(LOAD_NAMES + PV_NAMES + STORAGE_NAMES, asset_args, asset_uuid_mapping) print() print(\"Summary of assets registered:\") print() print(asset_uuid_mapping) # loop to allow persistence while not aggregator.is_finished: sleep(0.5) For simulations run in the backend, a similar script is available here . Implement trading strategies \u00b6 One of the main functionalities provided by the Asset API is to implement customized trading strategies. The Asset API script stores energy assets information such as the energy requirements for the loads , the energy available for the PVs and the State of Charge for the storage . This information when aggregated could be valuable when designing a smarter trading strategy. A template script can be found here . At the beginning of the on_market_slot event, the script generates the trading strategies (in the build_strategies function). The Market Maker price and the Feed-in Tariff values are required to set the pricing boundaries for the trading strategy. fit_rate = market_info[\"feed_in_tariff_rate\"] market_maker_rate = market_info[\"market_maker_rate\"] med_price = (market_maker_rate - fit_rate) / 2 + fit_rate Then, the script creates the asset_strategy dictionary, which contains various information for each asset, such as its name, its type (load, PV or storage) and the grid fees between the assets and the market maker. To calculate the grid fees between two assets or markets in the grid, the calculate_grid_fee function is used,which takes 3 arguments: start_market_or_asset_name : UUID of the started market/asset target_market_or_asset_name : UUID of the targeted market/asset fee_type : can either be \"current_market_fee\" or \u201clast_market_fee\u201d The fees are integrated in the pricing strategy in order to avoid any power outages for the loads or PV curtailment. for area_uuid, area_dict in self.latest_grid_tree_flat.items(): if \"asset_info\" not in area_dict or area_dict[\"asset_info\"] is None: continue self.asset_strategy[area_uuid] = {} self.asset_strategy[area_uuid][\"asset_name\"] = area_dict[\"area_name\"] self.asset_strategy[area_uuid][ \"fee_to_market_maker\" ] = self.calculate_grid_fee( area_uuid, self.get_uuid_from_area_name(\"Market Maker\"), \"current_market_fee\", ) Lastly, in the asset_strategy dictionary, the pricing strategy is defined for each asset individually. This allows assets to have independent strategies depending on the available market information and their location in the grid. The current pricing strategies are deterministic, representing a linear function bounded between the Feed-in Tariff-grid fee (lower boundary) and the Market Maker price + grid fee (upper boundary). Since the Asset API can post up to 10 bids/offers per market slot, the strategies incrementally ramp up (bids) or down (offers) for a total of 10 prices per energy asset. The final bid/offer price is set at least 2 ticks before the end of the market slot (9th and 10th tick in the example). The load strategy, the PV strategy and the storage strategy, as assets that can charge and discharge and therefore place bids and offers at the same time, are designed as follows. # Consumption strategy if \"energy_requirement_kWh\" in area_dict[\"asset_info\"]: load_strategy = [] for tick in range(0, TICKS): if tick < TICKS - 2: buy_rate = (fit_rate - self.asset_strategy[area_uuid][\"fee_to_market_maker\"] + (market_maker_rate + 2 * self.asset_strategy[area_uuid][\"fee_to_market_maker\"] - fit_rate) * (tick / TICKS) ) load_strategy.append(buy_rate) else: buy_rate = market_maker_rate + ( self.asset_strategy[area_uuid][\"fee_to_market_maker\"]) load_strategy.append(buy_rate) self.asset_strategy[area_uuid][\"buy_rates\"] = load_strategy # Generation strategy if \"available_energy_kWh\" in area_dict[\"asset_info\"]: gen_strategy = [] for tick in range(0, TICKS): if tick < TICKS - 2: sell_rate = (market_maker_rate + self.asset_strategy[area_uuid][\"fee_to_market_maker\"] - (market_maker_rate + 2 * self.asset_strategy[area_uuid][\"fee_to_market_maker\"] - fit_rate) * (tick / TICKS) ) gen_strategy.append(max(0, sell_rate)) else: sell_rate = fit_rate - ( self.asset_strategy[area_uuid][\"fee_to_market_maker\"]) gen_strategy.append(max(0, sell_rate)) self.asset_strategy[area_uuid][\"sell_rates\"] = gen_strategy # Storage strategy if \"used_storage\" in area_dict[\"asset_info\"]: batt_buy_strategy = [] batt_sell_strategy = [] for tick in range(0, TICKS): buy_rate = (fit_rate - self.asset_strategy[area_uuid][\"fee_to_market_maker\"] + (med_price - (fit_rate - self.asset_strategy[area_uuid][\"fee_to_market_maker\"] ) ) * (tick / TICKS) ) batt_buy_strategy.append(buy_rate) sell_rate = (market_maker_rate + self.asset_strategy[area_uuid][\"fee_to_market_maker\"] - (market_maker_rate + self.asset_strategy[area_uuid][\"fee_to_market_maker\"] - med_price) * (tick / TICKS) ) batt_sell_strategy.append(sell_rate) self.asset_strategy[area_uuid][\"buy_rates\"] = batt_buy_strategy self.asset_strategy[area_uuid][\"sell_rates\"] = batt_sell_strategy At each on_tick event, the Asset API will post new bids and offers, or update / delete existing ones. This allows the Exchange SDK to update their price strategy until all consumption and generation have been traded. In the following lines the Exchange SDK updates the existing bids/offers with new prices to optimize trades. The updated energy information is found in latest_grid_tree_flat.items() and the prices for each bid/offer depend on the market slot progression. All the commands are then executed. def post_bid_offer(self, rate_index=0): \"\"\"Post a bid or an offer to the exchange.\"\"\" for area_uuid, area_dict in self.latest_grid_tree_flat.items(): asset_info = area_dict.get(\"asset_info\") if not asset_info: continue # Consumption assets required_energy = asset_info.get(\"energy_requirement_kWh\") if required_energy: rate = self.asset_strategy[area_uuid][\"buy_rates\"][rate_index] self.add_to_batch_commands.bid_energy_rate( asset_uuid=area_uuid, rate=rate, energy=required_energy ) # Generation assets available_energy = asset_info.get(\"available_energy_kWh\") if available_energy: rate = self.asset_strategy[area_uuid][\"sell_rates\"][rate_index] self.add_to_batch_commands.offer_energy_rate( asset_uuid=area_uuid, rate=rate, energy=available_energy ) # Storage assets buy_energy = asset_info.get(\"energy_to_buy\") if buy_energy: buy_rate = self.asset_strategy[area_uuid][\"buy_rates\"][rate_index] self.add_to_batch_commands.bid_energy_rate( asset_uuid=area_uuid, rate=buy_rate, energy=buy_energy ) sell_energy = asset_info.get(\"energy_to_sell\") if sell_energy: sell_rate = self.asset_strategy[area_uuid][\"sell_rates\"][rate_index] self.add_to_batch_commands.offer_energy_rate( asset_uuid=area_uuid, rate=sell_rate, energy=sell_energy ) self.execute_batch_commands() The rest of the script functionality has been covered in the previous section . For simulations run in the backend, a similar script is available here . Introduce trading preferences with the Degrees of Freedom \u00b6 With the Asset API, users also have the option to specify trading preferences for each asset, such as preferred trading partners, energy type, energy amount and rate. An example of such a script can be found here . These preferences are also known as requirements and attributes or \u201cdegrees of freedom\u201d, as explained here . Requirements are uploaded to the template script via a JSON file (an example can be found here ), which has the following structure: { \"Load 3 L17\":[ { \"Trading Partners\": [\"PV 9 (15kW)\"], \"Energy Types\": [], \"Energy\": \"None\", \"Rate\": \"None\" } ], \"Load 2 L21\":[ { \"Trading Partners\": [\"PV 5 (10kW)\"], \"Energy Types\": [], \"Energy\": 10, \"Rate\": 3 } ], \"Load 1 L13\":[ { \"Trading Partners\": [], \"Energy Types\": [], \"Energy\": \"None\", \"Rate\": \"None\" } ] } In this example it is shown how, for each load, the four above mentioned requirements are listed and specified in value. It is also possible not to set any specific requirement to an asset, as for Load 1 L13. If, for example, \u201cEnergy\u201d and \u201cRate\u201d are set to None, the default energy and rate values from the template trading strategies are assigned. At each market slot , the Asset API loads and reads the information contained in this JSON file with the following function: def read_requirements(self): \"\"\"Load the JSON file containing the list of requirements for each asset.\"\"\" with open( os.path.join(module_dir, \"resources/requirements.json\"), \"r\", encoding=\"utf-8\", ) as file: self.degrees_of_freedom = json.load(file) Subsequently, a bid with the associated requirements is posted to the Exchange (for more on how to post bids and offers please see here .) The requirements uploaded through the JSON file must be converted to the correct format ahead of submission to the Exchange. To do so, the build_requirements_dict function is used: def build_requirements_dict(self, rate, energy, area_name): \"\"\"Return a dictionary with the requirements of the asset.\"\"\" asset_dof_list = self.degrees_of_freedom[area_name] for asset_dof in asset_dof_list: id_trading_partners_list = get_partner_ids(asset_dof[\"Trading Partners\"]) energy_types_list = asset_dof[\"Energy Types\"] energy_requirement = ( energy if asset_dof[\"Energy\"] == \"None\" else min(asset_dof[\"Energy\"], energy) ) rate_requirement = ( rate if asset_dof[\"Rate\"] == \"None\" else asset_dof[\"Rate\"] ) requirements = [ { \"trading_partners\": id_trading_partners_list, \"energy_type\": energy_types_list, \"energy\": energy_requirement, \"price\": rate_requirement * energy_requirement, } ] return requirements The rest of the script functionality has been covered in the previous section . It is important to note that currently there is no available template script for introducing degrees of freedom from the UI, but solely from the backend . Send live data to a Canary Test Network \u00b6 As noted here , the Asset API has the functionality to send live data to Grid Singularity Canary Test Network . A template script can be found here . To do so, at each market slot , forecast for the next 15 minutes are sent through the following function: def send_forecasts(self, market_info): \"\"\"Send forecasts of the next market slot to the exchange.\"\"\" forecast_market_slot = ( from_format(market_info[\"market_slot\"], DATE_TIME_FORMAT) .add(minutes=15) .format(DATE_TIME_FORMAT) ) # pylint: disable=unused-variable for area_uuid, area_dict in self.latest_grid_tree_flat.items(): asset_info = area_dict.get(\"asset_info\") if not asset_info: continue # Consumption assets if \"energy_requirement_kWh\" in asset_info: asset_name = area_dict[\"area_name\"] globals()[f\"{asset_name}\"].set_energy_forecast( energy_forecast_kWh={forecast_market_slot: 1.2}, do_not_wait=False, ) # Generation assets if \"available_energy_kWh\" in asset_info: asset_name = area_dict[\"area_name\"] globals()[f\"{asset_name}\"].set_energy_forecast( energy_forecast_kWh={forecast_market_slot: 0.86}, do_not_wait=False, ) self.execute_batch_commands() The forecast_market_slot , namely the marker slot at which the forecasted value is sent, is first retrieved by the market_info dictionary. Then, the set_energy_forecast function is used to send consumption / generation forecasted values to the Grid Singularity Exchange. In this example, 1.2 kWh are sent as consumption forecasts and 0.86 kWh are sent as generation forecasts. The rest of the script functionality has been covered in the previous section . Post energy deviations in the Settlement Market \u00b6 Finally, the Asset API can also be used to post energy deviations between forecasts (namely the values of consumption or generation that an asset was expected to consume or produce) and measurements (namely the actual consumption or generation values) in the Settlement Market . A template script can be found here . As noted in the previous section, users can send forecasts (generated by assets or other data source) to the Grid Singularity Exchange by using the Asset API. To settle energy deviations in the Settlement Market, further action is needed, which is to send measurements to the Exchange at each market slot by using the following function: def send_measurements(self, market_info): \"\"\"Send measurements for the current market slot to the exchange.\"\"\" # pylint: disable=unused-variable for area_uuid, area_dict in self.latest_grid_tree_flat.items(): if \"asset_info\" not in area_dict or area_dict[\"asset_info\"] is None: continue # Consumption assets if \"energy_requirement_kWh\" in area_dict[\"asset_info\"]: self.add_to_batch_commands.set_energy_measurement( asset_uuid=area_uuid, energy_measurement_kWh={market_info[\"market_slot\"]: 1.23}, ) # Generation assets if \"available_energy_kWh\" in area_dict[\"asset_info\"]: self.add_to_batch_commands.set_energy_measurement( asset_uuid=area_uuid, energy_measurement_kWh={market_info[\"market_slot\"]: 0.87}, ) As shown in the snippet above, set_energy_measurement is used to send values to the Exchange which, in this example, are sent to the current market slot. Later, in settle_energy_deviation , the Asset API computes the difference between the forecast and measured values, called in the script unsettled_deviation . Depending on whether this value is positive or negative, a bid or an offer will be posted in the Settlement Market. The rate, as well as the time slot for order placement can be arbitrarily set by the user. Below is the snippet of the described function: def settle_energy_deviations(self): \"\"\"Post the energy deviations between forecasts and measurements in the Settlement market.\"\"\" for area_uuid, area_dict in self.latest_grid_tree_flat.items(): if not area_dict.get(\"asset_info\"): continue time_slot = ( list(area_dict[\"asset_info\"][\"unsettled_deviation_kWh\"].keys())[-1]) unsettled_deviation = area_dict[\"asset_info\"][ \"unsettled_deviation_kWh\" ].get(time_slot) if unsettled_deviation > 0: self.add_to_batch_commands.bid_energy_rate( asset_uuid=area_uuid, rate=5, energy=unsettled_deviation, time_slot=time_slot, ) if unsettled_deviation < 0: self.add_to_batch_commands.offer_energy_rate( asset_uuid=area_uuid, rate=10, energy=abs(unsettled_deviation), time_slot=time_slot, ) The rest of the script functionality has been covered in the previous section . It is important to note that currently there is no available template script for interacting with the Settlement Market from the UI, but solely from the backend . The next step is to adapt the Asset API template scripts developed by Grid Singularity to customize your trading strategies, whether to send live data to the Grid Singularity Canary Test Network or to interact with the Settlement Market .","title":"Asset API Template Script"},{"location":"asset-api-template-script/#post-bids-and-offers-to-the-grid-singularity-exchange","text":"The key functionality of the Asset API is to post bids or offers to the Grid Singularity Exchange on behalf of energy asset owners based on their preferences. A template script can be found here . Users need to list the names of the assets to be connected with the Asset API, as shown in the following example. For simulations launched from the user-interface (UI), the CONNECT_TO_ALL_ASSETS parameter is available. If set to True, the Asset API connects automatically to all the assets the aggregator is connected to. # List of assets' names to be connected with the API LOAD_NAMES = [\"Load 1 L13\", \"Load 2 L21\", \"Load 3 L17\"] PV_NAMES = [\"PV 1 (4kW)\", \"PV 3 (5kW)\"] STORAGE_NAMES = [\"Tesla Powerwall 3\"] CONNECT_TO_ALL_ASSETS = True The goal of this template script is to send, at each market slot , a bid and/or an offer for each energy asset. This is performed by the post_bid_offer function, which loops through all the assets connected with the Asset API, extracts their required or available energy and posts these values along with an associated rate for clearance and settlement by the Grid Singularity Exchange. As shown in the snippet below, the process is separated for consumption, generation and storage assets. def post_bid_offer(self): \"\"\"Post a bid or an offer to the exchange.\"\"\" for area_uuid, area_dict in self.latest_grid_tree_flat.items(): asset_info = area_dict.get(\"asset_info\") if not asset_info: continue # Consumption assets required_energy = asset_info.get(\"energy_requirement_kWh\") if required_energy: self.add_to_batch_commands.bid_energy_rate( asset_uuid=area_uuid, rate=10, energy=required_energy ) # Generation assets available_energy = asset_info.get(\"available_energy_kWh\") if available_energy: self.add_to_batch_commands.offer_energy_rate( asset_uuid=area_uuid, rate=10, energy=available_energy ) # Storage assets buy_energy = asset_info.get(\"energy_to_buy\") if buy_energy: self.add_to_batch_commands.bid_energy_rate( asset_uuid=area_uuid, rate=10, energy=buy_energy ) sell_energy = asset_info.get(\"energy_to_sell\") if sell_energy: self.add_to_batch_commands.offer_energy_rate( asset_uuid=area_uuid, rate=10, energy=sell_energy ) self.execute_batch_commands() Later in the script, the on_event_or_response is called. By default, the Asset API template does not perform any operation here but the user can add events . For instance, the user could record all the trades occurring in that event. Lastly, the script overwrites the on_finish event so that when this function is triggered, the script stops. If the user wishes to save any information reported in the logs, this can be done by exporting it to an external file. def on_event_or_response(self, message): pass def on_finish(self, finish_info): self.is_finished = True The rest of the script is used to connect to the energy assets of a running simulation / collaboration / Canary Test Network , with the purpose of actively placing bids and offers on their behalf. aggregator = Oracle(aggregator_name=ORACLE_NAME) simulation_id = os.environ[\"API_CLIENT_SIMULATION_ID\"] domain_name = os.environ[\"API_CLIENT_DOMAIN_NAME\"] websockets_domain_name = os.environ[\"API_CLIENT_WEBSOCKET_DOMAIN_NAME\"] asset_args = {\"autoregister\": False, \"start_websocket\": False} if CONNECT_TO_ALL_ASSETS: registry = aggregator.get_configuration_registry() registered_assets = get_assets_name(registry) LOAD_NAMES = registered_assets[\"Load\"] PV_NAMES = registered_assets[\"PV\"] STORAGE_NAMES = registered_assets[\"Storage\"] def register_asset_list(asset_names: List, asset_params: Dict, asset_uuid_map: Dict) -> Dict: \"\"\"Register the provided list of assets with the aggregator.\"\"\" for asset_name in asset_names: print(\"Registered asset:\", asset_name) uuid = get_area_uuid_from_area_name_and_collaboration_id( simulation_id, asset_name, domain_name ) asset_params[\"asset_uuid\"] = uuid asset_uuid_map[uuid] = asset_name asset = RestAssetClient(**asset_params) asset.select_aggregator(aggregator.aggregator_uuid) return asset_uuid_map print() print(\"Registering assets ...\") asset_uuid_mapping = {} asset_uuid_mapping = register_asset_list(LOAD_NAMES + PV_NAMES + STORAGE_NAMES, asset_args, asset_uuid_mapping) print() print(\"Summary of assets registered:\") print() print(asset_uuid_mapping) # loop to allow persistence while not aggregator.is_finished: sleep(0.5) For simulations run in the backend, a similar script is available here .","title":"Post bids and offers to the Grid Singularity Exchange"},{"location":"asset-api-template-script/#implement-trading-strategies","text":"One of the main functionalities provided by the Asset API is to implement customized trading strategies. The Asset API script stores energy assets information such as the energy requirements for the loads , the energy available for the PVs and the State of Charge for the storage . This information when aggregated could be valuable when designing a smarter trading strategy. A template script can be found here . At the beginning of the on_market_slot event, the script generates the trading strategies (in the build_strategies function). The Market Maker price and the Feed-in Tariff values are required to set the pricing boundaries for the trading strategy. fit_rate = market_info[\"feed_in_tariff_rate\"] market_maker_rate = market_info[\"market_maker_rate\"] med_price = (market_maker_rate - fit_rate) / 2 + fit_rate Then, the script creates the asset_strategy dictionary, which contains various information for each asset, such as its name, its type (load, PV or storage) and the grid fees between the assets and the market maker. To calculate the grid fees between two assets or markets in the grid, the calculate_grid_fee function is used,which takes 3 arguments: start_market_or_asset_name : UUID of the started market/asset target_market_or_asset_name : UUID of the targeted market/asset fee_type : can either be \"current_market_fee\" or \u201clast_market_fee\u201d The fees are integrated in the pricing strategy in order to avoid any power outages for the loads or PV curtailment. for area_uuid, area_dict in self.latest_grid_tree_flat.items(): if \"asset_info\" not in area_dict or area_dict[\"asset_info\"] is None: continue self.asset_strategy[area_uuid] = {} self.asset_strategy[area_uuid][\"asset_name\"] = area_dict[\"area_name\"] self.asset_strategy[area_uuid][ \"fee_to_market_maker\" ] = self.calculate_grid_fee( area_uuid, self.get_uuid_from_area_name(\"Market Maker\"), \"current_market_fee\", ) Lastly, in the asset_strategy dictionary, the pricing strategy is defined for each asset individually. This allows assets to have independent strategies depending on the available market information and their location in the grid. The current pricing strategies are deterministic, representing a linear function bounded between the Feed-in Tariff-grid fee (lower boundary) and the Market Maker price + grid fee (upper boundary). Since the Asset API can post up to 10 bids/offers per market slot, the strategies incrementally ramp up (bids) or down (offers) for a total of 10 prices per energy asset. The final bid/offer price is set at least 2 ticks before the end of the market slot (9th and 10th tick in the example). The load strategy, the PV strategy and the storage strategy, as assets that can charge and discharge and therefore place bids and offers at the same time, are designed as follows. # Consumption strategy if \"energy_requirement_kWh\" in area_dict[\"asset_info\"]: load_strategy = [] for tick in range(0, TICKS): if tick < TICKS - 2: buy_rate = (fit_rate - self.asset_strategy[area_uuid][\"fee_to_market_maker\"] + (market_maker_rate + 2 * self.asset_strategy[area_uuid][\"fee_to_market_maker\"] - fit_rate) * (tick / TICKS) ) load_strategy.append(buy_rate) else: buy_rate = market_maker_rate + ( self.asset_strategy[area_uuid][\"fee_to_market_maker\"]) load_strategy.append(buy_rate) self.asset_strategy[area_uuid][\"buy_rates\"] = load_strategy # Generation strategy if \"available_energy_kWh\" in area_dict[\"asset_info\"]: gen_strategy = [] for tick in range(0, TICKS): if tick < TICKS - 2: sell_rate = (market_maker_rate + self.asset_strategy[area_uuid][\"fee_to_market_maker\"] - (market_maker_rate + 2 * self.asset_strategy[area_uuid][\"fee_to_market_maker\"] - fit_rate) * (tick / TICKS) ) gen_strategy.append(max(0, sell_rate)) else: sell_rate = fit_rate - ( self.asset_strategy[area_uuid][\"fee_to_market_maker\"]) gen_strategy.append(max(0, sell_rate)) self.asset_strategy[area_uuid][\"sell_rates\"] = gen_strategy # Storage strategy if \"used_storage\" in area_dict[\"asset_info\"]: batt_buy_strategy = [] batt_sell_strategy = [] for tick in range(0, TICKS): buy_rate = (fit_rate - self.asset_strategy[area_uuid][\"fee_to_market_maker\"] + (med_price - (fit_rate - self.asset_strategy[area_uuid][\"fee_to_market_maker\"] ) ) * (tick / TICKS) ) batt_buy_strategy.append(buy_rate) sell_rate = (market_maker_rate + self.asset_strategy[area_uuid][\"fee_to_market_maker\"] - (market_maker_rate + self.asset_strategy[area_uuid][\"fee_to_market_maker\"] - med_price) * (tick / TICKS) ) batt_sell_strategy.append(sell_rate) self.asset_strategy[area_uuid][\"buy_rates\"] = batt_buy_strategy self.asset_strategy[area_uuid][\"sell_rates\"] = batt_sell_strategy At each on_tick event, the Asset API will post new bids and offers, or update / delete existing ones. This allows the Exchange SDK to update their price strategy until all consumption and generation have been traded. In the following lines the Exchange SDK updates the existing bids/offers with new prices to optimize trades. The updated energy information is found in latest_grid_tree_flat.items() and the prices for each bid/offer depend on the market slot progression. All the commands are then executed. def post_bid_offer(self, rate_index=0): \"\"\"Post a bid or an offer to the exchange.\"\"\" for area_uuid, area_dict in self.latest_grid_tree_flat.items(): asset_info = area_dict.get(\"asset_info\") if not asset_info: continue # Consumption assets required_energy = asset_info.get(\"energy_requirement_kWh\") if required_energy: rate = self.asset_strategy[area_uuid][\"buy_rates\"][rate_index] self.add_to_batch_commands.bid_energy_rate( asset_uuid=area_uuid, rate=rate, energy=required_energy ) # Generation assets available_energy = asset_info.get(\"available_energy_kWh\") if available_energy: rate = self.asset_strategy[area_uuid][\"sell_rates\"][rate_index] self.add_to_batch_commands.offer_energy_rate( asset_uuid=area_uuid, rate=rate, energy=available_energy ) # Storage assets buy_energy = asset_info.get(\"energy_to_buy\") if buy_energy: buy_rate = self.asset_strategy[area_uuid][\"buy_rates\"][rate_index] self.add_to_batch_commands.bid_energy_rate( asset_uuid=area_uuid, rate=buy_rate, energy=buy_energy ) sell_energy = asset_info.get(\"energy_to_sell\") if sell_energy: sell_rate = self.asset_strategy[area_uuid][\"sell_rates\"][rate_index] self.add_to_batch_commands.offer_energy_rate( asset_uuid=area_uuid, rate=sell_rate, energy=sell_energy ) self.execute_batch_commands() The rest of the script functionality has been covered in the previous section . For simulations run in the backend, a similar script is available here .","title":"Implement trading strategies"},{"location":"asset-api-template-script/#introduce-trading-preferences-with-the-degrees-of-freedom","text":"With the Asset API, users also have the option to specify trading preferences for each asset, such as preferred trading partners, energy type, energy amount and rate. An example of such a script can be found here . These preferences are also known as requirements and attributes or \u201cdegrees of freedom\u201d, as explained here . Requirements are uploaded to the template script via a JSON file (an example can be found here ), which has the following structure: { \"Load 3 L17\":[ { \"Trading Partners\": [\"PV 9 (15kW)\"], \"Energy Types\": [], \"Energy\": \"None\", \"Rate\": \"None\" } ], \"Load 2 L21\":[ { \"Trading Partners\": [\"PV 5 (10kW)\"], \"Energy Types\": [], \"Energy\": 10, \"Rate\": 3 } ], \"Load 1 L13\":[ { \"Trading Partners\": [], \"Energy Types\": [], \"Energy\": \"None\", \"Rate\": \"None\" } ] } In this example it is shown how, for each load, the four above mentioned requirements are listed and specified in value. It is also possible not to set any specific requirement to an asset, as for Load 1 L13. If, for example, \u201cEnergy\u201d and \u201cRate\u201d are set to None, the default energy and rate values from the template trading strategies are assigned. At each market slot , the Asset API loads and reads the information contained in this JSON file with the following function: def read_requirements(self): \"\"\"Load the JSON file containing the list of requirements for each asset.\"\"\" with open( os.path.join(module_dir, \"resources/requirements.json\"), \"r\", encoding=\"utf-8\", ) as file: self.degrees_of_freedom = json.load(file) Subsequently, a bid with the associated requirements is posted to the Exchange (for more on how to post bids and offers please see here .) The requirements uploaded through the JSON file must be converted to the correct format ahead of submission to the Exchange. To do so, the build_requirements_dict function is used: def build_requirements_dict(self, rate, energy, area_name): \"\"\"Return a dictionary with the requirements of the asset.\"\"\" asset_dof_list = self.degrees_of_freedom[area_name] for asset_dof in asset_dof_list: id_trading_partners_list = get_partner_ids(asset_dof[\"Trading Partners\"]) energy_types_list = asset_dof[\"Energy Types\"] energy_requirement = ( energy if asset_dof[\"Energy\"] == \"None\" else min(asset_dof[\"Energy\"], energy) ) rate_requirement = ( rate if asset_dof[\"Rate\"] == \"None\" else asset_dof[\"Rate\"] ) requirements = [ { \"trading_partners\": id_trading_partners_list, \"energy_type\": energy_types_list, \"energy\": energy_requirement, \"price\": rate_requirement * energy_requirement, } ] return requirements The rest of the script functionality has been covered in the previous section . It is important to note that currently there is no available template script for introducing degrees of freedom from the UI, but solely from the backend .","title":"Introduce trading preferences with the Degrees of Freedom"},{"location":"asset-api-template-script/#send-live-data-to-a-canary-test-network","text":"As noted here , the Asset API has the functionality to send live data to Grid Singularity Canary Test Network . A template script can be found here . To do so, at each market slot , forecast for the next 15 minutes are sent through the following function: def send_forecasts(self, market_info): \"\"\"Send forecasts of the next market slot to the exchange.\"\"\" forecast_market_slot = ( from_format(market_info[\"market_slot\"], DATE_TIME_FORMAT) .add(minutes=15) .format(DATE_TIME_FORMAT) ) # pylint: disable=unused-variable for area_uuid, area_dict in self.latest_grid_tree_flat.items(): asset_info = area_dict.get(\"asset_info\") if not asset_info: continue # Consumption assets if \"energy_requirement_kWh\" in asset_info: asset_name = area_dict[\"area_name\"] globals()[f\"{asset_name}\"].set_energy_forecast( energy_forecast_kWh={forecast_market_slot: 1.2}, do_not_wait=False, ) # Generation assets if \"available_energy_kWh\" in asset_info: asset_name = area_dict[\"area_name\"] globals()[f\"{asset_name}\"].set_energy_forecast( energy_forecast_kWh={forecast_market_slot: 0.86}, do_not_wait=False, ) self.execute_batch_commands() The forecast_market_slot , namely the marker slot at which the forecasted value is sent, is first retrieved by the market_info dictionary. Then, the set_energy_forecast function is used to send consumption / generation forecasted values to the Grid Singularity Exchange. In this example, 1.2 kWh are sent as consumption forecasts and 0.86 kWh are sent as generation forecasts. The rest of the script functionality has been covered in the previous section .","title":"Send live data to a Canary Test Network"},{"location":"asset-api-template-script/#post-energy-deviations-in-the-settlement-market","text":"Finally, the Asset API can also be used to post energy deviations between forecasts (namely the values of consumption or generation that an asset was expected to consume or produce) and measurements (namely the actual consumption or generation values) in the Settlement Market . A template script can be found here . As noted in the previous section, users can send forecasts (generated by assets or other data source) to the Grid Singularity Exchange by using the Asset API. To settle energy deviations in the Settlement Market, further action is needed, which is to send measurements to the Exchange at each market slot by using the following function: def send_measurements(self, market_info): \"\"\"Send measurements for the current market slot to the exchange.\"\"\" # pylint: disable=unused-variable for area_uuid, area_dict in self.latest_grid_tree_flat.items(): if \"asset_info\" not in area_dict or area_dict[\"asset_info\"] is None: continue # Consumption assets if \"energy_requirement_kWh\" in area_dict[\"asset_info\"]: self.add_to_batch_commands.set_energy_measurement( asset_uuid=area_uuid, energy_measurement_kWh={market_info[\"market_slot\"]: 1.23}, ) # Generation assets if \"available_energy_kWh\" in area_dict[\"asset_info\"]: self.add_to_batch_commands.set_energy_measurement( asset_uuid=area_uuid, energy_measurement_kWh={market_info[\"market_slot\"]: 0.87}, ) As shown in the snippet above, set_energy_measurement is used to send values to the Exchange which, in this example, are sent to the current market slot. Later, in settle_energy_deviation , the Asset API computes the difference between the forecast and measured values, called in the script unsettled_deviation . Depending on whether this value is positive or negative, a bid or an offer will be posted in the Settlement Market. The rate, as well as the time slot for order placement can be arbitrarily set by the user. Below is the snippet of the described function: def settle_energy_deviations(self): \"\"\"Post the energy deviations between forecasts and measurements in the Settlement market.\"\"\" for area_uuid, area_dict in self.latest_grid_tree_flat.items(): if not area_dict.get(\"asset_info\"): continue time_slot = ( list(area_dict[\"asset_info\"][\"unsettled_deviation_kWh\"].keys())[-1]) unsettled_deviation = area_dict[\"asset_info\"][ \"unsettled_deviation_kWh\" ].get(time_slot) if unsettled_deviation > 0: self.add_to_batch_commands.bid_energy_rate( asset_uuid=area_uuid, rate=5, energy=unsettled_deviation, time_slot=time_slot, ) if unsettled_deviation < 0: self.add_to_batch_commands.offer_energy_rate( asset_uuid=area_uuid, rate=10, energy=abs(unsettled_deviation), time_slot=time_slot, ) The rest of the script functionality has been covered in the previous section . It is important to note that currently there is no available template script for interacting with the Settlement Market from the UI, but solely from the backend . The next step is to adapt the Asset API template scripts developed by Grid Singularity to customize your trading strategies, whether to send live data to the Grid Singularity Canary Test Network or to interact with the Settlement Market .","title":"Post energy deviations in the Settlement Market"},{"location":"assets-installation/","text":"Solar Panels \u00b6 There are two options to implement a PV in a backend: Solar Profile (for template generation profile): Market ('H2 PV', strategy=PVStrategy(panel_count=4, initial_selling_rate=30, final_selling_rate=5, fit_to_limit=True, update_interval=duration(minutes=5))) User Profile (for uploaded generation profile): ```user_profile_path = os.path.join(gsy-e_path, \"assets/Solar_Curve_W_sunny.csv\") Market ('H1 PV', strategy=PVUserProfileStrategy(power_profile=user_profile_path, panel_count=)) ##Consumption To implement the consumption profile (load) in a backend simulation, two options are available: [User configure Profile](https://github.com/gridsingularity/gsy-e/blob/master/src/gsy_e/models/strategy/load_hours.py): ```python Market('Load', strategy=LoadHoursStrategy(avg_power_W=200, hrs_per_day=6,hrs_of_day=list(range(12, 18)), initial_buying_rate=0, final_buying_rate=35)) User upload Profile : user_profile_path = os.path.join(gsy-e_path,\"assets/load.csv\") Market('Load', strategy=LoadProfileStrategy(daily_load_profile=user_profile_path, initial_buying_rate Addendum: hrs_of_day and hrs_per_day hrs_of_day defines the allowed time-window in which the load has to consume for a time defined by hrs_per_day. For example, a user can input 5 hrs_per_day and give a wider range for hrs_of_day like (2,18). The Load will try to consume as fast as possible during this time if there is any offered energy to purchase within the limits of initial_buying_rate and final_buying_rate set parameters. - If there is sufficient energy at affordable rates, the load will consume in the first 5 hours, i.e. from 02:00 until 07:00, with no energy demand unmatched. - In case energy prices are too high during the time-interval from 04:00 to 16:00, the load will consume from 02:00 until 04:00, turn off, and consume from 16:00 until 18:00, resulting in one hour of energy demand unmatched. For information on changes in buying and selling rates, please see: Trading strategies Batteries \u00b6 To implement a battery in a backend simulation one option is available: Energy Storage System Market('Storage', strategy=StorageStrategy(initial_soc=50, energy_rate_decrease_per_update=3, battery_capacity_kWh=1.2, max_abs_battery_power_kW=5, final_buying_rate=16.99, final_selling_rate= 17.01))) Power Plant \u00b6 To implement the power plant in a backend simulation one option is available: Finite Power Plant profile_kW = { 0: 0.1, 8: 0.15, 12: 0.2, 19: 0.15, 22: 0.1 } Market (\"Power Plant', strategy=FinitePowerPlant(energy_rate=31.3, max_available_power_kW=profile_ Market Maker \u00b6 To implement a market maker in a backend simulation, two methods are available : Infinite power plant Market ('Market Maker', strategy=MarketMakerStrategy(energy_rate=selling_rate, grid_connected=True)) Infinite bus Market ('Market Maker', strategy=InfiniteBusStrategy(energy_buy_rate=22, energy_sell_rate=22)) Addendum: Storage Capacity Based Method. This method was created to sell energy at lower prices during high state of charge - SOC (when the battery has more energy stored) and at higher prices during low SOC (when the battery can afford to sell its stored energy for less). If the cap_price_strategy is True, the offer price for the storage is calculated according to: offer_rate = initial_selling_rate - ((initial_selling_rate - final_selling_rate)\\*soc/100) As an example, considering an initial_selling_rate of 30 cents/kWh and a final_selling_rate of 20 cents/kWh, a storage with an SOC of 1% would sell its energy at 29.9 cents/kWh, and a battery at 100% SOC would sell its energy at 20 cents/kWh. To implement a power plant in a backend simulation, one option is available: Finite Power Plant profile_kW = { 0: 0.1, 8: 0.15, 12: 0.2, 19: 0.15, 22: 0.1 } Market (\"Power Plant', strategy=FinitePowerPlant(energy_rate=31.3, max_available_power_kW=profile_kW))","title":"Assets Installation"},{"location":"assets-installation/#solar-panels","text":"There are two options to implement a PV in a backend: Solar Profile (for template generation profile): Market ('H2 PV', strategy=PVStrategy(panel_count=4, initial_selling_rate=30, final_selling_rate=5, fit_to_limit=True, update_interval=duration(minutes=5))) User Profile (for uploaded generation profile): ```user_profile_path = os.path.join(gsy-e_path, \"assets/Solar_Curve_W_sunny.csv\") Market ('H1 PV', strategy=PVUserProfileStrategy(power_profile=user_profile_path, panel_count=)) ##Consumption To implement the consumption profile (load) in a backend simulation, two options are available: [User configure Profile](https://github.com/gridsingularity/gsy-e/blob/master/src/gsy_e/models/strategy/load_hours.py): ```python Market('Load', strategy=LoadHoursStrategy(avg_power_W=200, hrs_per_day=6,hrs_of_day=list(range(12, 18)), initial_buying_rate=0, final_buying_rate=35)) User upload Profile : user_profile_path = os.path.join(gsy-e_path,\"assets/load.csv\") Market('Load', strategy=LoadProfileStrategy(daily_load_profile=user_profile_path, initial_buying_rate Addendum: hrs_of_day and hrs_per_day hrs_of_day defines the allowed time-window in which the load has to consume for a time defined by hrs_per_day. For example, a user can input 5 hrs_per_day and give a wider range for hrs_of_day like (2,18). The Load will try to consume as fast as possible during this time if there is any offered energy to purchase within the limits of initial_buying_rate and final_buying_rate set parameters. - If there is sufficient energy at affordable rates, the load will consume in the first 5 hours, i.e. from 02:00 until 07:00, with no energy demand unmatched. - In case energy prices are too high during the time-interval from 04:00 to 16:00, the load will consume from 02:00 until 04:00, turn off, and consume from 16:00 until 18:00, resulting in one hour of energy demand unmatched. For information on changes in buying and selling rates, please see: Trading strategies","title":"Solar Panels"},{"location":"assets-installation/#batteries","text":"To implement a battery in a backend simulation one option is available: Energy Storage System Market('Storage', strategy=StorageStrategy(initial_soc=50, energy_rate_decrease_per_update=3, battery_capacity_kWh=1.2, max_abs_battery_power_kW=5, final_buying_rate=16.99, final_selling_rate= 17.01)))","title":"Batteries"},{"location":"assets-installation/#power-plant","text":"To implement the power plant in a backend simulation one option is available: Finite Power Plant profile_kW = { 0: 0.1, 8: 0.15, 12: 0.2, 19: 0.15, 22: 0.1 } Market (\"Power Plant', strategy=FinitePowerPlant(energy_rate=31.3, max_available_power_kW=profile_","title":"Power Plant"},{"location":"assets-installation/#market-maker","text":"To implement a market maker in a backend simulation, two methods are available : Infinite power plant Market ('Market Maker', strategy=MarketMakerStrategy(energy_rate=selling_rate, grid_connected=True)) Infinite bus Market ('Market Maker', strategy=InfiniteBusStrategy(energy_buy_rate=22, energy_sell_rate=22)) Addendum: Storage Capacity Based Method. This method was created to sell energy at lower prices during high state of charge - SOC (when the battery has more energy stored) and at higher prices during low SOC (when the battery can afford to sell its stored energy for less). If the cap_price_strategy is True, the offer price for the storage is calculated according to: offer_rate = initial_selling_rate - ((initial_selling_rate - final_selling_rate)\\*soc/100) As an example, considering an initial_selling_rate of 30 cents/kWh and a final_selling_rate of 20 cents/kWh, a storage with an SOC of 1% would sell its energy at 29.9 cents/kWh, and a battery at 100% SOC would sell its energy at 20 cents/kWh. To implement a power plant in a backend simulation, one option is available: Finite Power Plant profile_kW = { 0: 0.1, 8: 0.15, 12: 0.2, 19: 0.15, 22: 0.1 } Market (\"Power Plant', strategy=FinitePowerPlant(energy_rate=31.3, max_available_power_kW=profile_kW))","title":"Market Maker"},{"location":"assets-strategies/","text":"Prosumer assets can post orders ( bids/offers ) of their energy deviations to the settlement market in order to get compensated by another entity that deviated in the opposite direction. Energy deviations are calculated from the difference between the traded energy and measured energy for production or consumption. External asset strategies \u00b6 Energy Measurement and Forecasts \u00b6 Aggregator users can post the forecasted and measured energy to the Grid Singularity exchange for each market slot via the Asset API with the batch commands set_energy_forecast and set_energy_measurement . To enable these batch commands the asset must have either PVForecastExternalStrategy or LoadForecastExternalStrategy set as a strategy in the Grid Singularity Exchange setup file. Measurements should be set in the current market cycle for the unsettled deviation to be calculated. Figure 3.10 . Settlement market posting energy deviations mechanism with external asset strategies. Posting of Orders \u00b6 Posting and updating bids and offers works the same as in the spot markets . If the provided time_slot is a settlement market already, the order is placed or updated in the settlement market. The external client can only post maximally the amount of energy of the deviation to the settlement market. Unsettled Deviation \u00b6 To find out the amount of deviated energy, a key named unsettled_deviation_kWh is added on the assets_info dictionary. Its value is itself a dictionary with past time slots as keys and the unsettled energy as values. An example is shown below: { 'unsettled_deviation_kWh': {'2022-01-14T00:00': -8.3, '2022-01-14T01:00': -10.5}, 'available_energy_kWh': 10, 'energy_active_in_offers': 0, 'energy_traded': 0, 'total_cost': 0 } There will appear as many time slots as they fit in the amount of hours specified on ConstSettings.SettlementMarketSettings.ENABLE_SETTLEMENT_MARKETS . The value in each time slot is the maximal amount of energy that can be posted (please also see Settlement Market Rotation ). The sign of the unsettled energy can vary depending on wether more energy was traded than measured or vice versa. If a PV asset has a negative deviation, it implies that more energy was produced/measured than traded, and it is possible to offer it in the settlement market. To have a positive deviation would imply that more energy was traded than it was produced, and the asset now has to make up for it by posting bids. If a Load asset has a negative deviation, it implies that more energy was initially bid (and traded) than the one that was actually used, and can then be offered on the settlement market. To have a positive deviation would imply that more energy was consumed than it was traded, and the asset now has to make up for it by posting bids. In conclusion, regardless of wether the asset is a PV or a Load, if the unsettled deviation is negative, the energy should be offered, and if positive, bid. Example settlement market strategy: if self._can_place_in_settlement_market(asset_info): for market_slot, energy in asset_info[\"unsettled_deviation_kWh\"].items(): if energy and energy > 0: self.add_to_batch_commands.bid_energy(asset_uuid=area_uuid, energy=energy, price=30, time_slot=market_slot) elif energy and energy < 0: self.add_to_batch_commands.offer_energy(asset_uuid=area_uuid, energy=-energy, price=1, time_slot=market_slot) where the method self._can_place_in_settlement_market() is defined as follows: def _can_place_in_settlement_market(asset_info): return \"unsettled_deviation_kWh\" in asset_info and ( asset_info[\"unsettled_deviation_kWh\"] != 0) Template asset strategies \u00b6 Energy Measurement and Forecasts \u00b6 For the template strategies, the forecasted energy is provided by the user, either by uploading a profile or setting up a predefined PV or Load. The forecasted energy is used to post bids or offers to the spot markets. The actual measured energy is calculated by a random deviation of the forecasted value. A gaussian random error is simulated (positive and negative deviances around the forecasted energy value possible). The intensity of this random deviation can be controlled by the following setting that represents the relative standard deviation, so the width of the random deviation around the energy forecast: ConstSettings.SettlementMarketSettings.RELATIVE_STD_FROM_FORECAST_FLOAT . Figure 3.11 . Settlement market posting energy deviations mechanism with template asset strategies. Posting of Orders \u00b6 The template strategies will post orders (bids / offers) with energy values equal to the energy deviations for each market. For example, if a PV forecasted to produce 5kWh of energy for the 12:00 market, but the simulated measured energy reveals that it only produced 4kWh for that time slot, the template strategy will post a bid to the 12:00 settlement market with the energy 1kWh. The behavior for the price increase of this bid is the same as in the spot market: the energy rate of the bid is increased during the market until the final selling rate is reached. As the settlement market will stay available for longer than the normal spot market (configurable by Const.Settings.SettlementMarketSettings.MAX_AGE_SETTLEMENT_MARKET_HOURS , please also see here ), the template strategy will not update the orders as frequent as in the normal spot market, but in the interval that can be set by the parameter SettlementTemplateStrategiesConstants.UPDATE_INTERVAL_MIN .","title":"Assets strategies"},{"location":"assets-strategies/#external-asset-strategies","text":"","title":"External asset strategies"},{"location":"assets-strategies/#energy-measurement-and-forecasts","text":"Aggregator users can post the forecasted and measured energy to the Grid Singularity exchange for each market slot via the Asset API with the batch commands set_energy_forecast and set_energy_measurement . To enable these batch commands the asset must have either PVForecastExternalStrategy or LoadForecastExternalStrategy set as a strategy in the Grid Singularity Exchange setup file. Measurements should be set in the current market cycle for the unsettled deviation to be calculated. Figure 3.10 . Settlement market posting energy deviations mechanism with external asset strategies.","title":"Energy Measurement and Forecasts"},{"location":"assets-strategies/#posting-of-orders","text":"Posting and updating bids and offers works the same as in the spot markets . If the provided time_slot is a settlement market already, the order is placed or updated in the settlement market. The external client can only post maximally the amount of energy of the deviation to the settlement market.","title":"Posting of Orders"},{"location":"assets-strategies/#unsettled-deviation","text":"To find out the amount of deviated energy, a key named unsettled_deviation_kWh is added on the assets_info dictionary. Its value is itself a dictionary with past time slots as keys and the unsettled energy as values. An example is shown below: { 'unsettled_deviation_kWh': {'2022-01-14T00:00': -8.3, '2022-01-14T01:00': -10.5}, 'available_energy_kWh': 10, 'energy_active_in_offers': 0, 'energy_traded': 0, 'total_cost': 0 } There will appear as many time slots as they fit in the amount of hours specified on ConstSettings.SettlementMarketSettings.ENABLE_SETTLEMENT_MARKETS . The value in each time slot is the maximal amount of energy that can be posted (please also see Settlement Market Rotation ). The sign of the unsettled energy can vary depending on wether more energy was traded than measured or vice versa. If a PV asset has a negative deviation, it implies that more energy was produced/measured than traded, and it is possible to offer it in the settlement market. To have a positive deviation would imply that more energy was traded than it was produced, and the asset now has to make up for it by posting bids. If a Load asset has a negative deviation, it implies that more energy was initially bid (and traded) than the one that was actually used, and can then be offered on the settlement market. To have a positive deviation would imply that more energy was consumed than it was traded, and the asset now has to make up for it by posting bids. In conclusion, regardless of wether the asset is a PV or a Load, if the unsettled deviation is negative, the energy should be offered, and if positive, bid. Example settlement market strategy: if self._can_place_in_settlement_market(asset_info): for market_slot, energy in asset_info[\"unsettled_deviation_kWh\"].items(): if energy and energy > 0: self.add_to_batch_commands.bid_energy(asset_uuid=area_uuid, energy=energy, price=30, time_slot=market_slot) elif energy and energy < 0: self.add_to_batch_commands.offer_energy(asset_uuid=area_uuid, energy=-energy, price=1, time_slot=market_slot) where the method self._can_place_in_settlement_market() is defined as follows: def _can_place_in_settlement_market(asset_info): return \"unsettled_deviation_kWh\" in asset_info and ( asset_info[\"unsettled_deviation_kWh\"] != 0)","title":"Unsettled Deviation"},{"location":"assets-strategies/#template-asset-strategies","text":"","title":"Template asset strategies"},{"location":"assets-strategies/#energy-measurement-and-forecasts_1","text":"For the template strategies, the forecasted energy is provided by the user, either by uploading a profile or setting up a predefined PV or Load. The forecasted energy is used to post bids or offers to the spot markets. The actual measured energy is calculated by a random deviation of the forecasted value. A gaussian random error is simulated (positive and negative deviances around the forecasted energy value possible). The intensity of this random deviation can be controlled by the following setting that represents the relative standard deviation, so the width of the random deviation around the energy forecast: ConstSettings.SettlementMarketSettings.RELATIVE_STD_FROM_FORECAST_FLOAT . Figure 3.11 . Settlement market posting energy deviations mechanism with template asset strategies.","title":"Energy Measurement and Forecasts"},{"location":"assets-strategies/#posting-of-orders_1","text":"The template strategies will post orders (bids / offers) with energy values equal to the energy deviations for each market. For example, if a PV forecasted to produce 5kWh of energy for the 12:00 market, but the simulated measured energy reveals that it only produced 4kWh for that time slot, the template strategy will post a bid to the 12:00 settlement market with the energy 1kWh. The behavior for the price increase of this bid is the same as in the spot market: the energy rate of the bid is increased during the market until the final selling rate is reached. As the settlement market will stay available for longer than the normal spot market (configurable by Const.Settings.SettlementMarketSettings.MAX_AGE_SETTLEMENT_MARKET_HOURS , please also see here ), the template strategy will not update the orders as frequent as in the normal spot market, but in the interval that can be set by the parameter SettlementTemplateStrategiesConstants.UPDATE_INTERVAL_MIN .","title":"Posting of Orders"},{"location":"backend-results-energy-bills/","text":"The cumulative energy bills for each market and energy asset are reported on the UI Results page and in a JSON file bills.json for a backend simulation. The bills are reported as the cash flow through each market. Figure 2.31 . Example grid setup showing connection to the grid. This configuration is simulated for one day using the Pay-as-Bid market type and the load bidding to buy energy at 12:00, leading to the propagation of the load bid and the grid operator offer until they are matched as shown in the figure below: Figure 2.32 . Example grid setup with bid and offers. The bid and the offer are forwarded to the higher-level Grid market and are matched in this market with a clearing price (and trade price) of \u20ac0.45. For more information on how grid fees are calculated, please read the grid fees documentation . In the bills.json file, the cash flow in each market is reported as follows: \"Parent market\": { \"Agent\": { \"bought\": Energy that has been bought during the simulation [kWh], \"sold\": Energy that has been sold during the simulation [kWh], \"spent\": Amount of money that has been spent in trades during the simulation [\u20ac] , \"earned\": Amount of money that has been earned in trades during the simulation [\u20ac], \"total_energy\": energy bought - energy sold [kWh], \"total_cost\": money spent in trades - money earned in trades [\u20ac], \"market_fee\": Money spent in the \"Parent area\" as grid fees [\u20ac] , \"type\": Type of agent. Can either be a market or the name of the asset strategy }, }, Shown below are the results of the previous example. The first set of results is from the highest market, in this case the Grid market: Figure 2.33 . Results example. In the Grid market, Home 1 has bought 1 kWh from the Gris and spent \u20ac0.375 for this trade. Home 1 also pays the \u20ac0.075 grid fee that the Grid market is charging. The total cost of 1 kWh of energy is \u20ac0.375 + \u20ac0.075 = \u20ac0.45 One level down the hierarchy, the Home 1 market is displayed in the figure below: Figure 2.34 . Results example. The Home 1 market has no information on the other markets\u2019 grid fees, so only considers its own fees in the bills table. Therefore, the Load spends \u20ac0.45 (\u20ac0.0375 + \u20ac0.075) for 1 kWh of energy that is externally supplied to Home 1, with no grid fee added since House 1 has no fees. Finally, the bills of each energy asset are shown: Figure 2.35 . Results example.","title":"Energy bills"},{"location":"backend-results-overview/","text":"After running a simulation in the backend, the user can export simulation results. This functionality is enabled by default. If you want to disable the export of simulation results, use the --no-export flag for the simulation run. Another useful parameter is: --export-path , used to change the output path of the simulation results. The default path is $HOME/gsy-e-simulation/ . The simulation results include analytical information about the bids, offers and trades that took place in the course of the simulation. Information about energy characteristics of each asset and market are also included (eg. battery state of charge, energy traded/requested/deficit). A detailed description of these files is available on the data download page. In addition to text files, some graphs that display aggregated market information during the course of the simulation are also exposed. These can be found under the plot directory and are very similar to the ones available in the UI: - **unmatched_loads_*.html**: Plots the volume of energy that loads have not been able to purchase (power outage) - **energy_profile_*.html**: Similar plot to energy trade profile - **average_trade_price_*.html**: Similar plot to energy pricing - **asset_profile_*.html**: each energy asset within the simulation has its own plot showing its profile (consumption, generation, State of Charge), the actual energy traded and energy rates.","title":"Overview"},{"location":"backend-solar-panels/","text":"","title":"Backend solar panels"},{"location":"balancing-implementation/","text":"Figure 3.1 . Structure of Balancing Market in Grid Singularity exchange Grid Singularity energy exchange bottom-up market design allows participants to engage in Local Energy Market (LEM) for energy trading, providing energy balance at a local level. Grid Singularity Exchange flexibility trading also facilitates the procurement of flexibility locally from participants to assist distribution grid operation in balancing the grid. Assets \u00b6 In the Grid Singularity Exchange, balancing has been implemented using: Fast responding non-critical loads to provide load shedding Battery storage Commercial power plants The trading strategies of energy assets like Loads , Storages and Power Plants can be used to balance the grid by placing balancing offers. These assets participate in the balancing market only if they are registered in the Asset Registry . Asset Registry \u00b6 The balancing asset registry is a dictionary that contains the names of assets as keys and the balancing rates as tuple values: (demand balancing rate, supply balancing rate). asset_registry_dict = { \"H1 General Load\": (33, 35), \"H2 General Load\": (33, 35), \"H1 Storage1\": (33, 35), \"H1 Storage2\": (33, 35), } Balancing Market \u00b6 The present setting is a One-Sided Pay-as-Offer market , which accepts balancing_offers from energy assets and connected hierarchies of balancing_market . balancing_offers could be positive or negative. It also facilitates the balancing_trade . Balancing Agent \u00b6 The balancing agent follows the lead of the spot_market_trade of its lower hierarchy. Whenever there is a trade in the lower hierarchy of spot_market , it will try to secure a share of spot market trades in the balancing market. Constant Parameters \u00b6 The following are the constant parameters related to the balancing market, with defaults available here . ENABLE_BALANCING_MARKET \u2192 (Default: False) (It enables the simulation with Balancing Market) BALANCING_SPOT_TRADE_RATIO \u2192 (Default: 0.2) (It dictates the ratio of spot_market_energy to be traded in balancing market) BALANCING_OFFER_DEMAND_RATIO \u2192 (Default: 0.1) (It dictates the ratio of spot_market_energy to be offered in balancing market as demand_balancing_offer ) BALANCING_OFFER_SUPPLY_RATIO \u2192 (Default: 0.1) (It dictates the ratio of spot_market_energy to be offered in balancing market as supply_balancing_offer ) BALANCING_FLEXIBLE_LOADS_SUPPORT \u2192 (Default: True) (It enables Load Strategy to place supply_balancing_offer (effectively curtailing it's load)) Multiple examples of balancing market setup are available here .","title":"Balancing Market Implementation"},{"location":"balancing-implementation/#assets","text":"In the Grid Singularity Exchange, balancing has been implemented using: Fast responding non-critical loads to provide load shedding Battery storage Commercial power plants The trading strategies of energy assets like Loads , Storages and Power Plants can be used to balance the grid by placing balancing offers. These assets participate in the balancing market only if they are registered in the Asset Registry .","title":"Assets"},{"location":"balancing-implementation/#asset-registry","text":"The balancing asset registry is a dictionary that contains the names of assets as keys and the balancing rates as tuple values: (demand balancing rate, supply balancing rate). asset_registry_dict = { \"H1 General Load\": (33, 35), \"H2 General Load\": (33, 35), \"H1 Storage1\": (33, 35), \"H1 Storage2\": (33, 35), }","title":"Asset Registry"},{"location":"balancing-implementation/#balancing-market","text":"The present setting is a One-Sided Pay-as-Offer market , which accepts balancing_offers from energy assets and connected hierarchies of balancing_market . balancing_offers could be positive or negative. It also facilitates the balancing_trade .","title":"Balancing Market"},{"location":"balancing-implementation/#balancing-agent","text":"The balancing agent follows the lead of the spot_market_trade of its lower hierarchy. Whenever there is a trade in the lower hierarchy of spot_market , it will try to secure a share of spot market trades in the balancing market.","title":"Balancing Agent"},{"location":"balancing-implementation/#constant-parameters","text":"The following are the constant parameters related to the balancing market, with defaults available here . ENABLE_BALANCING_MARKET \u2192 (Default: False) (It enables the simulation with Balancing Market) BALANCING_SPOT_TRADE_RATIO \u2192 (Default: 0.2) (It dictates the ratio of spot_market_energy to be traded in balancing market) BALANCING_OFFER_DEMAND_RATIO \u2192 (Default: 0.1) (It dictates the ratio of spot_market_energy to be offered in balancing market as demand_balancing_offer ) BALANCING_OFFER_SUPPLY_RATIO \u2192 (Default: 0.1) (It dictates the ratio of spot_market_energy to be offered in balancing market as supply_balancing_offer ) BALANCING_FLEXIBLE_LOADS_SUPPORT \u2192 (Default: True) (It enables Load Strategy to place supply_balancing_offer (effectively curtailing it's load)) Multiple examples of balancing market setup are available here .","title":"Constant Parameters"},{"location":"balancing-market/","text":"Definition \u00b6 Electrical power systems are characterized by voltage and frequency and the flow of electricity is a continuous process. Buffering or storing electrical energy at each node is still not feasible, therefore electrical energy needs to be generated exactly at the time of consumption. Differences in supply and demand causes the nominal frequency (50Hz in EU) to deviate. Consequently, supply and demand need to be monitored in real time to implement adjustments to maintain equilibrium and nominal frequency. Significant deviation from the nominal leads to cascading effect culminating in a blackout . Transmission system operators (TSOs) oversee fast, flexible, fossil fuel-based generation units and demand response service from large consumers, ensuring the continuation of operation during significant transient faults in the energy system. These generators form the basis of frequency control strategies used in balancing these electrical systems. Each control strategy has specific purposes and features and can be categorized in three groups, as shown in the figure below. Primary Control (Frequency Containment Reserve - FCR) Secondary Control (Automatic Frequency Restoration Reserves - aFRR) Tertiary Control (Manual Frequency Restoration Reserves - mFRR) Figure 3.4 . The three tiers of grid control and its activation structure In conventional grid structures \u00b6 Primary control is an automatic function that is almost instantaneously activated to stabilise the frequency drops/spikes. It is the fastest type of frequency control with a response time of a few seconds and operates using a joint process involving all TSOs of the synchronous area. This is shown in the figure below. For example, if there is an increase in demand, the energy used to compensate for this demand comes from the kinetic energy stored in large rotating synchronous generators that start decreasing its velocity. This is referred to as Inertial response . For the generators to recover the speed, the speed controller of each generator acts to increase the generator power to clear the imbalance. Within a period of 30 seconds, each generating unit is able to generate the required power and stabilise this production for at least 15 minutes or depending on the requirements of the TSO within the synchronous region. Primary control is done using generation plants that are connected to the high voltage power supply with the exception of renewable energy sources which are non-schedulable due to its intermittent nature. Figure 3.5 . Recovery of the system from a contingency event and action by primary frequency control (PFR) Secondary control is performed automatically by all the generators to restore the nominal frequency, the power exchanges and reserve of the generators used in primary control. The generators involved in this regulation function through dedicated reserve power that are set in conjunction with central controllers. The reserve control power is negotiated in a contract conjunction with the TSO and is a percentage of the maximum available power with a predefined minimum value to ensure that it can be dispatched whenever needed. This service is remunerated according to the set contracts. Tertiary control is not an automatic function and is executed upon request by the grid operator. The reserve margins used for the secondary control are restored through tertiary control. The differences between the primary, secondary and tertiary frequency control is the time the production and response can be activated, and the remuneration for each. Primary frequency control is symmetrical as the capacity for control has been scheduled and usually balances between ramping up and down the production and therefore not remunerated. Secondary and tertiary control are not symmetrical as the capacity can be used only for ramping up or down the production to restore the frequency and are remunerated. Review of the three levels of regulation \u00b6 Response Time Duration Time Operation Purpose Primary Control 10-30 Seconds 15 Minutes Automatic Act in case of frequency variation in order to stabilize frequency value Secondary Control 200 Seconds 120 minutes Automatic Act to bring back frequency value to the nominal value and restore the power reserve of the generators used for the primary frequency control Tertiary Control 15 Minutes Indicated by TSO Upon Request Act to restore power reserves of the generators used for the secondary frequency control Table 3.1 : Main features of frequency control strategies In our transactive energy low voltage grid structure primary, secondary and tertiary control are controlled by an area controller called the balancing agent. Figure 3.6 . Area control structure of market consisting of all three tiers of control (source: Martin Fornage, A generalized transactive energy-based framework: Enphase Energy. Powerpoint presentation 2015) The balancing agent monitors the health of the system and is in control of all its allocated resources. It also had the ability to control the physical connect and disconnect from upstream and downstream resources according to the type of control required. Primary control happens simultaneously as the spot market through a droop curve. Grid forming assets have different droop curves based on their behaviour (Loads, Storage, PV) which are used to keep the voltage and frequency towards nominal in case of a deviation. Local balancing is therefore done through primary control. Secondary control (Inertia Control) is done through a time schedule. The schedule is received from the upper tertiary control or from a ledger. Secondary balancing agents adjust the primary balancing agents resources within its market by disconnecting and connecting them in case of failure of upstream structure or failure to meet the schedule. Tertiary control negotiates the schedules upstream or downstream at lowest cost of operation and provides a marketplace for energy in and out of the market area. The inputs of the tertiary control are the bids, offers and error signals from secondary control. The outputs are the schedules to resources.","title":"Balancing Market Structure"},{"location":"balancing-market/#definition","text":"Electrical power systems are characterized by voltage and frequency and the flow of electricity is a continuous process. Buffering or storing electrical energy at each node is still not feasible, therefore electrical energy needs to be generated exactly at the time of consumption. Differences in supply and demand causes the nominal frequency (50Hz in EU) to deviate. Consequently, supply and demand need to be monitored in real time to implement adjustments to maintain equilibrium and nominal frequency. Significant deviation from the nominal leads to cascading effect culminating in a blackout . Transmission system operators (TSOs) oversee fast, flexible, fossil fuel-based generation units and demand response service from large consumers, ensuring the continuation of operation during significant transient faults in the energy system. These generators form the basis of frequency control strategies used in balancing these electrical systems. Each control strategy has specific purposes and features and can be categorized in three groups, as shown in the figure below. Primary Control (Frequency Containment Reserve - FCR) Secondary Control (Automatic Frequency Restoration Reserves - aFRR) Tertiary Control (Manual Frequency Restoration Reserves - mFRR) Figure 3.4 . The three tiers of grid control and its activation structure","title":"Definition"},{"location":"balancing-market/#in-conventional-grid-structures","text":"Primary control is an automatic function that is almost instantaneously activated to stabilise the frequency drops/spikes. It is the fastest type of frequency control with a response time of a few seconds and operates using a joint process involving all TSOs of the synchronous area. This is shown in the figure below. For example, if there is an increase in demand, the energy used to compensate for this demand comes from the kinetic energy stored in large rotating synchronous generators that start decreasing its velocity. This is referred to as Inertial response . For the generators to recover the speed, the speed controller of each generator acts to increase the generator power to clear the imbalance. Within a period of 30 seconds, each generating unit is able to generate the required power and stabilise this production for at least 15 minutes or depending on the requirements of the TSO within the synchronous region. Primary control is done using generation plants that are connected to the high voltage power supply with the exception of renewable energy sources which are non-schedulable due to its intermittent nature. Figure 3.5 . Recovery of the system from a contingency event and action by primary frequency control (PFR) Secondary control is performed automatically by all the generators to restore the nominal frequency, the power exchanges and reserve of the generators used in primary control. The generators involved in this regulation function through dedicated reserve power that are set in conjunction with central controllers. The reserve control power is negotiated in a contract conjunction with the TSO and is a percentage of the maximum available power with a predefined minimum value to ensure that it can be dispatched whenever needed. This service is remunerated according to the set contracts. Tertiary control is not an automatic function and is executed upon request by the grid operator. The reserve margins used for the secondary control are restored through tertiary control. The differences between the primary, secondary and tertiary frequency control is the time the production and response can be activated, and the remuneration for each. Primary frequency control is symmetrical as the capacity for control has been scheduled and usually balances between ramping up and down the production and therefore not remunerated. Secondary and tertiary control are not symmetrical as the capacity can be used only for ramping up or down the production to restore the frequency and are remunerated.","title":"In conventional grid structures"},{"location":"balancing-market/#review-of-the-three-levels-of-regulation","text":"Response Time Duration Time Operation Purpose Primary Control 10-30 Seconds 15 Minutes Automatic Act in case of frequency variation in order to stabilize frequency value Secondary Control 200 Seconds 120 minutes Automatic Act to bring back frequency value to the nominal value and restore the power reserve of the generators used for the primary frequency control Tertiary Control 15 Minutes Indicated by TSO Upon Request Act to restore power reserves of the generators used for the secondary frequency control Table 3.1 : Main features of frequency control strategies In our transactive energy low voltage grid structure primary, secondary and tertiary control are controlled by an area controller called the balancing agent. Figure 3.6 . Area control structure of market consisting of all three tiers of control (source: Martin Fornage, A generalized transactive energy-based framework: Enphase Energy. Powerpoint presentation 2015) The balancing agent monitors the health of the system and is in control of all its allocated resources. It also had the ability to control the physical connect and disconnect from upstream and downstream resources according to the type of control required. Primary control happens simultaneously as the spot market through a droop curve. Grid forming assets have different droop curves based on their behaviour (Loads, Storage, PV) which are used to keep the voltage and frequency towards nominal in case of a deviation. Local balancing is therefore done through primary control. Secondary control (Inertia Control) is done through a time schedule. The schedule is received from the upper tertiary control or from a ledger. Secondary balancing agents adjust the primary balancing agents resources within its market by disconnecting and connecting them in case of failure of upstream structure or failure to meet the schedule. Tertiary control negotiates the schedules upstream or downstream at lowest cost of operation and provides a marketplace for energy in and out of the market area. The inputs of the tertiary control are the bids, offers and error signals from secondary control. The outputs are the schedules to resources.","title":"Review of the three levels of regulation"},{"location":"battery/","text":"Batteries (also known as energy storage) are energy assets that save the surplus energy produced and store it for use at a later time. Adding a battery to a home or community will increase the self-consumption and self-sufficiency levels and enhance the potential of flexibility service for grid operators. Asset Configuration Options \u00b6 Express Mode Name - Must be unique Geo-tag - This automatically uploads the location a user selects Advanced Mode Battery capacity - Users can choose the total energy capacity in kWh. Initial capacity - Set the initial capacity of the battery in terms of Initial State of Charge (SOC) in %, or Initial Energy in kWh. This will set the initial level of charge of the battery at the start of the simulation. Minimum SOC - Choose the minimum amount of energy to leave in the battery. Batteries usually have a safeguard disabling them to discharge below a specific threshold to increase life expectancy. Max power rating for battery - Choose the power limit (charge and discharge) for each market slot in kW. This parameter limits the maximum sold and bought energy. Initial selling rate - Users can choose the initial rate for selling energy at the beginning of each market slot in cents/kWh. Final selling rate - Users can choose the final rate for selling energy at the end of each market slot in cents/kWh. Rate decrease - Users can choose the explicit rate decrease increment in cents/kWh. Initial buying rate - Users can choose the initial rate for buying energy at the beginning of each market slot in cents/kWh. Final buying rate - Users can choose the final rate for buying energy at the end of each market slot in cents/kWh. Rate increase - Users can choose the explicit rate increase increment in cents/kWh. Fit to Limits - If activated, a rate decrease per time is calculated, starting at initial Selling Rate and ending at final Selling Rate while updating the rate at each Update Interval Bidding behaviour is derived from a linear fitted curve of a buying rate between initial_buying_rate and final_buying_rate and a selling rate between initial_selling_rate and final_selling_rate within the bidding interval. If activated: energy_rate_increase = (final_buying_rate - initial_buying_rate) / max(int((slot_length / update_interval) -1), 1) energy_rate_decrease_per_update = (initial_selling_rate - final_selling_rate) / max(int((slot_length / update_interval) -1), 1) Update interval - Users can choose the frequency at which the rate is updated. Capacity based method - If activated, energy will be sold at lower prices during high state of charge - SOC (when the battery has more energy stored) and at higher prices during low SOC (when the battery can afford to sell its stored energy for less). If chosen, the offer price for the storage is calculated according to: offer_rate = initial_selling_rate - ((initial_selling_rate - final_selling_rate)\\*soc/100) As an example, considering an initial_selling_rate of 30 cents/kWh and a final_selling_rate of 20 cents/kWh, a storage with an SOC of 1% would sell its energy at 29.9 cents/kWh, and a battery at 100% SOC would sell its energy at 20 cents/kWh. Note: The current default setting of the battery component is 100% energy conversion efficiency. It is not possible to change this setting at the moment but it may be in the future versions of the software. Interested contributors may propose such additions to our open source code on GitHub . Figure 2.12 . Battery (Storage) Advanced Configuration Options Storage Behaviour in Local Energy Markets \u00b6 In general, all bids and offers follow the physical constraint of the set max_abs_battery_power_kW value . The accumulated energy per market slot cannot exceed this power value times the length of the market slot, in hours. Energy sold and bought cancel each other out, meaning that if 2kWh are both sold and bought in the same market slot, the relative power remains 0kW. For the buying rate increase and selling rate decrease behaviour, please see the Trading Strategies page . Buying energy in the One-Sided Market On each tick, the storage scans the connected market for affordable offers* if there is storage space to be filled (if the current SOC is lower than 100%). Affordable offers are offers that have a price lower or equal to the current acceptable energy rate. The acceptable energy rate changes during a market slot depending on the initial_buying_rate, final_buying_rate, energy_rate_decrease_per_update and update_interval setting. Once an offer is found, it is either fully or partially accepted, depending on the demand. The storage always seeks 100% SOC when buying energy. Buying energy in the Two-Sided Market On each tick, the storage either places a bid for the quantity of energy it needs to reach 100% SOC or updates the price of an existing bid in the market where the bid rate depends on the initial_buying_rate, final_buying_rate, energy_rate_decrease_per_update and update_interval setting. Selling energy At the beginning of each market slot, the storage places an offer for all the energy it has stored (not including the energy that is needed to keep the storage at least at min_allowed_soc). This offer is updated at each update_interval pursuant to the rate decrease settings. This mechanism applies in both one and two-sided market types. Consequently, it is possible for the storage to have both an offer and a bid placed in the same market.","title":"Battery (Storage)"},{"location":"battery/#asset-configuration-options","text":"Express Mode Name - Must be unique Geo-tag - This automatically uploads the location a user selects Advanced Mode Battery capacity - Users can choose the total energy capacity in kWh. Initial capacity - Set the initial capacity of the battery in terms of Initial State of Charge (SOC) in %, or Initial Energy in kWh. This will set the initial level of charge of the battery at the start of the simulation. Minimum SOC - Choose the minimum amount of energy to leave in the battery. Batteries usually have a safeguard disabling them to discharge below a specific threshold to increase life expectancy. Max power rating for battery - Choose the power limit (charge and discharge) for each market slot in kW. This parameter limits the maximum sold and bought energy. Initial selling rate - Users can choose the initial rate for selling energy at the beginning of each market slot in cents/kWh. Final selling rate - Users can choose the final rate for selling energy at the end of each market slot in cents/kWh. Rate decrease - Users can choose the explicit rate decrease increment in cents/kWh. Initial buying rate - Users can choose the initial rate for buying energy at the beginning of each market slot in cents/kWh. Final buying rate - Users can choose the final rate for buying energy at the end of each market slot in cents/kWh. Rate increase - Users can choose the explicit rate increase increment in cents/kWh. Fit to Limits - If activated, a rate decrease per time is calculated, starting at initial Selling Rate and ending at final Selling Rate while updating the rate at each Update Interval Bidding behaviour is derived from a linear fitted curve of a buying rate between initial_buying_rate and final_buying_rate and a selling rate between initial_selling_rate and final_selling_rate within the bidding interval. If activated: energy_rate_increase = (final_buying_rate - initial_buying_rate) / max(int((slot_length / update_interval) -1), 1) energy_rate_decrease_per_update = (initial_selling_rate - final_selling_rate) / max(int((slot_length / update_interval) -1), 1) Update interval - Users can choose the frequency at which the rate is updated. Capacity based method - If activated, energy will be sold at lower prices during high state of charge - SOC (when the battery has more energy stored) and at higher prices during low SOC (when the battery can afford to sell its stored energy for less). If chosen, the offer price for the storage is calculated according to: offer_rate = initial_selling_rate - ((initial_selling_rate - final_selling_rate)\\*soc/100) As an example, considering an initial_selling_rate of 30 cents/kWh and a final_selling_rate of 20 cents/kWh, a storage with an SOC of 1% would sell its energy at 29.9 cents/kWh, and a battery at 100% SOC would sell its energy at 20 cents/kWh. Note: The current default setting of the battery component is 100% energy conversion efficiency. It is not possible to change this setting at the moment but it may be in the future versions of the software. Interested contributors may propose such additions to our open source code on GitHub . Figure 2.12 . Battery (Storage) Advanced Configuration Options","title":"Asset Configuration Options"},{"location":"battery/#storage-behaviour-in-local-energy-markets","text":"In general, all bids and offers follow the physical constraint of the set max_abs_battery_power_kW value . The accumulated energy per market slot cannot exceed this power value times the length of the market slot, in hours. Energy sold and bought cancel each other out, meaning that if 2kWh are both sold and bought in the same market slot, the relative power remains 0kW. For the buying rate increase and selling rate decrease behaviour, please see the Trading Strategies page . Buying energy in the One-Sided Market On each tick, the storage scans the connected market for affordable offers* if there is storage space to be filled (if the current SOC is lower than 100%). Affordable offers are offers that have a price lower or equal to the current acceptable energy rate. The acceptable energy rate changes during a market slot depending on the initial_buying_rate, final_buying_rate, energy_rate_decrease_per_update and update_interval setting. Once an offer is found, it is either fully or partially accepted, depending on the demand. The storage always seeks 100% SOC when buying energy. Buying energy in the Two-Sided Market On each tick, the storage either places a bid for the quantity of energy it needs to reach 100% SOC or updates the price of an existing bid in the market where the bid rate depends on the initial_buying_rate, final_buying_rate, energy_rate_decrease_per_update and update_interval setting. Selling energy At the beginning of each market slot, the storage places an offer for all the energy it has stored (not including the energy that is needed to keep the storage at least at min_allowed_soc). This offer is updated at each update_interval pursuant to the rate decrease settings. This mechanism applies in both one and two-sided market types. Consequently, it is possible for the storage to have both an offer and a bid placed in the same market.","title":"Storage Behaviour in Local Energy Markets"},{"location":"bills-traded-energy/","text":"This category shows the net energy (energy bought minus energy sold) in terms of \u20ac and kWh for each home in the community, as well as Grid Fees and the Grid Market. Each value shown is the total traded in this market for the length of the simulation. The energy values marked in green have a net export of energy while those marked in red have a net import of energy. Bills show the net amount paid or owed, marked in red or green. As an example, the grid market in the figure below is overall selling energy to the community (net exporting). If grid fees are added to the simulation, they will also show up in the energy bills table. Figure 2.21 . Total energy bills and net energy traded in Euro (\u20ac).","title":"Bills and traded energy"},{"location":"blockchain/","text":"Purpose \u00b6 Grid Singularity energy exchange engine has been designed so that it does not require blockchain technology, but that it can benefit from this technology to provide enhanced functionality. Grid Singularity aims to integrate blockchain for specific benefits: Decentralisation and transparency : blockchain can be used to create decentralized registry and identity. By doing so, the privacy and security of users are enhanced. Data ownership : End-users would have complete control over their data access and use Payments : Trades cleared on the market will be recorded on the chain and the payments executed. While the privacy of users will be preserved, the system would be more transparent. Degrees of Freedom : Bids and offers can be tagged with validated attributes to enable trading degrees of freedom such as preferred trading partner, energy source selection, or location restrictions on trades Asset validation : energy assets, smart meters, and entities can be validated using tools like the Energy Web Switchboard. The Energy Web Chain is the blockchain of choice for Grid Singularity Exchange future blockchain implementation. Grid Singularity, an energy technology startup, and the Rocky Mountain Institute, a nonprofit clean technology organisation, jointly founded the Energy Web Foundation (EWF) in January 2017. EWF is a nonprofit foundation gathering an ecosystem of over 100 energy corporations and startups with a shared, public blockchain platform, the Energy Web Chain. While Grid Singularity has significantly contributed to EWF development and the launch of the Energy Web Chain, its role today is supervisory and advisory, with two Grid Singularity representatives serving on the EWF\u2019s Foundation Council . At present, Grid Singularity Exchange blockchain integration is used just for simulated transactions and it is based on Substrate . We are also in the process of integrating with the Energy Web Switchboard , which will be used as a decentralized asset registry . In the future we plan to move to full implementation on the Energy Web Chain, benefiting from Polkadot\u2019s scaling solution. The current basic blockchain integration uses Substrate, which allows modular business logic to be built directly in the blockchain and facilitates a high transaction throughput. Substrate has components called pallets, where each pallet can represent different functionality, such as smart contracts, storage, auctions, and more . Currently, our integration includes a storage pallet that provides immutable storage of executed transactions, and additional functionalities will continue to be actively developed. Blockchain can optionally be enabled on simulations running locally with the backend code base. There are three configuration parameters. The command-line flag is --enable-bc , used to enable blockchain operations. The two other parameters are the mnemonic to restore your key and interact with the blockchain, and the ENABLE_SUBSTRATE parameter described in the steps below. Connecting to Grid Singularity node \u00b6 https://polkadot.js.org/apps/?rpc=wss%3A%2F%2Fcanvas-node.dev.gridsingularity.com When you go to the endpoint, you will see the standard interface. That\u2019s the easiest point of interaction with the node, where you can call extrinsics, upload contracts, deploy them, test their functions, send funds and more. Simulating Grid Singularity local energy markets on Substrate \u00b6 Wallet \u00b6 Ensure that you have the Polkadot Chrome extension (it is a browser extension that allows you to manage accounts for any Substrate-based blockchain). Create an account and save your seed phrase. You will need to save \"your twelve words\" mnemonic to be able to restore your key in general, and later to pass it the models/market/blockchain_utils.py in order to call the contracts on-chain from python code. Make sure never to push your mnemonic to GitHub. Balance \u00b6 If you want to send a transaction manually or through Grid Singularity Exchange in the development chain, you need to pay transaction fees ( gas ), which requires that you have funds in your wallet. In the Polkadot User Interface, go to Network \u2192 Accounts where you will see a list of pre-funded addresses called Alice, Bob, and so on. There you can send funds to your newly generated address to be able to pay for the gas. Sending 10 Units will suffice for running hundreds of simulations. These pre-funded accounts serve as a faucet as they do not represent real financial value and the transactions are simulated. Test pallet calls \u00b6 It is possible to manually test the Developer \u2192 Extrinsics \u2192 tradestorage in the UI. You can choose the prefunded addresses as the buyer (Alice) and the seller (Bob). Set a small amount e.g. 1 and rate (e.g.12) (rate here is the price at which the trade is executed). Trade ID is a bytes vector (e.g. 0x1234 ). If the extrinsic hash is successfully submitted, you will see a success message pop up in the top right corner of the UI. The Polkadot user interface does not allow you to directly go to that extrinsic hash, but you can go to Network and find the latest block. You may have to go to its parent or further to see the extrinsic hash. Running Grid Singularity Exchange with Substrate \u00b6 Go to src/d3a/blockchain/constants.py and set ENABLE_SUBSTRATE = True and add your mnemonic. That will allow all the blockchain dependencies to be installed with: fab sync Each transaction in the simulation triggers a call to the pallet. Currently, the buyer and the seller are default addresses. In addition to the buyer and seller, the trade structure has a trade ID, energy quantity, and rate. Following Grid Singularity Exchange\u2019s integration with the decentralized identity registry (Energy Web Switchboard), the addresses will be actual user accounts. In the terminal, you should see the extrinsic hash and the block hash. 17:39:37.466 WARNING ( 333) d3a.gsy_e_core.simulation : Slot 1 of 96 - (1.0%) 0.00 second elapsed, ETA: 0.01 second 17:39:41.974 INFO ( 122) root : Extrinsic '0xe1357be7db683e0f3f85e101ea017da10fcaa63310e4dc7040e505cad9ac1a0a' sent and included in block '0x2199d0870583183e6f2c591b66e9a1a9cb2399b7b3ed21b21c3804c3cfcf730f' 17:39:41.975 INFO ( 271) d3a.models.market.one_sided : [TRADE] [Grid] [2021-01-26T00:00] {7f15aa} [origin: H1 Storage2 -> Cell Tower] [IAA House 1 -> Cell Tower] 0.025 kWh @ 0.7500000000000001 30.0 db09b600-22a9-4feb-ae4d-620cb6247702 [fee: 0.0 cts.] The block hash will allow you to find your extrinsic hash, as in this example . View events \u2192 tradestorage.TradeMapStored (this event is triggered every time we call the pallet\u2019s store trade map function).","title":"Blockchain Integration"},{"location":"blockchain/#purpose","text":"Grid Singularity energy exchange engine has been designed so that it does not require blockchain technology, but that it can benefit from this technology to provide enhanced functionality. Grid Singularity aims to integrate blockchain for specific benefits: Decentralisation and transparency : blockchain can be used to create decentralized registry and identity. By doing so, the privacy and security of users are enhanced. Data ownership : End-users would have complete control over their data access and use Payments : Trades cleared on the market will be recorded on the chain and the payments executed. While the privacy of users will be preserved, the system would be more transparent. Degrees of Freedom : Bids and offers can be tagged with validated attributes to enable trading degrees of freedom such as preferred trading partner, energy source selection, or location restrictions on trades Asset validation : energy assets, smart meters, and entities can be validated using tools like the Energy Web Switchboard. The Energy Web Chain is the blockchain of choice for Grid Singularity Exchange future blockchain implementation. Grid Singularity, an energy technology startup, and the Rocky Mountain Institute, a nonprofit clean technology organisation, jointly founded the Energy Web Foundation (EWF) in January 2017. EWF is a nonprofit foundation gathering an ecosystem of over 100 energy corporations and startups with a shared, public blockchain platform, the Energy Web Chain. While Grid Singularity has significantly contributed to EWF development and the launch of the Energy Web Chain, its role today is supervisory and advisory, with two Grid Singularity representatives serving on the EWF\u2019s Foundation Council . At present, Grid Singularity Exchange blockchain integration is used just for simulated transactions and it is based on Substrate . We are also in the process of integrating with the Energy Web Switchboard , which will be used as a decentralized asset registry . In the future we plan to move to full implementation on the Energy Web Chain, benefiting from Polkadot\u2019s scaling solution. The current basic blockchain integration uses Substrate, which allows modular business logic to be built directly in the blockchain and facilitates a high transaction throughput. Substrate has components called pallets, where each pallet can represent different functionality, such as smart contracts, storage, auctions, and more . Currently, our integration includes a storage pallet that provides immutable storage of executed transactions, and additional functionalities will continue to be actively developed. Blockchain can optionally be enabled on simulations running locally with the backend code base. There are three configuration parameters. The command-line flag is --enable-bc , used to enable blockchain operations. The two other parameters are the mnemonic to restore your key and interact with the blockchain, and the ENABLE_SUBSTRATE parameter described in the steps below.","title":"Purpose"},{"location":"blockchain/#connecting-to-grid-singularity-node","text":"https://polkadot.js.org/apps/?rpc=wss%3A%2F%2Fcanvas-node.dev.gridsingularity.com When you go to the endpoint, you will see the standard interface. That\u2019s the easiest point of interaction with the node, where you can call extrinsics, upload contracts, deploy them, test their functions, send funds and more.","title":"Connecting to Grid Singularity node"},{"location":"blockchain/#simulating-grid-singularity-local-energy-markets-on-substrate","text":"","title":"Simulating Grid Singularity local energy markets on Substrate"},{"location":"blockchain/#wallet","text":"Ensure that you have the Polkadot Chrome extension (it is a browser extension that allows you to manage accounts for any Substrate-based blockchain). Create an account and save your seed phrase. You will need to save \"your twelve words\" mnemonic to be able to restore your key in general, and later to pass it the models/market/blockchain_utils.py in order to call the contracts on-chain from python code. Make sure never to push your mnemonic to GitHub.","title":"Wallet"},{"location":"blockchain/#balance","text":"If you want to send a transaction manually or through Grid Singularity Exchange in the development chain, you need to pay transaction fees ( gas ), which requires that you have funds in your wallet. In the Polkadot User Interface, go to Network \u2192 Accounts where you will see a list of pre-funded addresses called Alice, Bob, and so on. There you can send funds to your newly generated address to be able to pay for the gas. Sending 10 Units will suffice for running hundreds of simulations. These pre-funded accounts serve as a faucet as they do not represent real financial value and the transactions are simulated.","title":"Balance"},{"location":"blockchain/#test-pallet-calls","text":"It is possible to manually test the Developer \u2192 Extrinsics \u2192 tradestorage in the UI. You can choose the prefunded addresses as the buyer (Alice) and the seller (Bob). Set a small amount e.g. 1 and rate (e.g.12) (rate here is the price at which the trade is executed). Trade ID is a bytes vector (e.g. 0x1234 ). If the extrinsic hash is successfully submitted, you will see a success message pop up in the top right corner of the UI. The Polkadot user interface does not allow you to directly go to that extrinsic hash, but you can go to Network and find the latest block. You may have to go to its parent or further to see the extrinsic hash.","title":"Test pallet calls"},{"location":"blockchain/#running-grid-singularity-exchange-with-substrate","text":"Go to src/d3a/blockchain/constants.py and set ENABLE_SUBSTRATE = True and add your mnemonic. That will allow all the blockchain dependencies to be installed with: fab sync Each transaction in the simulation triggers a call to the pallet. Currently, the buyer and the seller are default addresses. In addition to the buyer and seller, the trade structure has a trade ID, energy quantity, and rate. Following Grid Singularity Exchange\u2019s integration with the decentralized identity registry (Energy Web Switchboard), the addresses will be actual user accounts. In the terminal, you should see the extrinsic hash and the block hash. 17:39:37.466 WARNING ( 333) d3a.gsy_e_core.simulation : Slot 1 of 96 - (1.0%) 0.00 second elapsed, ETA: 0.01 second 17:39:41.974 INFO ( 122) root : Extrinsic '0xe1357be7db683e0f3f85e101ea017da10fcaa63310e4dc7040e505cad9ac1a0a' sent and included in block '0x2199d0870583183e6f2c591b66e9a1a9cb2399b7b3ed21b21c3804c3cfcf730f' 17:39:41.975 INFO ( 271) d3a.models.market.one_sided : [TRADE] [Grid] [2021-01-26T00:00] {7f15aa} [origin: H1 Storage2 -> Cell Tower] [IAA House 1 -> Cell Tower] 0.025 kWh @ 0.7500000000000001 30.0 db09b600-22a9-4feb-ae4d-620cb6247702 [fee: 0.0 cts.] The block hash will allow you to find your extrinsic hash, as in this example . View events \u2192 tradestorage.TradeMapStored (this event is triggered every time we call the pallet\u2019s store trade map function).","title":"Running Grid Singularity Exchange with Substrate"},{"location":"canary-network/","text":"The Grid Singularity Canary Test Network (CN) is the first peer-to-peer energy exchange with live energy asset data and real-time trading . At the current stage, CN acts as a uni-directional bridge between the physical and digital world, reading real consumption and generation data from real energy assets in real-time, while simulating trading with the grid\u2019s digital twins. Flexible assets\u2019 digital twins such as storage are unbundled from their physical ones, to simulate the benefits of Local Energy Markets without real world energy and financial transactions. All energy trades in the GSy Canary Test Network are simulated, meaning that no real-world financial or energy transaction occurs and flexible assets such as batteries may physically charge or discharge at different times than their simulated behaviour in the Canary Network. The GSy Canary Test Network runs at real time, meaning that assets send their actual energy usage through the Asset API once every 15 minutes . This mimics how deployed exchanges will operate, but provides only a few sets of data points every hour, requiring iterations of experiments to which doesn\u2019t meet the needs of the ongoing research efforts to determine effective market, grid fee, and agent designs. Determining the mechanics for deployable markets require frequent iterations and experimentation. Grid Singularity simulations allow for energy exchanges to be run at warp speed, meaning one week of trading can be simulated and analysed in less than two hours. This functionality allows for rapid prototyping of grid models and experimental setups . CN is designed to host an iterative process to test new ideas in a safe environment, closest as possible to reality. The following link will direct you to the Grid Singularity Canary Test Network tutorial .","title":"Canary network"},{"location":"cloud-service-guide/","text":"Guide to setup and run an API agent from a cloud based service \u00b6 Amazon Web Services (AWS) \u00b6 Step 1: Set up an instance \u00b6 Login to your AWS account. If you don\u2019t have one, you can create one, the free plan is sufficient. Create a virtual machine. Select an AMI . We strongly recommend using Ubuntu Server 20.04 LTS (HVM), SSD Volume Type Choose instance type t2.micro 1vcpus and 1GiB and click on review and launch Create a new ssh key and download it on your local machine. The key file\u2019s format is .pem Now you need to copy your scripts/files from your local computer onto your AWS instance. To do that you need to connect to your instance by using the ssh key and your public DNS. You can find the DNS of your instance by selecting your instance and looking at the summary First you need to make sure your key is not publicly available on your machine. Run the following command chmod 400 path_to/mykey.pem Step 2: Upload relevant files onto the instance \u00b6 To copy a file into your AWS instance please run the equivalent command (with your own information) scp -i path_to_ssh_key.pem path_to_file username@public_DNS:/path_to_copy The username can be found after clicking on connect. The default username will depend on the instance platform you are using. If you are using Linux, \u201cubuntu\u201d will be the default username. Additionally we recommend copying your files into the home directory of your instance /home/ubuntu . Here is an example of command scp -i Desktop/mykey.pem myscript.py ubuntu@ec2-18-188-221-121.us-east-2.compute.amazonaws.com:/home/ubuntu/ Step 3: Connect to the instance \u00b6 Once you have copied all necessary files onto you AWS instance you can connect to your instance with 2 ways Directly with the AWS terminal cli that you can access by clicking on connect on your EC2 instance connect With your local terminal cli (recommended) To connect to your instance from your local terminal you just need to run the following command with your equivalent information ssh -i path_to/mykey.pem username@public_DNS Example ssh -i Desktop/mykey.pem ubuntu@ec2-18-188-221-121.us-east-2.compute.amazonaws.com Once connected, go into the directory you have previously sent your files. If you have copied them in /home/ubuntu , just run the following command cd /home/ubuntu You can list all the files in the directory, to confirm that your files are correctly copied onto the instance by running ls Step 4: Initialize the instance's environment and install Grid Singularity Client \u00b6 Update and install all required package on your AWS instance Update your sudo sudo apt update Install python3 pip sudo apt install python3-pip Add deadnakes to your system source sudo add-apt-repository ppa:deadsnakes/ppa Install python 3.6 sudo apt-get install python3.6 Install virtual environment sudo apt install python3-virtualenv Create a virtual environment with python 3.6 virtualenv /tmp/d3a --python=/usr/bin/python3.6 Activate your virtual environment source /tmp/d3a/bin/activate Install d3a api client pip3 install git+https://github.com/gridsingularity/d3a-api-client.git Step 5: Install screen and run the API agent \u00b6 To be able to run the script indefinitely on your AWS instance you need to install Linux Screen (that allows to have multiple screen within your terminal) with the following command sudo apt-get install screen Create a new screen screen -S screen_name Run your python script python3 assets.py To detach from the current screen session Ctr+a+d If you want to log back in the relevant screen run screen -r screen_name Once you are detached for the running screen you are able to close your terminal and your script will continue to run indefinitely on your AWS instance","title":"Cloud service guide"},{"location":"cloud-service-guide/#guide-to-setup-and-run-an-api-agent-from-a-cloud-based-service","text":"","title":"Guide to setup and run an API agent from a cloud based service"},{"location":"cloud-service-guide/#amazon-web-services-aws","text":"","title":"Amazon Web Services (AWS)"},{"location":"cloud-service-guide/#step-1-set-up-an-instance","text":"Login to your AWS account. If you don\u2019t have one, you can create one, the free plan is sufficient. Create a virtual machine. Select an AMI . We strongly recommend using Ubuntu Server 20.04 LTS (HVM), SSD Volume Type Choose instance type t2.micro 1vcpus and 1GiB and click on review and launch Create a new ssh key and download it on your local machine. The key file\u2019s format is .pem Now you need to copy your scripts/files from your local computer onto your AWS instance. To do that you need to connect to your instance by using the ssh key and your public DNS. You can find the DNS of your instance by selecting your instance and looking at the summary First you need to make sure your key is not publicly available on your machine. Run the following command chmod 400 path_to/mykey.pem","title":"Step 1: Set up an instance"},{"location":"cloud-service-guide/#step-2-upload-relevant-files-onto-the-instance","text":"To copy a file into your AWS instance please run the equivalent command (with your own information) scp -i path_to_ssh_key.pem path_to_file username@public_DNS:/path_to_copy The username can be found after clicking on connect. The default username will depend on the instance platform you are using. If you are using Linux, \u201cubuntu\u201d will be the default username. Additionally we recommend copying your files into the home directory of your instance /home/ubuntu . Here is an example of command scp -i Desktop/mykey.pem myscript.py ubuntu@ec2-18-188-221-121.us-east-2.compute.amazonaws.com:/home/ubuntu/","title":"Step 2: Upload relevant files onto the instance"},{"location":"cloud-service-guide/#step-3-connect-to-the-instance","text":"Once you have copied all necessary files onto you AWS instance you can connect to your instance with 2 ways Directly with the AWS terminal cli that you can access by clicking on connect on your EC2 instance connect With your local terminal cli (recommended) To connect to your instance from your local terminal you just need to run the following command with your equivalent information ssh -i path_to/mykey.pem username@public_DNS Example ssh -i Desktop/mykey.pem ubuntu@ec2-18-188-221-121.us-east-2.compute.amazonaws.com Once connected, go into the directory you have previously sent your files. If you have copied them in /home/ubuntu , just run the following command cd /home/ubuntu You can list all the files in the directory, to confirm that your files are correctly copied onto the instance by running ls","title":"Step 3: Connect to the instance"},{"location":"cloud-service-guide/#step-4-initialize-the-instances-environment-and-install-grid-singularity-client","text":"Update and install all required package on your AWS instance Update your sudo sudo apt update Install python3 pip sudo apt install python3-pip Add deadnakes to your system source sudo add-apt-repository ppa:deadsnakes/ppa Install python 3.6 sudo apt-get install python3.6 Install virtual environment sudo apt install python3-virtualenv Create a virtual environment with python 3.6 virtualenv /tmp/d3a --python=/usr/bin/python3.6 Activate your virtual environment source /tmp/d3a/bin/activate Install d3a api client pip3 install git+https://github.com/gridsingularity/d3a-api-client.git","title":"Step 4: Initialize the instance's environment and install Grid Singularity Client"},{"location":"cloud-service-guide/#step-5-install-screen-and-run-the-api-agent","text":"To be able to run the script indefinitely on your AWS instance you need to install Linux Screen (that allows to have multiple screen within your terminal) with the following command sudo apt-get install screen Create a new screen screen -S screen_name Run your python script python3 assets.py To detach from the current screen session Ctr+a+d If you want to log back in the relevant screen run screen -r screen_name Once you are detached for the running screen you are able to close your terminal and your script will continue to run indefinitely on your AWS instance","title":"Step 5: Install screen and run the API agent"},{"location":"collaboration/","text":"Note: Collaborations are only available at Grid Singularity\u2019s previous interface (d3a .io ) at the moment, and we will update this document as soon as the tool is migrated to the new interface. Collaboration is a type of simulation in the Grid Singularity user interface that allows multiple users to participate in the same environment. They can act in a collaborative or competitive way, aiming to optimize specific metrics, for instance the cost of energy bill or peak congestion. Users can connect through the Grid Singularity API to actively engage in the collaboration, assuming one of the following roles: Exchange Operator \u00b6 The exchange operator (EO) is responsible for building the digital twin representation of the electrical grid, including energy assets and (sub)markets. Once the setup is complete, the EO facilitates the approval of other users to register to manage a set of (sub)markets and energy assets, and subsequently launches the collaboration. The EO is also in charge of expanding the grid (see events ) or registering new energy assets in the course of a simulated collaboration. Grid Operator \u00b6 The grid operator role is designed specifically for Distribution System Operators (DSOs), Distribution Network Operators (DNOs), Independent System Operators (ISOs) and Transmission System Operators (TSOs), which can register to manage different (sub)markets, on different grid levels in the collaboration. Once registered and approved by the EO, they can manage the relevant markets by using the Grid Operator API to change grid fees to manage the grid congestion in the local energy market by optimizing specific metrics, such as peak percentage. Aggregator \u00b6 The aggregator role is designed for aggregator companies participating in the Grid Singularity Exchange. Aggregators can apply to manage energy assets (Load i.e. energy consumption , PV and Storage i.e. batteries ) owned by communities, consumers, producers and prosumers. Once approved by the Exchange Operator, aggregators are responsible for buying and selling energy on behalf of their customers by connecting their energy assets with set trading preferences through the Asset API . To create a Collaboration in the Grid Singularity user interface, follow these steps: Log-in to Grid Singularity Exchange (as noted, the full functionality is still available only via our previous interface: d3a.io) with your Grid Singularity credentials to automatically access previously created simulations. Select the simulation that you want to set up as a Collaboration by clicking on Edit \u2192 Create a Collaboration . If you have not yet created a simulation or want to create a new one, please follow the instructions here . Currently, this step is managed manually. A personal account of an external user does not have the admin rights to create a Collaboration. We are currently working on automating the functionalities of a Collaboration (i.e., connection with API). Please contact us at contact@gridsingularity.com for technical support and provide us with the following information: Your Name Grid Singularity account email address Company name Location of the community Size of the community (number of participants, assets) Current utility / grid operator Purpose of the Collaboration Simulation URL The simulation URL should look like this at the moment:","title":"Create a Grid Singularity Collaboration"},{"location":"collaboration/#exchange-operator","text":"The exchange operator (EO) is responsible for building the digital twin representation of the electrical grid, including energy assets and (sub)markets. Once the setup is complete, the EO facilitates the approval of other users to register to manage a set of (sub)markets and energy assets, and subsequently launches the collaboration. The EO is also in charge of expanding the grid (see events ) or registering new energy assets in the course of a simulated collaboration.","title":"Exchange Operator"},{"location":"collaboration/#grid-operator","text":"The grid operator role is designed specifically for Distribution System Operators (DSOs), Distribution Network Operators (DNOs), Independent System Operators (ISOs) and Transmission System Operators (TSOs), which can register to manage different (sub)markets, on different grid levels in the collaboration. Once registered and approved by the EO, they can manage the relevant markets by using the Grid Operator API to change grid fees to manage the grid congestion in the local energy market by optimizing specific metrics, such as peak percentage.","title":"Grid Operator"},{"location":"collaboration/#aggregator","text":"The aggregator role is designed for aggregator companies participating in the Grid Singularity Exchange. Aggregators can apply to manage energy assets (Load i.e. energy consumption , PV and Storage i.e. batteries ) owned by communities, consumers, producers and prosumers. Once approved by the Exchange Operator, aggregators are responsible for buying and selling energy on behalf of their customers by connecting their energy assets with set trading preferences through the Asset API . To create a Collaboration in the Grid Singularity user interface, follow these steps: Log-in to Grid Singularity Exchange (as noted, the full functionality is still available only via our previous interface: d3a.io) with your Grid Singularity credentials to automatically access previously created simulations. Select the simulation that you want to set up as a Collaboration by clicking on Edit \u2192 Create a Collaboration . If you have not yet created a simulation or want to create a new one, please follow the instructions here . Currently, this step is managed manually. A personal account of an external user does not have the admin rights to create a Collaboration. We are currently working on automating the functionalities of a Collaboration (i.e., connection with API). Please contact us at contact@gridsingularity.com for technical support and provide us with the following information: Your Name Grid Singularity account email address Company name Location of the community Size of the community (number of participants, assets) Current utility / grid operator Purpose of the Collaboration Simulation URL The simulation URL should look like this at the moment:","title":"Aggregator"},{"location":"community-settings/","text":"Users can configure the overall settings for their communities by selecting the blue dot on the circle surrounding their energy community on the Singularity Map. Figure 2.13 . Map view of community settings. Community Configuration Options \u00b6 Name: Must be unique. Currency: Choose the currency used by the community. Simulation Length: Users can choose the length of time of their simulation, as well as corresponding dates. By default, simulations are set to run for one week starting from the current date. If users upload their own data, they should set the simulation length, start date and end date according to the used profile. Show community on the Map: Users can choose whether or not their community will be publicly visible on the Singularity Map. If visible, the name, approximate location (circle outline) and simulation results will be available for anyone to see. This information will be kept private to the user if the user selects otherwise. Description: Users can add an optional description of their community. Solar profile: Users can choose between the template solar profiles of either sunny, partially cloudy, cloudy, Gaussian (each profile generated with a 250W panel), or upload their own custom generation profile ( see format required ). Spot market type - Users can select either the one-sided or two-sided market type. In the One-Sided Pay-as-Offer spot market , agents representing energy producers, including prosumers (sellers), post offers in the market with an energy price determined by the assets' trading strategy . In the Two-Sided spot market, where buyers are able to place bids in the market alongside the offers placed by sellers, users can choose between the Two-Sided Pay-as-Bid Market or the Two-Sided Pay-as-Clear Market . Bid offer match algorithm - Users can choose if they would like to have a Pay as Bid, Pay as Clear or External Matching trading algorithm . Number of spot markets - Number of future spot markets where the energy assets and agents can trade. Length of spot market - Users can choose the length of the spot market in minutes. Tick Length - Users can choose the length of ticks in seconds. Grid Fees - If switched on, users can select one of two types: Constant grid fee or Percentage grid fee . Constant grid fee allows users to enter a value in cents/kWh that will represent a fee applied to each trade that occurs in this market, while percentage grid fee allows users to enter a value in %. Market slot real time duration - Desired duration of a market slot in real time (default is 0s) Figure 2.14 . Community Settings Configuration Options","title":"Community Settings"},{"location":"community-settings/#community-configuration-options","text":"Name: Must be unique. Currency: Choose the currency used by the community. Simulation Length: Users can choose the length of time of their simulation, as well as corresponding dates. By default, simulations are set to run for one week starting from the current date. If users upload their own data, they should set the simulation length, start date and end date according to the used profile. Show community on the Map: Users can choose whether or not their community will be publicly visible on the Singularity Map. If visible, the name, approximate location (circle outline) and simulation results will be available for anyone to see. This information will be kept private to the user if the user selects otherwise. Description: Users can add an optional description of their community. Solar profile: Users can choose between the template solar profiles of either sunny, partially cloudy, cloudy, Gaussian (each profile generated with a 250W panel), or upload their own custom generation profile ( see format required ). Spot market type - Users can select either the one-sided or two-sided market type. In the One-Sided Pay-as-Offer spot market , agents representing energy producers, including prosumers (sellers), post offers in the market with an energy price determined by the assets' trading strategy . In the Two-Sided spot market, where buyers are able to place bids in the market alongside the offers placed by sellers, users can choose between the Two-Sided Pay-as-Bid Market or the Two-Sided Pay-as-Clear Market . Bid offer match algorithm - Users can choose if they would like to have a Pay as Bid, Pay as Clear or External Matching trading algorithm . Number of spot markets - Number of future spot markets where the energy assets and agents can trade. Length of spot market - Users can choose the length of the spot market in minutes. Tick Length - Users can choose the length of ticks in seconds. Grid Fees - If switched on, users can select one of two types: Constant grid fee or Percentage grid fee . Constant grid fee allows users to enter a value in cents/kWh that will represent a fee applied to each trade that occurs in this market, while percentage grid fee allows users to enter a value in %. Market slot real time duration - Desired duration of a market slot in real time (default is 0s) Figure 2.14 . Community Settings Configuration Options","title":"Community Configuration Options"},{"location":"community/","text":"The Singularity Map is an interactive Grid Singularity exchange simulation platform where users can model and simulate digital twins (digital representations) of their communities. Users add household (or buildings) energy assets such as, consumption profiles, solar panels (PVs), and / or storages (batteries), which are represented by trading agents, trading energy according to user preferences. The purpose of the simulation is to configure and optimise the local energy market structure digitally before bringing the energy communities to reality through a physical deployment. Figure 2.1 . The Singularity Map - Grid Singularity Exchange web-based interface at https://map.gridsingularity.com/singularity-map . The map includes a search bar in the top left corner, a list of simulations in the extendable panel below the search bar, user icons on the right hand side of the screen (explained below) and coloured dots representing different simulations on the map. Icons This icon allows the user to reorient their view of the map to the standard north-facing direction. These icons allow users to zoom in and out of the map. This icon allows access to the user's location. These icons allow users a change of view between birds eye view (straight down/2D) and 3D. This icon allows the user to see their assets in a list view and to click on the items in the list in order to navigate the map and results views This icon allows the user to request upgrading their simulation to the Canary Network Legend Figure 2.2 . Legend explaining colouring for the energy import / export The coloured dots on the map represent energy community simulations. A legend on the top right \ud83d\udfe2 Green dots are communities that have a net export of energy. \ud83d\udd34 Red dots are communities that have a net import of energy. \ud83d\udd35 Blue dots are communities that have a neutral energy balance (neither net import/export) or haven\u2019t been simulated yet. Profile configuration By clicking on the icon in the top right corner next to \u201cRun Simulation\u201d, users can see their profile, edit their password, and change their profile picture by clicking on the image and uploading a file from their computer (as shown in the picture below). Figure2.3. User profile in the Singularity Map Building a Community to simulate To build a community, the user should take the following steps: Choose location - The first step is to choose the location for the community. Users can find their location by manually navigating the map or by typing their location in the search bar. Add homes (or other buildings) and energy assets - Once a location has been selected, users can start building their community by adding homes and energy assets. A community must have at least two homes before it can be saved and local energy trading simulated. Log in or register an account. Name the community, set the simulation period and save it. Run the simulation and view the results. A guided onboarding of this process launches automatically on the top right hand side of the screen for new users. Figure 2.4 : Guided Onboarding Feature Users can show/hide this feature by clicking on the icon at the top of the icon list on the right hand side of the screen. This icon and feature only appear after a user has chosen their location and selected the first button to start building their community. Figure 2.5 : The first button a user selects to start building their community.","title":"Build a community"},{"location":"configuration/","text":"There are three different types of assets a user can currently add to their communities on the Singularity Map - solar panels (PVs), consumption load profiles and batteries (storages) which can be grouped into homes. Each community can consist of at least two homes and assets and up to 1000 assets and/or homes. Users can create energy community prototypes quickly by adding template homes and assets using the express options, or they can configure the technical details and trading parameters of their communities\u2019 homes and assets by exploring the advanced options of each asset. Each asset within a community can trade energy with others and also with the grid. By default, assets tend to buy/sell energy locally with their neighbours and then if not possible they purchase the energy from the energy supplier (usually a utility). Trading occurs in market slots , which are by default 15-minute time slots in which energy assets can exchange energy at predefined market rates. This parameter can be changed by a user to reflect the spot market length of any region of the world. Users can set custom market rates or use default rates when adding assets to their communities. Users can set trading preferences for the energy assets within their community in the advanced settings of the assets for example by indicating the type of energy they would like to purchase or preferred trading partner.","title":"Overview"},{"location":"configure-trading-strategies-walkthrough/","text":"The Grid Singularity Asset API is designed for aggregators (energy service providers) who wish to provide their customers (individuals and communities) with benefits of peer-to-peer and community trading facilitated by the Grid Singularity Exchange. They can create agents that follow custom trading strategies to buy and sell energy in the energy market on behalf of managed energy assets. The agent can request and receive information through the Asset API, feed that information into an algorithm, and post bids or offers on the exchange. To actively place bids and offers on behalf of energy assets, please follow these steps: Install the Grid Singularity Exchange SDK on your computer by launching the following commands on your terminal window: Install gsy-e-sdk mkvirtualenv gsy-e-sdk pip install https://github.com/gridsingularity/gsy-e-sdk.git Update gsy-e-sdk (needed when an update is deployed) pip uninstall -y gsy-e-sdk pip install git+https://github.com/gridsingularity/gsy-e-sdk.git Go to the Registry section of the Collaboration of your interest and apply for each asset you wish to connect to manage their trading strategies by clicking on the asset or home. Then click on the green Apply button. If you have not already created a Collaboration / Canary Test Network or users are not yet registered for their assets, please follow instructions respectively here or here first. Notify Grid Singularity administration by sending an email to contact@gridsingularity.com to accept your applications (note: this action will be automated in the future). Edit the Asset SDK Script template developed by Grid Singularity to customize the trading strategies. Launch the Asset SDK Script to connect with the Grid Singularity Collaboration / Canary Test Network. A video tutorial is also available here . Run the Collaboration or notify Grid Singularity that you are ready.","title":"Walkthrough"},{"location":"connect-ctn/","text":"Connect to a Grid Singularity Canary Test Network \u00b6 The Grid Singularity Canary Test Network, inspired by the \u201ccanary in a coal mine\u201d, is designed to test new ideas while operating in conditions as close as possible to reality. Energy assets, managed by aggregators, send their actual energy usage through the Asset API each 15 minutes (or another specified timeframe depending on the determined spot market length) and the exchange operates in real-time to facilitate local energy markets. However, the network does not represent actual energy and financial transactions because the assets\u2019 virtual representations (digital twins) are decoupled in state from their physical (e.g. a battery\u2019s digital twin might have a different state of charge in simulation vs. reality). To create a Grid Singularity Canary Test Network, follow these steps (a video tutorial is also available here ): Select the Simulation that you want to set up as a Canary Test Network. Once your simulation has completed, click on settings, and click Go in the box that says, \u201cbring your simulation closer to reality\u201d. A Grid Singularity agent will be in touch with you shortly after to lead you through setting up a Canary Network. Currently, this step requires manual Grid Singularity intervention. A personal account of an external user does not have the admin rights to create a Canary Test Network. If you have any questions, please contact us at contact@gridsingularity.com for technical support and provide us with the following: Your Name Grid Singularity account email address Company name Location of the community Size of the community (number of participants, assets) Energy Supplier / grid operator Purpose of the canary network Simulation name Once Grid Singularity has approved your request, follow the steps below: With the creation of a Canary Network, a Registry tab has been added next to settings in the sidebar. Each homeowner or asset owner can be assigned to a home and invited to participate in the Canary Network by email through the Add More People invitation tool by the Canary Network owner. Once they accept the emailed invitation, they will be able to view the simulation and their assets through the Registry . The Canary Network owner can also set User Roles for each user. Invited people default to GSy User , allowing them to view and analyze results for their owned assets. Aggregators must login and register to trade on behalf of each asset on the Community Assets tab. Once their registration is accepted by the simulation owner, they can trade on behalf of assets through the Asset API . The Grid Operator, once registered, has access to manage grid fees and network congestion through the Grid Operator API . Connect live data streams to the energy exchange (see section below ).","title":"Connect to a Grid Singularity Canary Test Network"},{"location":"connect-ctn/#connect-to-a-grid-singularity-canary-test-network","text":"The Grid Singularity Canary Test Network, inspired by the \u201ccanary in a coal mine\u201d, is designed to test new ideas while operating in conditions as close as possible to reality. Energy assets, managed by aggregators, send their actual energy usage through the Asset API each 15 minutes (or another specified timeframe depending on the determined spot market length) and the exchange operates in real-time to facilitate local energy markets. However, the network does not represent actual energy and financial transactions because the assets\u2019 virtual representations (digital twins) are decoupled in state from their physical (e.g. a battery\u2019s digital twin might have a different state of charge in simulation vs. reality). To create a Grid Singularity Canary Test Network, follow these steps (a video tutorial is also available here ): Select the Simulation that you want to set up as a Canary Test Network. Once your simulation has completed, click on settings, and click Go in the box that says, \u201cbring your simulation closer to reality\u201d. A Grid Singularity agent will be in touch with you shortly after to lead you through setting up a Canary Network. Currently, this step requires manual Grid Singularity intervention. A personal account of an external user does not have the admin rights to create a Canary Test Network. If you have any questions, please contact us at contact@gridsingularity.com for technical support and provide us with the following: Your Name Grid Singularity account email address Company name Location of the community Size of the community (number of participants, assets) Energy Supplier / grid operator Purpose of the canary network Simulation name Once Grid Singularity has approved your request, follow the steps below: With the creation of a Canary Network, a Registry tab has been added next to settings in the sidebar. Each homeowner or asset owner can be assigned to a home and invited to participate in the Canary Network by email through the Add More People invitation tool by the Canary Network owner. Once they accept the emailed invitation, they will be able to view the simulation and their assets through the Registry . The Canary Network owner can also set User Roles for each user. Invited people default to GSy User , allowing them to view and analyze results for their owned assets. Aggregators must login and register to trade on behalf of each asset on the Community Assets tab. Once their registration is accepted by the simulation owner, they can trade on behalf of assets through the Asset API . The Grid Operator, once registered, has access to manage grid fees and network congestion through the Grid Operator API . Connect live data streams to the energy exchange (see section below ).","title":"Connect to a Grid Singularity Canary Test Network"},{"location":"connection-energy-assets/","text":"Send live energy asset data streams to the Grid Singularity exchange \u00b6 Once the Grid Singularity Canary Test Network is created, you need to send the live data stream from your community energy assets to the Grid Singularity exchange by establishing a connection from your hardware\u2019s data service through the Grid Singularity Asset API . Please make sure to satisfy all the data requirements (check here ) in order to connect live data streams to the Canary Network. Enable Live Asset data on the User Interface \u00b6 On the map, the Canary Network owner can click on the home and the asset they\u2019d like to connect live data to. In the Advanced Settings tab, the live data switch can be toggled so the checkmark is highlighted. Once this step and the one below is completed ( Establish a connection with your energy assets ), the real energy data will be represented for those assets in the results in the UI. Note that if live data is turned off, data will be read through the uploaded profiles instead of reading data sent through the Asset API. Establish a connection with your energy assets \u00b6 It is possible to connect and register automatically to a running Canary Network: User-Interface (currently d3a.io) (here the energy asset uuid has to be obtained first) \u00b6 asset_uuid = get_area_uuid_from_area_name_and_collaboration_id( <simulation_id>, <asset_name>, <domain_name> ) asset_client = RestAssetClient(asset_uuid, autoregister=True) Backend simulation \u00b6 asset_client = RedisAssetClient(<asset-uuid>, autoregister=True) Otherwise, it is also possible to connect manually by doing: asset_client.register() To disconnect/unregistering, the following command is available: asset_client.unregister() There are two options for you to connect live data streaming to the Grid Singularity Exchange: Exchange SDK (recommended, python-based agents) REST API (for non-python trading agents)","title":"Establish a connection with your energy assets"},{"location":"connection-energy-assets/#send-live-energy-asset-data-streams-to-the-grid-singularity-exchange","text":"Once the Grid Singularity Canary Test Network is created, you need to send the live data stream from your community energy assets to the Grid Singularity exchange by establishing a connection from your hardware\u2019s data service through the Grid Singularity Asset API . Please make sure to satisfy all the data requirements (check here ) in order to connect live data streams to the Canary Network.","title":"Send live energy asset data streams to the Grid Singularity exchange"},{"location":"connection-energy-assets/#enable-live-asset-data-on-the-user-interface","text":"On the map, the Canary Network owner can click on the home and the asset they\u2019d like to connect live data to. In the Advanced Settings tab, the live data switch can be toggled so the checkmark is highlighted. Once this step and the one below is completed ( Establish a connection with your energy assets ), the real energy data will be represented for those assets in the results in the UI. Note that if live data is turned off, data will be read through the uploaded profiles instead of reading data sent through the Asset API.","title":"Enable Live Asset data on the User Interface"},{"location":"connection-energy-assets/#establish-a-connection-with-your-energy-assets","text":"It is possible to connect and register automatically to a running Canary Network:","title":"Establish a connection with your energy assets"},{"location":"connection-energy-assets/#user-interface-currently-d3aio-here-the-energy-asset-uuid-has-to-be-obtained-first","text":"asset_uuid = get_area_uuid_from_area_name_and_collaboration_id( <simulation_id>, <asset_name>, <domain_name> ) asset_client = RestAssetClient(asset_uuid, autoregister=True)","title":"User-Interface (currently d3a.io) (here the energy asset uuid has to be obtained first)"},{"location":"connection-energy-assets/#backend-simulation","text":"asset_client = RedisAssetClient(<asset-uuid>, autoregister=True) Otherwise, it is also possible to connect manually by doing: asset_client.register() To disconnect/unregistering, the following command is available: asset_client.unregister() There are two options for you to connect live data streaming to the Grid Singularity Exchange: Exchange SDK (recommended, python-based agents) REST API (for non-python trading agents)","title":"Backend simulation"},{"location":"constant-fees/","text":"The constant grid fee is a market based fee, defined in \u20ac/kWh and added to each trade that is cleared, as shown in the figure below. Figure 3.15 . Constant grid fee calculation in the Grid Singularity Exchange. The rate of a bid or offer changes as that bid or offer is propagated into different markets. The offer rate increases to account for the added fees for the relevant market, ensuring that the seller receives a revenue equal or greater than the original offer. The bid rate decreases for the same reason. Example Calculation in One-Sided Pay-as-Offer Market \u00b6 Figure 3.16 . Constant Grid Fee Example Calculation in One-Sided Pay-as-Offer Market. In an One-Sided Pay-as-Offer market, there are no bids, only offers. Offers are propagated throughout the markets in the hierarchy shown in the figure above. Grid fees are accounted for when an offer is forwarded to the higher market, adding that market\u2019s grid fees to any previously accumulated fees. The formula to calculate the new offer rate when placing an offer to a higher market is the following: offer_rate_after_fees (\u20ac/kWh) = offer_rate (\u20ac/kWh) + grid_fee (\u20ac/kWh) If the offer is not purchased after two ticks , it is moved into the next market, with the total rate incremented by the amount of that market's grid fee. In the example above, the PV offer of 0.10 \u20ac/kWh is first placed into the House 2 Market where it gains zero fees. Then it moves into the Neighborhood 2 Market, gaining a fee of 0.01 \u20ac/kWh to become 0.11 \u20ac/kWh. Then, if not purchased, it moves into the Grid Market, gaining a fee of 0.02 \u20ac/kWh to become 0.13 \u20ac/kWh. Continuing into the Neighborhood 1 Market, the offer gains a fee of 0.01 \u20ac/kWh to become 0.14 \u20ac/kWh. Continuing into the House 1 Market, the offer gains zero fees. The Load ultimately buys the offer in the House 1 Market at the Clearing Rate of 0.14 \u20ac/kWh. The trade price is calculated by adding the original offer rate ( 0.10 \u20ac/kWh ) and the total fees ( (0.01+0.02+0.01) = 0.04 \u20ac/kWh ), then multiplying by the amount of energy traded ( 1 kWh ) to yield the Trade Price of 0.14\u20ac. The Load pays the Trade Price of 0.14\u20ac, which includes 0.10\u20ac revenue for the PV, 0.01\u20ac fees for the Neighborhood Market 1, 0.02\u20ac fees for the Grid Market, and 0.01\u20ac fees for the Neighborhood Market 2. Since the market type is pay-as-offer, the offer rate is used as the clearing rate. The grid fees are added to the offer rate to determine the trade rate and therefore the trade price in each market. The following formula is used: supply_side_fee (\u20ac/kWh) = forwarded_offer_rate (\u20ac/kWh) - original_offer_rate (\u20ac/kWh) trade_rate (\u20ac/kWh) = clearing rate (\u20ac/kWh) trade_price (\u20ac) = energy (kWh) * trade_rate (\u20ac/kWh) For the provided example, the trade price for each market is: Market_trade_price (\u20ac) = (original_offer_rate (\u20ac/kWh) + supply_side_fee (\u20ac/kWh)) * energy (kWh) Grid Market = (0.10 + 0.03)*1 = 0.13 Neighborhood 2 Market = (0.10 + 0.01)*1 = 0.11 Neighborhood 1 Market = (0.10 + 0.04)*1 = 0.14 House 1 Market = (0.10 + 0.04)*1 = 0.14 House 2 Market = (0.10 + 0)*1 = 0.10 Example Calculation in Two-Sided Pay-as-Bid Market \u00b6 Figure 3.17 . Constant Grid Fee Example Calculation in Two-Sided Pay-as-Bid Market. In the Two-Sided Pay-as-Bid market, there are both bids and offers, and both are propagated through the markets in the hierarchy. If a bid or offer is not matched after two ticks , it is moved into the next market. In order to prevent the double accounting of a market's grid fee when a bid and an offer are matched in that market, market fees are added to offers when they enter a new market (target market), and they are subtracted from bids when they leave a market (source market) and enter another one. The formula for propagating the offers is the same as for the one-sided market : offer_rate_after_fees (\u20ac/kWh) = offer_rate (\u20ac/kWh) + grid_fee (\u20ac/kWh) The IAA subtracts the fees from the bid before propagating the bid to the higher market, based on the following formula: bid_rate_after_fees (\u20ac/kWh) = bid_rate (\u20ac/kWh) - grid_fee (\u20ac/kWh) In the case of a Two-Sided Pay-as-Bid market, the offer is moved into the Grid Market by the same mechanism as in the One-Sided Pay-as-Offer market. The bid of 0.30 \u20ac/kWh is placed into the House 1 Market where there are zero fees. If it is not purchased after two ticks, it is moved into the Neighborhood 1 Market. As explained above, only the fees from the source market are added, which are zero in this case. Hence the bid rate remains 0.30 \u20ac/kWh. Next, the bid is moved into the Grid Market, where its value is reduced by the amount of the fees of its source market, the Neighborhood 1 Market at 0.01 \u20ac/kWh, resulting in a rate of 0.29 \u20ac/kWh as it enters the Grid Market. In the example above, the bid and offer are matched in the Grid Market. When the offer entered the Grid Market, its rate was immediately updated to account for the Grid Market fees (0.11 + 0.02). The bid was not updated, and if it was not matched in the Grid Market and moved to the Neighborhood 2 Market, the 0.02 \u20ac/kWh fee from the Grid Market would be subtracted to become (0.29 - 0.02) 0.27 \u20ac/kWh. The fees from the Neighborhood 2 Market would not be added to the bid unless it entered the House 2 Market (fees added according to the source market). In the Grid Market, the Load bid rate is listed as 0.29 \u20ac/kWh and the PV offer as 0.13 \u20ac/kWh. As the bid\u2019s rate is greater than the offer\u2019s rate, a trade can be scheduled. The trade clears at the bid\u2019s rate, resulting in a Clearing Rate of 0.29 \u20ac/kWh. The Grid Singularity energy exchange engine includes an algorithm that calculates the grid fee according to the clearing rate, basing the calculation on the original bid and offer rates. This allows the markets to act more independently and in a decentralized manner, without having to share information regarding their fees with other markets. The algorithm formula is as follows: demand_side_fee (\u20ac/kWh) = original_bid_rate (\u20ac/kWh) - forwarded_bid_rate (\u20ac/kWh) supply_side_fee (\u20ac/kWh) = forwarded_offer_rate (\u20ac/kWh) - original_offer_rate (\u20ac/kWh) For the example, we have the following values: supply_side_fee = 0.13 - 0.10 = 0.03 \u20ac/kWh demand_side_fee = 0.30 - 0.29 = 0.01 \u20ac/kWh After calculating the supply and demand side fee, the trade revenue can be calculated. Note the original_trade_rate is the amount that the original buyer (in our case the Load) will need to pay, therefore in the Pay-as-Bid market type this is the original bid price. The formula is the following: total_fee (\u20ac/kWh) = supply_side_fee (\u20ac/kWh) + demand_side_fee (\u20ac/kWh) revenue_rate (\u20ac/kWh) = original_trade_rate (\u20ac/kWh) - total_fee (\u20ac/kWh) For the example, the revenue will be: revenue = 0.30 - 0.04 = 0.26 \u20ac/kWh Finally, the trade rate is adapted according to the supply side fee, in order to include the fees of the current market: trade_rate (\u20ac/kWh) = revenue_rate (\u20ac/kWh) + supply_side_fee (\u20ac/kWh) trade_price (\u20ac) = energy (kWh) * trade_rate (\u20ac/kWh) For our example, the trade price for each market is: Market_trade_price (\u20ac) = (revenue_rate (\u20ac/kWh) + supply_side_fee (\u20ac/kWh)) * energy (kWh) Grid Market = (0.26 + 0.03)*1 = 0.29, Neighborhood 2 Market = (0.26 + 0.01)*1 = 0.27, Neighborhood 1 Market = (0.26 + 0.04)*1 = 0.30, House 1 Market = (0.26 + 0.04)*1 = 0.30, House 2 Market = (0.26 + 0)*1 = 0.26. The Load pays the Trade Price of 0.30\u20ac, which includes 0.26\u20ac revenue for the PV, 0.01\u20ac fees for Neighborhood Market 1, 0.02\u20ac fees for the Grid Market, and 0.01\u20ac fees for the Neighborhood Market 2.","title":"Constant Grid Fee Calculation"},{"location":"constant-fees/#example-calculation-in-one-sided-pay-as-offer-market","text":"Figure 3.16 . Constant Grid Fee Example Calculation in One-Sided Pay-as-Offer Market. In an One-Sided Pay-as-Offer market, there are no bids, only offers. Offers are propagated throughout the markets in the hierarchy shown in the figure above. Grid fees are accounted for when an offer is forwarded to the higher market, adding that market\u2019s grid fees to any previously accumulated fees. The formula to calculate the new offer rate when placing an offer to a higher market is the following: offer_rate_after_fees (\u20ac/kWh) = offer_rate (\u20ac/kWh) + grid_fee (\u20ac/kWh) If the offer is not purchased after two ticks , it is moved into the next market, with the total rate incremented by the amount of that market's grid fee. In the example above, the PV offer of 0.10 \u20ac/kWh is first placed into the House 2 Market where it gains zero fees. Then it moves into the Neighborhood 2 Market, gaining a fee of 0.01 \u20ac/kWh to become 0.11 \u20ac/kWh. Then, if not purchased, it moves into the Grid Market, gaining a fee of 0.02 \u20ac/kWh to become 0.13 \u20ac/kWh. Continuing into the Neighborhood 1 Market, the offer gains a fee of 0.01 \u20ac/kWh to become 0.14 \u20ac/kWh. Continuing into the House 1 Market, the offer gains zero fees. The Load ultimately buys the offer in the House 1 Market at the Clearing Rate of 0.14 \u20ac/kWh. The trade price is calculated by adding the original offer rate ( 0.10 \u20ac/kWh ) and the total fees ( (0.01+0.02+0.01) = 0.04 \u20ac/kWh ), then multiplying by the amount of energy traded ( 1 kWh ) to yield the Trade Price of 0.14\u20ac. The Load pays the Trade Price of 0.14\u20ac, which includes 0.10\u20ac revenue for the PV, 0.01\u20ac fees for the Neighborhood Market 1, 0.02\u20ac fees for the Grid Market, and 0.01\u20ac fees for the Neighborhood Market 2. Since the market type is pay-as-offer, the offer rate is used as the clearing rate. The grid fees are added to the offer rate to determine the trade rate and therefore the trade price in each market. The following formula is used: supply_side_fee (\u20ac/kWh) = forwarded_offer_rate (\u20ac/kWh) - original_offer_rate (\u20ac/kWh) trade_rate (\u20ac/kWh) = clearing rate (\u20ac/kWh) trade_price (\u20ac) = energy (kWh) * trade_rate (\u20ac/kWh) For the provided example, the trade price for each market is: Market_trade_price (\u20ac) = (original_offer_rate (\u20ac/kWh) + supply_side_fee (\u20ac/kWh)) * energy (kWh) Grid Market = (0.10 + 0.03)*1 = 0.13 Neighborhood 2 Market = (0.10 + 0.01)*1 = 0.11 Neighborhood 1 Market = (0.10 + 0.04)*1 = 0.14 House 1 Market = (0.10 + 0.04)*1 = 0.14 House 2 Market = (0.10 + 0)*1 = 0.10","title":"Example Calculation in One-Sided Pay-as-Offer Market"},{"location":"constant-fees/#example-calculation-in-two-sided-pay-as-bid-market","text":"Figure 3.17 . Constant Grid Fee Example Calculation in Two-Sided Pay-as-Bid Market. In the Two-Sided Pay-as-Bid market, there are both bids and offers, and both are propagated through the markets in the hierarchy. If a bid or offer is not matched after two ticks , it is moved into the next market. In order to prevent the double accounting of a market's grid fee when a bid and an offer are matched in that market, market fees are added to offers when they enter a new market (target market), and they are subtracted from bids when they leave a market (source market) and enter another one. The formula for propagating the offers is the same as for the one-sided market : offer_rate_after_fees (\u20ac/kWh) = offer_rate (\u20ac/kWh) + grid_fee (\u20ac/kWh) The IAA subtracts the fees from the bid before propagating the bid to the higher market, based on the following formula: bid_rate_after_fees (\u20ac/kWh) = bid_rate (\u20ac/kWh) - grid_fee (\u20ac/kWh) In the case of a Two-Sided Pay-as-Bid market, the offer is moved into the Grid Market by the same mechanism as in the One-Sided Pay-as-Offer market. The bid of 0.30 \u20ac/kWh is placed into the House 1 Market where there are zero fees. If it is not purchased after two ticks, it is moved into the Neighborhood 1 Market. As explained above, only the fees from the source market are added, which are zero in this case. Hence the bid rate remains 0.30 \u20ac/kWh. Next, the bid is moved into the Grid Market, where its value is reduced by the amount of the fees of its source market, the Neighborhood 1 Market at 0.01 \u20ac/kWh, resulting in a rate of 0.29 \u20ac/kWh as it enters the Grid Market. In the example above, the bid and offer are matched in the Grid Market. When the offer entered the Grid Market, its rate was immediately updated to account for the Grid Market fees (0.11 + 0.02). The bid was not updated, and if it was not matched in the Grid Market and moved to the Neighborhood 2 Market, the 0.02 \u20ac/kWh fee from the Grid Market would be subtracted to become (0.29 - 0.02) 0.27 \u20ac/kWh. The fees from the Neighborhood 2 Market would not be added to the bid unless it entered the House 2 Market (fees added according to the source market). In the Grid Market, the Load bid rate is listed as 0.29 \u20ac/kWh and the PV offer as 0.13 \u20ac/kWh. As the bid\u2019s rate is greater than the offer\u2019s rate, a trade can be scheduled. The trade clears at the bid\u2019s rate, resulting in a Clearing Rate of 0.29 \u20ac/kWh. The Grid Singularity energy exchange engine includes an algorithm that calculates the grid fee according to the clearing rate, basing the calculation on the original bid and offer rates. This allows the markets to act more independently and in a decentralized manner, without having to share information regarding their fees with other markets. The algorithm formula is as follows: demand_side_fee (\u20ac/kWh) = original_bid_rate (\u20ac/kWh) - forwarded_bid_rate (\u20ac/kWh) supply_side_fee (\u20ac/kWh) = forwarded_offer_rate (\u20ac/kWh) - original_offer_rate (\u20ac/kWh) For the example, we have the following values: supply_side_fee = 0.13 - 0.10 = 0.03 \u20ac/kWh demand_side_fee = 0.30 - 0.29 = 0.01 \u20ac/kWh After calculating the supply and demand side fee, the trade revenue can be calculated. Note the original_trade_rate is the amount that the original buyer (in our case the Load) will need to pay, therefore in the Pay-as-Bid market type this is the original bid price. The formula is the following: total_fee (\u20ac/kWh) = supply_side_fee (\u20ac/kWh) + demand_side_fee (\u20ac/kWh) revenue_rate (\u20ac/kWh) = original_trade_rate (\u20ac/kWh) - total_fee (\u20ac/kWh) For the example, the revenue will be: revenue = 0.30 - 0.04 = 0.26 \u20ac/kWh Finally, the trade rate is adapted according to the supply side fee, in order to include the fees of the current market: trade_rate (\u20ac/kWh) = revenue_rate (\u20ac/kWh) + supply_side_fee (\u20ac/kWh) trade_price (\u20ac) = energy (kWh) * trade_rate (\u20ac/kWh) For our example, the trade price for each market is: Market_trade_price (\u20ac) = (revenue_rate (\u20ac/kWh) + supply_side_fee (\u20ac/kWh)) * energy (kWh) Grid Market = (0.26 + 0.03)*1 = 0.29, Neighborhood 2 Market = (0.26 + 0.01)*1 = 0.27, Neighborhood 1 Market = (0.26 + 0.04)*1 = 0.30, House 1 Market = (0.26 + 0.04)*1 = 0.30, House 2 Market = (0.26 + 0)*1 = 0.26. The Load pays the Trade Price of 0.30\u20ac, which includes 0.26\u20ac revenue for the PV, 0.01\u20ac fees for Neighborhood Market 1, 0.02\u20ac fees for the Grid Market, and 0.01\u20ac fees for the Neighborhood Market 2.","title":"Example Calculation in Two-Sided Pay-as-Bid Market"},{"location":"consumption/","text":"The load is an energy asset that consumes energy over time. It is possible to use a single load to represent an entire building\u2019s consumption, as well as to configure multiple loads to represent different assets within a building (e.g. washing machine, air-conditioner, etc.).. Users are provided with template consumption load profiles from which they can choose those that are most suitable for the homes in their communities. The template consumption profiles are modelled using data from Load Profile Generator . Users who want to upload their own consumption profile data can do so in the \u2018upload profile\u2019 section in the PV advanced settings, after initially selecting a template consumption profile. Asset Configuration Options \u00b6 Express Mode Name - Must be unique Geo-tag - This automatically uploads the location a user selects Advanced Mode Load profile - Users can choose between user upload profile and user configure profile. User upload profile automatically loads as the template consumption profile selected, however this option also allows users to upload the data from their own consumption profile. User configure profile allows users to manually create a consumption profile by editing the load average power (W), the hours per day and the hours of day. The last option notably allows users to model disaggregated consuming devices such as a TV, Washing Machine, Boiler etc. a) Upload Profile - This option appears if a user selects \u2018user upload profile\u2019. The template consumption profile selected automatically loads, or users can upload their own consumption load profile data here in a csv file (respecting the required format . b) Average Power, Hours per day, Hours of day - These options appear if a user selects \u2018user configure profile\u2019. - Average power: Users can select the average consuming power of the load profile in Watts. - Hours per day: Users can select the number of hours the load operates per day. - Hours of day: The time range in which the load operates. 3. Initial buying rate - Users can choose the initial energy buying rate for the beginning of each market slot in cents/kWh. 4. Final buying rate: Users can choose the final energy buying rate at the end of each market slot in cents/kWh. Users can enter a custom value or choose the Market Maker rate. 5. Rate increase - Explicit rate increase increment per update interval in cents/kWh 6. Fit to limits: If activated, a rate decrease per time is calculated, starting at initial buying rate and ending at final buying rate while updating the rate at each Update Interval. The bidding behaviour is derived from a linear fitted curve of a buying rate between initial_buying_rate and final_buying_rate within the bidding interval. If activated, energy rate_increase = (final_buying_rate - initial_buying_rate) / max(int((slot_length / update_interval) -1), 1) 7.Update interval - Users can choose the frequency at which the rate is updated. Figure 2.11 . Consumption Load Profile Advanced Configuration Options","title":"Consumption (Load Profiles)"},{"location":"consumption/#asset-configuration-options","text":"Express Mode Name - Must be unique Geo-tag - This automatically uploads the location a user selects Advanced Mode Load profile - Users can choose between user upload profile and user configure profile. User upload profile automatically loads as the template consumption profile selected, however this option also allows users to upload the data from their own consumption profile. User configure profile allows users to manually create a consumption profile by editing the load average power (W), the hours per day and the hours of day. The last option notably allows users to model disaggregated consuming devices such as a TV, Washing Machine, Boiler etc. a) Upload Profile - This option appears if a user selects \u2018user upload profile\u2019. The template consumption profile selected automatically loads, or users can upload their own consumption load profile data here in a csv file (respecting the required format . b) Average Power, Hours per day, Hours of day - These options appear if a user selects \u2018user configure profile\u2019. - Average power: Users can select the average consuming power of the load profile in Watts. - Hours per day: Users can select the number of hours the load operates per day. - Hours of day: The time range in which the load operates. 3. Initial buying rate - Users can choose the initial energy buying rate for the beginning of each market slot in cents/kWh. 4. Final buying rate: Users can choose the final energy buying rate at the end of each market slot in cents/kWh. Users can enter a custom value or choose the Market Maker rate. 5. Rate increase - Explicit rate increase increment per update interval in cents/kWh 6. Fit to limits: If activated, a rate decrease per time is calculated, starting at initial buying rate and ending at final buying rate while updating the rate at each Update Interval. The bidding behaviour is derived from a linear fitted curve of a buying rate between initial_buying_rate and final_buying_rate within the bidding interval. If activated, energy rate_increase = (final_buying_rate - initial_buying_rate) / max(int((slot_length / update_interval) -1), 1) 7.Update interval - Users can choose the frequency at which the rate is updated. Figure 2.11 . Consumption Load Profile Advanced Configuration Options","title":"Asset Configuration Options"},{"location":"data-requirements/","text":"Users who would like to create an energy community in Grid Singularity Exchange using their own data instead of the template data need to collect the following information: Grid topology : a description of the location of energy assets and groups of the assets. Energy assets specifications : Disaggregated data (not net meter) is recommended to efficiently connect and measure performance, provided as csv files in the following upload format for each of the assets: Consumption (Load Profile) Name (can be anonymous) and location, energy consumed over the last 15 minutes by each house in kWh, and/or if houses have more granularity and have data for specific loads within a house, it is possible to either aggregate them or simulate different assets inside the house using their average power (kW) and the number of hours of use per day. PV (Solar panel) Name (can be anonymous) and location, energy produced over the last 15 minutes by each PV plant and/or peak production of PV panels in kW in order for the software to generate the Gaussian profile automatically and/or capacity in kW, including tilt and azimuth of the PV. Storage (Battery) Name (can be anonymous) and location, capacity in kWh, power delivery in kW Minimum SOC in % and/or actual SOC (sent each 15 minutes) (optional) and actual charge/discharge rate (sent each 15 minutes) (optional). Grid pricing information Feed-in structures Conventional (utility) energy price (profile) Grid tariffs (fixed value or profile). To use a custom data profile into energy assets, users can upload their own file as long as they follow the requirements. Grid Singularity Exchange currently only supports Comma Separated Values files (.csv). The separation can be done by comma , or semicolon ;. Two time formats are supported, see below. Power set-points are given in Watts . The software handles any conversions to energy (in kWh). All entered csv data values need to be positive Comma Separated Values (.csv) \u00b6 The separation can be done by comma , or semicolon ; . Two time formats are supported, see below. Power set-points are given in Watts . The software handles any conversions to energy (in kWh). All entered csv data values need to be positive hh:mm \u00b6 Example: INTERVAL;POWER(W): 00:00;10 00:15;10 00:30;10 00:45;10 01:00;10 YYYY-MM-DDThh:mm \u00b6 Example: INTERVAL,POWER(W) 2019-01-01T00:00,10.0 2019-01-01T00:15,10.0 2019-01-01T00:30,10.0 2019-01-01T00:45,10.0 2019-01-01T01:00,10.0 Note: If you upload csv files with date information, the start-date of the simulation should be identical in the csv files and simulation settings.","title":"Data Requirements and File Upload Format"},{"location":"data-requirements/#comma-separated-values-csv","text":"The separation can be done by comma , or semicolon ; . Two time formats are supported, see below. Power set-points are given in Watts . The software handles any conversions to energy (in kWh). All entered csv data values need to be positive","title":"Comma Separated Values (.csv)"},{"location":"data-requirements/#hhmm","text":"Example: INTERVAL;POWER(W): 00:00;10 00:15;10 00:30;10 00:45;10 01:00;10","title":"hh:mm"},{"location":"data-requirements/#yyyy-mm-ddthhmm","text":"Example: INTERVAL,POWER(W) 2019-01-01T00:00,10.0 2019-01-01T00:15,10.0 2019-01-01T00:30,10.0 2019-01-01T00:45,10.0 2019-01-01T01:00,10.0 Note: If you upload csv files with date information, the start-date of the simulation should be identical in the csv files and simulation settings.","title":"YYYY-MM-DDThh:mm"},{"location":"default-trading-strategy/","text":"Grid Singularity\u2019s exchange engine has a built-in template trading agent. The agent\u2019s trading strategy is deterministic . Each consumer asset will first try to buy energy at a low price and, if not cleared, the price will increase linearly during the market slot until a user-defined maximum is reached. In turn, assets generating energy will try to sell at a high price first and, if not cleared, reduce their rate linearly until a user-set minimum is reached. Offers\u2019 trading settings are as follows: initial_selling_rate final_selling_rate update_interval energy_rate_decrease_per_update fit_to_limit The following plot shows the changing energy rate in a spot market slot (slot_length = 15min) for four different trading settings. Figure 3.13 . Four different generation trading settings in a spot market slot (slot_length = 15 min). If fit_to_limit is set to True , energy_rate_decrease_per_update is ignored and a rate decrease per time is calculated, starting at initial_selling_rate and ending at final_selling_rate while updating the rate at each update_interval . Bids\u2019 Trading settings: initial_buying_rate final_buying_rate update_interval energy_rate_increase_per_update fit_to_limit The following plot shows the energy rate change in a spot market slot (slot_length = 15min) for different trading settings. If fit_to_limit is set to True , energy_rate_increase_per_update is ignored and a rate increase per time is calculated that starts at initial_buying_rate and ends at final_buying_rate while updating the rate at each update_interval . Figure 3.14 . Four different load trading settings in a spot market slot (slot_length = 15 min). Assets can also deploy more intelligent trading strategies, as demonstrated in the 2020 Energy Singularity Challenge, described in the following two articles: Grid Singularity. (September 10, 2020). En Route to Energy Singularity Odyssey Momentum: Learnings from the 2020 Chaos Experiment Grid Singularity. (November 25, 2020). Energy Singularity Challenge 2020: Social Energy Networks Information on how to set up and train intelligent trading strategies through the Grid Singularity Asset API is available here .","title":"Trading Strategies"},{"location":"degrees-of-freedom/","text":"Through the Grid Singularity Exchange, and as permitted by local legislation, users can enjoy enhanced degrees of freedom , or choices to trade or share energy based on a set of preferences , such as energy quantity, price, source or preferred trading partner. The degrees of freedom are a key functionality of the Symbiotic Energy Market , a future decentralised market design we aim to enable to the extent that legislation in relevant markets allows people to have more energy choices. A user might be interested to set trading preferences in order to prioritise consumption of green energy (i.e. solar, wind) over grey energy (i.e. coal) or in order to buy or sell energy directly to a friend or family member, for example. The bids and offers for an energy asset include a set of attributes and requirements that reflect its owner\u2019s trading preferences. Attributes are parameters currently supported only for offers, that describe the energy type of the offer posted, which is commonly associated with the energy source (e.g. PV, Wind, Hydro, Biomass, etc\u2026). On the other hand, requirements are parameters associated with both bids and offers, and represent the trading preferences of the users. The currently supported requirements are the following: Offers: Preferred trading partners: community participants the users wish to sell energy to; Bids: Preferred trading partners: community participants the users wish to buy energy from; Energy type: the energy source that the user prefers to consume (e.g. PV, Wind, Hydro, Biomass, etc.) Energy: the maximum amount of energy that the user is willing to consume; Price: the maximum price for energy that the user is willing to pay. Naturally, attributes and requirements can be aggregated/grouped in different combinations to express customised trading preferences. Below is an example of a bid and offer with attributes and requirements (figure 3.22). The bid submits three sets of conditions that must be interpreted as OR statements, i.e. each condition must be assessed individually and each requirement of the condition must be fulfilled. In this example, the Consumer desires to buy up to 1.0 kWh from their Mom for a maximum of 28 cents OR up to 1.0 kWh of solar energy for a maximum of 25 cents OR up to 0.5 kWh of energy from any source for a maximum of 20 cents. The Producer has 0.8 kWh of solar energy to sell for no less than 21 cents. In this case, the second condition is fulfilled by the offer, thus the two orders are successfully matched: - The energy source (solar) is the same in the bid and the offer; - The energy to be traded results in 0.8 kWh; - The trading price can range between 21 and 25 cents and will be determined by the matching algorithm in place. Figure 3.22 . Example of a bid and offer with attributes and requirements. Matching algorithms parse the orderbook and submit proposed bid and offer matches to the Grid Singularity Exchange through the Matching API . A verification function, integrated into the exchange code, confirms that the attributes of the proposed bid and offer match satisfies each other\u2019s respective requirements. The verification function accepts a bid / offer pair as input and, if the requirements are met, a trade is created. Otherwise, the trade is rejected. Multi-attributed bids and offers are submitted through Grid Singularity\u2019s existing Asset API . For more information on how to add attributes and requirements to bids and offers by using the Asset API, please follow this link .","title":"Degrees of Freedom"},{"location":"development-path/","text":"Grid Singularity Exchange is built as an open source GPL v.3 codebase with an interactive interface to simulate and operate interconnected, grid-aware energy marketplaces. The future market design implementation, termed Symbiotic Energy Markets, combines multi-attribute double-sided auctions, graph representations of the energy grid and the decentralised computation and verification enabled by blockchain. In the envisaged consumer-centric market design, spot, futures, settlement, and balancing markets are intertwined through the use of time slots, allowing market-driven pricing and accurate accounting of delivered energy. Individuals can optimise for their own multi-attribute objectives (e.g. green energy source, reduced energy bill, preferred trading partner) through degrees of freedom in the multi-attribute double auction with dynamic pricing. The grid is represented as a weighted graph, offering grid operators efficient management tools and allowing energy communities to interconnect and trade. The complexity of the matching algorithm is decoupled from the verification of transactions, with matching facilitated by third party matching algorithm providers, termed \u201cmycos\u201d, enabling the exchange itself to operate on a blockchain. New energy market participants are rewarded for providing valuable services such as data and algorithms, while the roles of established market participants (aggregators, grid operators, utilities, and regulators) converge towards the individual and the community. Figure 1.1 : Information flow between aggregator, Grid Singularity exchange and matching algorithm provider (to be sourced through Data and Algorithm Marketplace). IPFS or RDBMS will likely be used for off-chain storage of the order book. The matching algorithms will be run off-chain or in an instance of SubstraTEE. The Grid Singularity Exchange will operate as a pallet on a Substrate-based parachain or another network that provides the best security and privacy combined with execution efficiency. Grid Singularity is implementing Symbiotic Energy Markets in stages, adding or adapting modules to its codebase to take advantage of advancements in blockchain technology, increasing regulatory interest to enable bottom-up markets and the proliferation of connected energy resources. We rely on open source innovation and ecosystem collaboration to develop an inclusive, efficient, accountable and secure energy exchange: Inclusive to all stakeholders, providing barrier-free access for all market actors (established and new) including individuals and their communities, grid operators and utilities, trading algorithm providers, aggregators/energy management service providers, regulators, as well as diverse energy assets; to any individual choice, allowing participants to trade and interact with energy based on their personal preferences on a wide choice of attributes. Efficient physically, that the system accurately represents the grid topology and meets its feasibility requirements , ensuring supply-demand equilibrium to manage critical infrastructure including balancing services; environmentally, prioritising local trading and sustainable energy sources, and enables market transformation to meet the UN Sustainable Development Goals of affordable and clean energy and responsible production and consumption ; economically, [striving for advantageous market prices], a high rate of self-consumption, individual rationality , incentive compatibility and a large amount of energy traded yielding high self-sufficiency and liquidity. Accountable for settlement of energy usage (consumption and generation) and financial responsibility, providing confidentiality of personal data while delivering transparency of the auction process; for audit of transaction records by regulators without relying on a trusted third party and nudge consumers to become more active players ; Scalable technically, structured modularly and without matching and arbitration turning into a computational burden for scenarios with many participants; organisationally, allowing democratic deliberation and decisions on system upgrades; Secure to enable privacy, preserving the confidentiality of personal data and authorising its access on demand; against malicious activity, protecting the integrity of the market while enhancing communication security in the network. Our market design discussion paper explores how defined market requirements translate to the following functional capabilities, outlining the path forward to the deployment of the Symbiotic Energy Markets concept: Validated market participation and asset ownership, Degrees of freedom (choice of energy source, trading partner, etc.) with multi-attribute bids and offers, Matching and arbitration by third party algorithm providers that can be fully decentralised, A time-slot mechanism that allows for spot, futures, settlement (post-delivery) and balancing trading, An accurate grid topology representation that takes into account physical constraints and is scalable, Dynamic grid fees that allow grid operators to manage physical grid constraints, A blockchain implementation for verification and storage of transactions and the grid topology in a deployed network, with decentralised blockchain architecture to allow deliberation and decisions on system changes, Privacy and security considerations for the protection of sensitive user data, A data and algorithm marketplace to inform and optimise market participation, and Interoperable architecture to integrate existing and new business models, leading to a transformation of energy market roles.","title":"Grid Singularity Development Path"},{"location":"documentation/","text":"Grid Singularity is an awarded , open source energy technology startup, placing the individual and the environment at the centre of the energy market by developing the Grid Singularity Exchange and co-founding the Energy Web Foundation (EWF) . Grid Singularity simulates and operates interconnected grid-aware energy marketplaces enabling the utmost degrees of freedom in trading for any market participant. Our co-founders are seasoned energy market professionals and blockchain pioneers, who engaged a talented and diverse team of energy design thinkers and developers, guided by the following principles: Grid Singularity\u2019s mission is to build a sustainable, inclusive and democratic energy market that facilitates the ultimate degrees of freedom for the individual and the energy communities, allowing you to consume, trade or share energy based on your preferences of an energy type, location source, price or trading partner. You are energy. The European Union and other regulators are also supporting a bottom-up, user-centric market design, recognizing its diverse benefits: Grid Singularity facilitates a bottom-up market design by connecting aggregators, which in turn connect households and distributed energy assets digitally represented by trading agents, and grid operators through an application interface ( Grid Operator API and Asset API ). Economic, by incentivising prosumership and local generation and consumption which is cheaper than buying/selling energy directly from the grid while taking into account a wider range of individual preferences; Environmental, optimising the use of green energy supply by fostering collective self-consumption and increased investment in local renewable production; Social, promoting the creation of social energy networks by enabling energy exchange within a community and/or to support local initiatives, advancing community engagement and social inclusion. Modelling simulation studies carried out by Grid Singularity and German and Dutch energy communities and utilities using real-world data have revealed that the activation of local energy markets via Grid Singularity Exchange can increase community self-sufficiency and self-consumption by 7.7% and 5.7%, respectively, and reduce energy bills by around 21% , which could be reinvested in additional storage or other distributed energy assets (DERs). Grid operators can benefit from Grid Singularity Exchange to reduce peak loading and congestion by purchasing grid balancing services and levying flexible grid fees . The initial simulation experiments undertaken by Grid Singularity and German and Dutch energy grid operators revealed 10% reductions in peak loading and congestion, expected to improve with innovation in trading algorithms and grid tariff models.","title":"Grid Singularity Mission"},{"location":"duplicating-simulations/","text":"Any user can duplicate public simulations, in order to run different scenarios and compare or make changes to an existing simulation without losing the original configuration. To duplicate a simulation, click the three dots and select \u2018Duplicate\u2019. This will open the duplicate version of the simulation for editing. Figure 2.30 . Duplicate a simulation.","title":"Duplicating simulations"},{"location":"energy-bills/","text":"The cumulative energy bills for each market and energy asset are reported on the UI Results page and in a JSON file bills.json for a backend simulation. The bills are reported as the cash flow through each market. For a visual example, the following configuration will be used: This configuration is simulated for one day using the Pay-as-Bid market type and the load bidding to buy energy at 12:00, leading to the propagation of the load bid and the grid operator offer until they are matched as shown in the figure below: The bid and the offer are forwarded to the higher-level Grid market and are matched in this market with a clearing price (and trade price) of 0.45 \u20ac. For more information on how grid fees are calculated, please read the grid fees documentation ). In the bills.json file, the cash flow in each market is reported as follows: \"Parent market\": { \"Agent\": { \"bought\": Energy that has been bought during the simulation [kWh], \"sold\": Energy that has been sold during the simulation [kWh], \"spent\": Amount of money that has been spent in trades during the simulation [\u20ac] , \"earned\": Amount of money that has been earned in trades during the simulation [\u20ac], \"total_energy\": energy bought - energy sold [kWh], \"total_cost\": money spent in trades - money earned in trades [\u20ac], \"market_fee\": Money spent in the \"Parent area\" as grid fees [\u20ac] , \"type\": Type of agent. Can either be a market or the name of the asset strategy }, }, Shown below are the results of the previous example. The first set of results is from the highest market, in this case the Grid market : In the Grid market, House 1 has bought 1 kWh from the DSO and spent 0.375\u20ac in this trade. House 1 also pays the 0.075\u20ac grid fee that the Grid market is charging. The total cost of 1 kWh of energy is 0.375 + 0.075 = 0.45\u20ac One level down the hierarchy, the House 1 market is displayed in the figure below: The House 1 market has no information on the other markets\u2019 grid fees, so only considers its own fees in the bills table. Therefore, the Load spends 0.45\u20ac (0.0375+0.075) for 1 kWh of energy coming outside of House 1, with no grid fee added since House 1 has no fees. Finally, the bills of each energy asset is shown : The Load has bought 1 kWh of energy for 0.45\u20ac. Since 0.075\u20ac was paid as fees to the Grid market, the DSO received the remaining 0.375\u20ac for 1 kWh.","title":"Energy bills"},{"location":"events/","text":"This feature is currently only available in our previous interface (d3a.io) and it will soon be available in the new interface, when this documentation will be updated. Users have the ability to modify the modelling setup while the simulated network is running. These modifications are termed events . To create an event the user can either go to the ''Modelling'' page and make a change while the simulation is running or pause the simulation beforehand (by clicking pause on the Results page), resuming once changes are implemented. Possible events are : Add or delete markets and energy assets Change parameters of energy assets (with the exception of their names and the Market Maker) Change market configuration settings (except names) Events in Simulations run using the User Interface \u00b6 Once an event is set, the user can track it on the timeline displayed at the top of the simulation. If the user clicks on the event on the Modelling page, the grid setup at that specific time is viewed. If the user clicks on an event in the Results page, the results of the specific markets and energy assets are viewed. whenever a market or energy asset was added whenever a market or energy asset parameter was modified whenever a market or energy asset was removed whenever multiple events have been executed at the same time Events in Simulations run using the Backend \u00b6 In a backend simulation, events need to be defined by the user in the setup files before the start of the simulation, and they are associated with a specific point in time (or duration), at which the event is triggered. An event has to be associated with a market by using the event_list constructor parameter for that market. There are four different event types, described in further detail below: Add/Remove Market Events Connect/Disconnect Market Events Strategy Events Configuration Events Add/Remove Market Events \u00b6 This event is associated with a market, and dictates that this market (and its submarkets and assets) will be added or removed from the grid at a specific point in time. There are two ways to configure this operation, either via individual events ( EnableMarketEvent and DisableMarketEvent ) or by disabling this market for a time interval ( DisableIntervalMarketEvent ). EnableMarketEvent / DisableMarketEvent commands each accept one argument, which is the hour at which this event is triggered (hourly resolution is supported in the current implementation), and this area will be enabled/disabled at this specific point in time no matter its current state. DisableIntervalMarketEvent accepts two arguments, denoting the start hour and the end hour at which the Market is disabled. The term disabled market means that the relevant markets and submarkets are not performing any trading, and are hence inactive in the simulation for the time that the market is disabled. Once enabled, the relevant market and its submarkets will start to operate. Examples for these events are available on the Grid Singularity GitHub: EnableMarketEvent: isolated_enable_event.py DisableMarketEvent: isolated_disable_event.py DisableIntervalMarketEvent: disable_interval_event.py Connect/Disconnect Market Events \u00b6 These events are similar to the enable/disable event; both have a similar API and both are used for removing a market from the grid. The difference is that the Connect/Disconnect events are decoupling the relevant submarkets and assets from the main grid. When the event is enabled, there will be two independent grids trading energy internally, but not with each other. This is contrary to enable/disable events, where the subtree is not performing any trades. This can simulate grids that are abruptly decoupled from the main grid, but manage to self-sustain their assets by continuing to trade energy even after they are disconnected from the main grid. You can find examples for these events on Grid Singularity GitHub: ConnectMarketEvent: isolated_connect_event.py DisconnectMarketEvent: isolated_disconnect_event.py DisconnectIntervalMarketEvent: disconnect_interval_event.py Strategy Events \u00b6 These events are used to change an asset\u2019s trading strategy during the simulation runtime. These are distinct events with no interval event provided. Load StrategyEvent: load_event.py PV StrategyEvent: pv_event.py Storage StrategyEvent: storage_event.py Configuration Events \u00b6 These events are used to change the market configuration (including submarkets and assets) during runtime. A useful application for this event is to set different weather conditions for a subset of the grid. Configuration events are distinct and no interval event is provided. There are currently two configuration events: Cloud Coverage Event: cloud_coverage_event.py PV User Profile Event : userprofile_pv_event.py","title":"Events (Adding Assets, Communities, etc.)"},{"location":"events/#events-in-simulations-run-using-the-user-interface","text":"Once an event is set, the user can track it on the timeline displayed at the top of the simulation. If the user clicks on the event on the Modelling page, the grid setup at that specific time is viewed. If the user clicks on an event in the Results page, the results of the specific markets and energy assets are viewed. whenever a market or energy asset was added whenever a market or energy asset parameter was modified whenever a market or energy asset was removed whenever multiple events have been executed at the same time","title":"Events in Simulations run using the User Interface"},{"location":"events/#events-in-simulations-run-using-the-backend","text":"In a backend simulation, events need to be defined by the user in the setup files before the start of the simulation, and they are associated with a specific point in time (or duration), at which the event is triggered. An event has to be associated with a market by using the event_list constructor parameter for that market. There are four different event types, described in further detail below: Add/Remove Market Events Connect/Disconnect Market Events Strategy Events Configuration Events","title":"Events in Simulations run using the Backend"},{"location":"events/#addremove-market-events","text":"This event is associated with a market, and dictates that this market (and its submarkets and assets) will be added or removed from the grid at a specific point in time. There are two ways to configure this operation, either via individual events ( EnableMarketEvent and DisableMarketEvent ) or by disabling this market for a time interval ( DisableIntervalMarketEvent ). EnableMarketEvent / DisableMarketEvent commands each accept one argument, which is the hour at which this event is triggered (hourly resolution is supported in the current implementation), and this area will be enabled/disabled at this specific point in time no matter its current state. DisableIntervalMarketEvent accepts two arguments, denoting the start hour and the end hour at which the Market is disabled. The term disabled market means that the relevant markets and submarkets are not performing any trading, and are hence inactive in the simulation for the time that the market is disabled. Once enabled, the relevant market and its submarkets will start to operate. Examples for these events are available on the Grid Singularity GitHub: EnableMarketEvent: isolated_enable_event.py DisableMarketEvent: isolated_disable_event.py DisableIntervalMarketEvent: disable_interval_event.py","title":"Add/Remove Market Events"},{"location":"events/#connectdisconnect-market-events","text":"These events are similar to the enable/disable event; both have a similar API and both are used for removing a market from the grid. The difference is that the Connect/Disconnect events are decoupling the relevant submarkets and assets from the main grid. When the event is enabled, there will be two independent grids trading energy internally, but not with each other. This is contrary to enable/disable events, where the subtree is not performing any trades. This can simulate grids that are abruptly decoupled from the main grid, but manage to self-sustain their assets by continuing to trade energy even after they are disconnected from the main grid. You can find examples for these events on Grid Singularity GitHub: ConnectMarketEvent: isolated_connect_event.py DisconnectMarketEvent: isolated_disconnect_event.py DisconnectIntervalMarketEvent: disconnect_interval_event.py","title":"Connect/Disconnect Market Events"},{"location":"events/#strategy-events","text":"These events are used to change an asset\u2019s trading strategy during the simulation runtime. These are distinct events with no interval event provided. Load StrategyEvent: load_event.py PV StrategyEvent: pv_event.py Storage StrategyEvent: storage_event.py","title":"Strategy Events"},{"location":"events/#configuration-events","text":"These events are used to change the market configuration (including submarkets and assets) during runtime. A useful application for this event is to set different weather conditions for a subset of the grid. Configuration events are distinct and no interval event is provided. There are currently two configuration events: Cloud Coverage Event: cloud_coverage_event.py PV User Profile Event : userprofile_pv_event.py","title":"Configuration Events"},{"location":"general-settings/","text":"Grid Singularity exchange engine can be used to simulate, collaborate and optimize grid-aware local energy markets (LEMs). The simulation tool is freely available through our User Interface (UI) at map.gridsingularity and our backend codebase is open source under GNU general public license . This section will focus on a step-by-step guide to create and simulate LEMs using our software, starting with an explanation and guide for the UI, followed by a more technical tutorial to reproduce in the backend. User-Interface Simulation Configuration \u00b6 When creating a new simulation, simulation collaboration or a simulation in the Canary Test Network, the user needs to define the following general settings: Simulation name : Please provide a unique name. Description : Description of the simulation (optional but encouraged to clarify the intent of the simulation). Project : The user can select a project folder where the simulation is saved. Start date : Simulation start date (please make sure that the date-stamp of any uploaded data coincides with the defined start and end date). End date : Simulation end date. The user can simulate up to 7 days of LEM trading. Solar profile : Sets a template production curve for all photovoltaics (PVs) without custom production curves. Select one the following possible configurations: Sunny (generation profile with 250W panel) Cloudy (generation profile with 250W panel) Partially Cloudy (generation profile with 250W panel) Gaussian (the user can define the panel power output) Upload a profile (a custom default PV production curve can be uploaded as described in Upload File Formats ) Spot market type : The user can select one of three market types: One-sided pay-as-offer , Two-sided pay-as-bid and Two-sided pay-as-clear . Number of spot markets : Number of future spot markets where the energy assets and agents can trade. Duration of market slot : Duration of each spot market,between 2 and 60 minutes. Default is set to 15 minutes. Tick duration : Amount of time between two increments of each market slot when trades are cleared or agent trading rates are updated. Default duration is 15 simulated seconds, yielding 60 ticks per market slot. Grid Fees : The user can select one of two types: Constant grid fee or Percentage grid fee The interface for selecting general settings is shown below: Once the general settings of the simulation are defined, the user can move to the modelling page and set up the grid architecture by adding Markets and Energy Assets. Each market or energy asset is considered as 1 node . At the moment, up to 1000 nodes can be configured. Markets contain a spot market where all connected energy assets, submarkets and parent markets trade energy. Markets can potentially house multiple submarkets of different market types, and this feature will be available in the future version of our software. After adding the first market the user has to select a Market Maker rate. Subsequently, the user can model the simulation by configuring multiple submarkets and energy assets in a hierarchical electrical grid. Once the modelling is completed, the user goes to the Results page to initiate the simulation and view results. Backend Simulation Configuration \u00b6 In the backend, the simulation process is slightly different. There is no need to login to set up a simulation. The user first needs to download the code from our Github Repository (Installation Instructions for Linux , Mac and Windows ). In the setup-file (in Python programming language), general and trading strategy settings can be defined. Examples can be found in the relevant Grid Singularity GitHub folder. This is the most basic skeleton for a setup-file: ```python from gsy_e.models.area import Area def get_setup(config): area = Area('Grid', []) return area The user can add more nested submarkets recursively by adding more instances of Area to the second parameter (list) of the Area class. If the strategy parameter is set in the Area class, the area is converted to a leaf node, e.g. a load. The following grid architecture is given: Grid House 1 H1 General Load H1 Storage 1 H1 Storage 2 House 2 H2 General Load Bold instances in the outline above are markets ( Area component). For each of these markets, an inter-area-agent is created in the background to execute offer/bid forwarding and matching. In the following, the corresponding setup-file is shown. ```python from gsy_e.models.area import Area from d3a.models.strategy.storage import StorageStrategy from gsy_e.models.strategy.load_hours import LoadHoursStrategy from d3a.models.strategy.pv import PVStrategy def get_setup(config): area = Area( 'Grid', [ Area( 'House 1', [ Area('H1 General Load', strategy=LoadHoursStrategy(avg_power_W=200, hrs_per_day=6, hrs_of_day=list( range(12, 18)), final_buying_rate=35) ), Area('H1 Storage1', strategy=StorageStrategy(initial_soc=50) ), Area('H1 Storage2', strategy=StorageStrategy(initial_soc=50) ), ], grid_fee_pct=0, grid_fee_const=0, ), Area( 'House 2', [ Area('H2 General Load', strategy=LoadHoursStrategy(avg_power_W=200, hrs_per_day=4, hrs_of_day=list( range(12, 16)), final_buying_rate=35) ), Area('H2 PV', strategy=PVStrategy(panel_count=4, initial_selling_rate=30, final_selling_rate=5) ), ], grid_fee_pct=0, grid_fee_const=0, ), ], config=config ) return area Additionally the user has the possibility to change the default general settings in two different ways: Setup file (best option) d3a-setting.json setup-file (best option): \u00b6 For a description of each grid component please see the Modelling section. The user can overwrite the configuration settings by changing variables of the ConstSettings class in the setup-file. This class defines the default values for various parameters (general simulation settings, market settings and energy asset configuration). For instance, the user can define multiple configuration parameters in the get_setup function by overwriting the ConstSettings default values. For example, the following parameters can be set : Market_type (if equal to 1: One-Sided Pay-as-Offer , if equal to 2 : Two-Sided Pay-as-Bid , if equal to 3 : Two-Sided Pay-as-Clear ) Grid_fee_type (if equal to 1: Constant grid fee , if equal to 2 : Percentage grid fee ) Here is an example to setup a simulation with the Two-Sided Pay-as-Bid market type, constant grid fee and default min (0cts/kWh) and max to (35cts/kWh) energy rate for all loads : from gsy_framework.constants_limits import ConstSettings def get_setup(config): ConstSettings.MASettings.MARKET_TYPE = 2 ConstSettings.LoadSettings.MIN_ENERGY_RATE = 0 ConstSettings.LoadSettings.MAX_ENERGY_RATE = 35 ConstSettings.MASettings.GRID_FEE_TYPE = 1 d3a-settings.json \u00b6 These general settings can also be parsed via a settings file in JSON format, which contains all constants in the advanced_settings branch. An example can be found here: src/d3a/setup/d3a-settings.json The settings JSON file can be parsed via the --settings-file keyword Setting General Configuration Parameters \u00b6 The following parameters are part of Simulation Config and are initialised before updating any ConstSettings : sim_duration slot_length tick_length cloud_coverage* market_maker_rate* grid_fee_pct* grid_fee_const* pv_user_profile* max_panel_power_W In order to update some of these parameters (starred in list above), please use update_config_parameters method to update the general configuration parameters in the setup file: def get_setup(config): config.update_config_parameters(grid_fee_pct=5, grid_fee_const=35, cloud_coverage=2, pv_user_profile=\"<path>/<profile_name>\", market_maker_rate=30) area = Area( 'Grid', [ Area('General Load', strategy=LoadHoursStrategy(avg_power_W=200, hrs_per_day=4, hrs_of_day=list(range(12, 16)), final_buying_rate=35) ), Area('PV', strategy=PVStrategy(4, 80) ), ], config=config ) return area Simulation launch \u00b6 Once the entire grid architecture is modelled, including energy assets, the user can launch the trading simulation by running a command line including desired setup features: -d, --duration: simulated duration of simulation [default: 1d] -t, --tick-length: simulated duration of a tick [default: 1s] -s, --slot-length: simulated duration of a market slot [default: 15m] -c, --cloud-coverage: Cloud coverage, 0 for sunny, 1 for partial coverage, 2 for clouds. [default: 0] --slot-length-realtime: Desired duration of slot in realtime [default: 0s] Example simulation call: d3a -l ERROR run --duration=1d --tick-length=1s --slot-length=15m --cloud-coverage=0 --setup default_2a Getting help in the command line: d3a --help returns: Usage: d3a [OPTIONS] COMMAND [ARGS]... Options: -l, --log-level [CRITICAL|FATAL|ERROR|WARN|WARNING|INFO|DEBUG|NOTSET|TRACE] Log level [default: INFO] --help Show this message and exit. Commands: run* resume d3a run --help returns: Usage: d3a run [OPTIONS] Options: -d, --duration INTERVAL Duration of simulation [default: 1d] -t, --tick-length INTERVAL Length of a tick [default: 1s] -s, --slot-length INTERVAL Length of a market slot [default: 15m] --slot-length-realtime INTERVAL Desired duration of slot in realtime [default: 0s] -c, --cloud-coverage INTEGER Cloud coverage, 0 for sunny, 1 for partial coverage, 2 for clouds. [default: 0] --setup TEXT Simulation setup module use. Available modules: [1000_houses, market_events.cloud_coverage_event, market_events.disable_interval_event, market_events.disconnect_interval_event, market_events.isolated_connect_event, market_events.isolated_disable_event, market_events.isolated_disconnect_event, market_events.isolated_enable_event, market_events.load_event, market_events.pv_event, market_events.storage_event, balancing_market.default_2a, balancing_market.one_load_one_pv, balancing_market.one_load_one_storage, balancing_market.one_storage_one_pv, balancing_market.test_asset_registry, balancing_market.two_sided_one_load_one_pv, config_parameter_test, default_2, default_2a, default_2b, default_3, default_3_pv_only, default_3a, default_3b, default_4, default_5, default_addcurve, default_addcurve2, default_csv, graphs_testing, jira.d3asim_1024, jira.d3asim_1139, jira.d3asim_638_custom_load, jira.d3asim_639_custom_storage, jira.d3asim_640_custom_pv, jira.d3asim_778, jira.d3asim_780, jira.d3asim_869, jira.d3asim_871, jira.d3asim_895, jira.d3asim_895_pr1, jira.d3asim_895_pr2, jira.d3asim_895_pr3, jira.d3asim_962, jira.default_2off_d3asim_1475, jira.default_595, jira.default_611, jira.default_613, jira.default_623, jira.default_645, jira.default_737, jira.test_strategy_custom_load, jira.test_strategy_custom_pv, jira.test_strategy_custom_storage, json_arg, json_file, non_compounded_grid_fees, redis_communication_default_2a, sam_config, sam_config_const_load, sam_config_small, strategy_tests.commercial_producer_market_maker_rate, strategy_tests.ess_capacity_based_sell_offer, strategy_tests.ess_sell_offer_decrease_based_on_risk_or_rate, strategy_tests.finite_power_plant, strategy_tests.finite_power_plant_profile, strategy_tests.home_cp_ess_load, strategy_tests.home_hybrid_pv_ess_load, strategy_tests.infinite_bus, strategy_tests.predefined_pv_test, strategy_tests.pv_const_price_decrease, strategy_tests.pv_final_selling_rate, strategy_tests.pv_initial_pv_rate_option, strategy_tests.pv_max_panel_output, strategy_tests.pv_max_panel_power_global, strategy_tests.pv_risk_based_price_decrease, strategy_tests.storage_buys_and_offers, strategy_tests.storage_strategy_break_even_hourly, strategy_tests.user_profile_load_csv, strategy_tests.user_profile_load_csv_multiday, strategy_tests.user_profile_load_dict, strategy_tests.user_profile_pv_csv, strategy_tests.user_profile_pv_dict, strategy_tests.user_profile_wind_csv, strategy_tests.user_rate_profile_load_dict, tobalaba.one_producer_load, two_sided_market.default_2a, two_sided_market.infinite_bus, two_sided_market.offer_reposted_at_old_offer_rate, two_sided_market.one_cep_one_load, two_sided_market.one_load_5_pv_partial, two_sided_market.one_load_one_storage, two_sided_market.one_pv_one_load, two_sided_market.one_pv_one_storage, two_sided_market.one_storage_5_pv_partial, two_sided_market.user_min_rate_profile_load_dict, two_sided_market.with_balancing_market, two_sided_pay_as_clear.default_2a, two_sided_pay_as_clear.test_clearing_energy] -g, --settings-file TEXT Settings file path --seed TEXT Manually specify random seed --paused Start simulation in paused state [default: False] --pause-at TEXT Automatically pause at a certain time. Accepted Input formats: (YYYY-MM-DD, HH:mm) [default: disabled] --repl / --no-repl Start REPL after simulation run. [default: False] --no-export Skip export of simulation data --export-path TEXT Specify a path for the csv export files (default: ~/d3a-simulation) --enable-bc Run simulation on Blockchain --start-date DATE Start date of the Simulation (YYYY-MM-DD) [default: 2019-09-27] --help Show this message and exit.","title":"General settings"},{"location":"general-settings/#user-interface-simulation-configuration","text":"When creating a new simulation, simulation collaboration or a simulation in the Canary Test Network, the user needs to define the following general settings: Simulation name : Please provide a unique name. Description : Description of the simulation (optional but encouraged to clarify the intent of the simulation). Project : The user can select a project folder where the simulation is saved. Start date : Simulation start date (please make sure that the date-stamp of any uploaded data coincides with the defined start and end date). End date : Simulation end date. The user can simulate up to 7 days of LEM trading. Solar profile : Sets a template production curve for all photovoltaics (PVs) without custom production curves. Select one the following possible configurations: Sunny (generation profile with 250W panel) Cloudy (generation profile with 250W panel) Partially Cloudy (generation profile with 250W panel) Gaussian (the user can define the panel power output) Upload a profile (a custom default PV production curve can be uploaded as described in Upload File Formats ) Spot market type : The user can select one of three market types: One-sided pay-as-offer , Two-sided pay-as-bid and Two-sided pay-as-clear . Number of spot markets : Number of future spot markets where the energy assets and agents can trade. Duration of market slot : Duration of each spot market,between 2 and 60 minutes. Default is set to 15 minutes. Tick duration : Amount of time between two increments of each market slot when trades are cleared or agent trading rates are updated. Default duration is 15 simulated seconds, yielding 60 ticks per market slot. Grid Fees : The user can select one of two types: Constant grid fee or Percentage grid fee The interface for selecting general settings is shown below: Once the general settings of the simulation are defined, the user can move to the modelling page and set up the grid architecture by adding Markets and Energy Assets. Each market or energy asset is considered as 1 node . At the moment, up to 1000 nodes can be configured. Markets contain a spot market where all connected energy assets, submarkets and parent markets trade energy. Markets can potentially house multiple submarkets of different market types, and this feature will be available in the future version of our software. After adding the first market the user has to select a Market Maker rate. Subsequently, the user can model the simulation by configuring multiple submarkets and energy assets in a hierarchical electrical grid. Once the modelling is completed, the user goes to the Results page to initiate the simulation and view results.","title":"User-Interface Simulation Configuration"},{"location":"general-settings/#backend-simulation-configuration","text":"In the backend, the simulation process is slightly different. There is no need to login to set up a simulation. The user first needs to download the code from our Github Repository (Installation Instructions for Linux , Mac and Windows ). In the setup-file (in Python programming language), general and trading strategy settings can be defined. Examples can be found in the relevant Grid Singularity GitHub folder. This is the most basic skeleton for a setup-file: ```python from gsy_e.models.area import Area def get_setup(config): area = Area('Grid', []) return area The user can add more nested submarkets recursively by adding more instances of Area to the second parameter (list) of the Area class. If the strategy parameter is set in the Area class, the area is converted to a leaf node, e.g. a load. The following grid architecture is given: Grid House 1 H1 General Load H1 Storage 1 H1 Storage 2 House 2 H2 General Load Bold instances in the outline above are markets ( Area component). For each of these markets, an inter-area-agent is created in the background to execute offer/bid forwarding and matching. In the following, the corresponding setup-file is shown. ```python from gsy_e.models.area import Area from d3a.models.strategy.storage import StorageStrategy from gsy_e.models.strategy.load_hours import LoadHoursStrategy from d3a.models.strategy.pv import PVStrategy def get_setup(config): area = Area( 'Grid', [ Area( 'House 1', [ Area('H1 General Load', strategy=LoadHoursStrategy(avg_power_W=200, hrs_per_day=6, hrs_of_day=list( range(12, 18)), final_buying_rate=35) ), Area('H1 Storage1', strategy=StorageStrategy(initial_soc=50) ), Area('H1 Storage2', strategy=StorageStrategy(initial_soc=50) ), ], grid_fee_pct=0, grid_fee_const=0, ), Area( 'House 2', [ Area('H2 General Load', strategy=LoadHoursStrategy(avg_power_W=200, hrs_per_day=4, hrs_of_day=list( range(12, 16)), final_buying_rate=35) ), Area('H2 PV', strategy=PVStrategy(panel_count=4, initial_selling_rate=30, final_selling_rate=5) ), ], grid_fee_pct=0, grid_fee_const=0, ), ], config=config ) return area Additionally the user has the possibility to change the default general settings in two different ways: Setup file (best option) d3a-setting.json","title":"Backend Simulation Configuration"},{"location":"general-settings/#setup-file-best-option","text":"For a description of each grid component please see the Modelling section. The user can overwrite the configuration settings by changing variables of the ConstSettings class in the setup-file. This class defines the default values for various parameters (general simulation settings, market settings and energy asset configuration). For instance, the user can define multiple configuration parameters in the get_setup function by overwriting the ConstSettings default values. For example, the following parameters can be set : Market_type (if equal to 1: One-Sided Pay-as-Offer , if equal to 2 : Two-Sided Pay-as-Bid , if equal to 3 : Two-Sided Pay-as-Clear ) Grid_fee_type (if equal to 1: Constant grid fee , if equal to 2 : Percentage grid fee ) Here is an example to setup a simulation with the Two-Sided Pay-as-Bid market type, constant grid fee and default min (0cts/kWh) and max to (35cts/kWh) energy rate for all loads : from gsy_framework.constants_limits import ConstSettings def get_setup(config): ConstSettings.MASettings.MARKET_TYPE = 2 ConstSettings.LoadSettings.MIN_ENERGY_RATE = 0 ConstSettings.LoadSettings.MAX_ENERGY_RATE = 35 ConstSettings.MASettings.GRID_FEE_TYPE = 1","title":"setup-file (best option):"},{"location":"general-settings/#d3a-settingsjson","text":"These general settings can also be parsed via a settings file in JSON format, which contains all constants in the advanced_settings branch. An example can be found here: src/d3a/setup/d3a-settings.json The settings JSON file can be parsed via the --settings-file keyword","title":"d3a-settings.json"},{"location":"general-settings/#setting-general-configuration-parameters","text":"The following parameters are part of Simulation Config and are initialised before updating any ConstSettings : sim_duration slot_length tick_length cloud_coverage* market_maker_rate* grid_fee_pct* grid_fee_const* pv_user_profile* max_panel_power_W In order to update some of these parameters (starred in list above), please use update_config_parameters method to update the general configuration parameters in the setup file: def get_setup(config): config.update_config_parameters(grid_fee_pct=5, grid_fee_const=35, cloud_coverage=2, pv_user_profile=\"<path>/<profile_name>\", market_maker_rate=30) area = Area( 'Grid', [ Area('General Load', strategy=LoadHoursStrategy(avg_power_W=200, hrs_per_day=4, hrs_of_day=list(range(12, 16)), final_buying_rate=35) ), Area('PV', strategy=PVStrategy(4, 80) ), ], config=config ) return area","title":"Setting General Configuration Parameters"},{"location":"general-settings/#simulation-launch","text":"Once the entire grid architecture is modelled, including energy assets, the user can launch the trading simulation by running a command line including desired setup features: -d, --duration: simulated duration of simulation [default: 1d] -t, --tick-length: simulated duration of a tick [default: 1s] -s, --slot-length: simulated duration of a market slot [default: 15m] -c, --cloud-coverage: Cloud coverage, 0 for sunny, 1 for partial coverage, 2 for clouds. [default: 0] --slot-length-realtime: Desired duration of slot in realtime [default: 0s] Example simulation call: d3a -l ERROR run --duration=1d --tick-length=1s --slot-length=15m --cloud-coverage=0 --setup default_2a Getting help in the command line: d3a --help returns: Usage: d3a [OPTIONS] COMMAND [ARGS]... Options: -l, --log-level [CRITICAL|FATAL|ERROR|WARN|WARNING|INFO|DEBUG|NOTSET|TRACE] Log level [default: INFO] --help Show this message and exit. Commands: run* resume d3a run --help returns: Usage: d3a run [OPTIONS] Options: -d, --duration INTERVAL Duration of simulation [default: 1d] -t, --tick-length INTERVAL Length of a tick [default: 1s] -s, --slot-length INTERVAL Length of a market slot [default: 15m] --slot-length-realtime INTERVAL Desired duration of slot in realtime [default: 0s] -c, --cloud-coverage INTEGER Cloud coverage, 0 for sunny, 1 for partial coverage, 2 for clouds. [default: 0] --setup TEXT Simulation setup module use. Available modules: [1000_houses, market_events.cloud_coverage_event, market_events.disable_interval_event, market_events.disconnect_interval_event, market_events.isolated_connect_event, market_events.isolated_disable_event, market_events.isolated_disconnect_event, market_events.isolated_enable_event, market_events.load_event, market_events.pv_event, market_events.storage_event, balancing_market.default_2a, balancing_market.one_load_one_pv, balancing_market.one_load_one_storage, balancing_market.one_storage_one_pv, balancing_market.test_asset_registry, balancing_market.two_sided_one_load_one_pv, config_parameter_test, default_2, default_2a, default_2b, default_3, default_3_pv_only, default_3a, default_3b, default_4, default_5, default_addcurve, default_addcurve2, default_csv, graphs_testing, jira.d3asim_1024, jira.d3asim_1139, jira.d3asim_638_custom_load, jira.d3asim_639_custom_storage, jira.d3asim_640_custom_pv, jira.d3asim_778, jira.d3asim_780, jira.d3asim_869, jira.d3asim_871, jira.d3asim_895, jira.d3asim_895_pr1, jira.d3asim_895_pr2, jira.d3asim_895_pr3, jira.d3asim_962, jira.default_2off_d3asim_1475, jira.default_595, jira.default_611, jira.default_613, jira.default_623, jira.default_645, jira.default_737, jira.test_strategy_custom_load, jira.test_strategy_custom_pv, jira.test_strategy_custom_storage, json_arg, json_file, non_compounded_grid_fees, redis_communication_default_2a, sam_config, sam_config_const_load, sam_config_small, strategy_tests.commercial_producer_market_maker_rate, strategy_tests.ess_capacity_based_sell_offer, strategy_tests.ess_sell_offer_decrease_based_on_risk_or_rate, strategy_tests.finite_power_plant, strategy_tests.finite_power_plant_profile, strategy_tests.home_cp_ess_load, strategy_tests.home_hybrid_pv_ess_load, strategy_tests.infinite_bus, strategy_tests.predefined_pv_test, strategy_tests.pv_const_price_decrease, strategy_tests.pv_final_selling_rate, strategy_tests.pv_initial_pv_rate_option, strategy_tests.pv_max_panel_output, strategy_tests.pv_max_panel_power_global, strategy_tests.pv_risk_based_price_decrease, strategy_tests.storage_buys_and_offers, strategy_tests.storage_strategy_break_even_hourly, strategy_tests.user_profile_load_csv, strategy_tests.user_profile_load_csv_multiday, strategy_tests.user_profile_load_dict, strategy_tests.user_profile_pv_csv, strategy_tests.user_profile_pv_dict, strategy_tests.user_profile_wind_csv, strategy_tests.user_rate_profile_load_dict, tobalaba.one_producer_load, two_sided_market.default_2a, two_sided_market.infinite_bus, two_sided_market.offer_reposted_at_old_offer_rate, two_sided_market.one_cep_one_load, two_sided_market.one_load_5_pv_partial, two_sided_market.one_load_one_storage, two_sided_market.one_pv_one_load, two_sided_market.one_pv_one_storage, two_sided_market.one_storage_5_pv_partial, two_sided_market.user_min_rate_profile_load_dict, two_sided_market.with_balancing_market, two_sided_pay_as_clear.default_2a, two_sided_pay_as_clear.test_clearing_energy] -g, --settings-file TEXT Settings file path --seed TEXT Manually specify random seed --paused Start simulation in paused state [default: False] --pause-at TEXT Automatically pause at a certain time. Accepted Input formats: (YYYY-MM-DD, HH:mm) [default: disabled] --repl / --no-repl Start REPL after simulation run. [default: False] --no-export Skip export of simulation data --export-path TEXT Specify a path for the csv export files (default: ~/d3a-simulation) --enable-bc Run simulation on Blockchain --start-date DATE Start date of the Simulation (YYYY-MM-DD) [default: 2019-09-27] --help Show this message and exit.","title":"Simulation launch"},{"location":"grid-fees/","text":"Grid operators (Distribution and Transmission System Operators - DSOs and TSOs - or Independent System Operators - ISOs in the USA) are tasked to monitor and manage the electrical grid. It is their responsibility to ensure a connection for end-users on the distribution network along with energy transport security. Grid operators use grid fees to cover the cost of managing their grid infrastructure. Lately, due to the heightened pace of innovation, increased demand and investment in distributed energy resources (DERs), grid operators face many challenges, such as lines and transformers congestion at specific times of the day. One solution is to use grid fees as a tool to actively manage grid congestion by increasing and reducing the fee during the day, week or year. Increasing the fee at peak transmission and reducing the price during off-peak periods makes it financially attractive for end-users to use flexible energy assets (e.g. batteries, EVs, heat-pumps) to provide demand response services and reduce reliance on the grid. Grid Singularity offers an environment to simulate, test and optimize grid fee incentives for local energy markets (LEMs) At the moment grid fee can be set as : Market Fee : This is a fee that is added to each trade that is cleared. The buyer of energy is responsible for paying all the grid fees: bid\u2019s price >= offer\u2019s price + grid fee . Constant grid fee : constant value in cents/kWh that is added to each trade Percentage grid fee : percentage value determined by the clearing price that is added to each trade The following article explains how flexible grid fees may be implemented towards peak reduction. For a video tutorial on how to set grid fees in the Grid Singularity exchange engine , please follow this link .","title":"Grid Fee Objectives"},{"location":"grid-market-settings/","text":"Energy markets are regulated exchange systems in which energy assets can buy, sell and trade energy. In the Grid Singularity Exchange, as a user builds an energy community, that community by default exists in one market. Its participants include the homes in the community and the grid market, if configured, which mimics the behaviour of a typical energy utility and can be used as a price reference point. Energy can be exchanged between the assets in this market, and this market can contain submarkets. For example, if the energy assets within a home in a community exchange energy (e.g. a solar panel supplying a fridge and a battery, the battery supplying a television\u2026) then this home can be considered a market in and of itself, with trading strategies implemented if the user/asset owner chooses to do so. Energy assets can trade by posting bids and offers in the market(s) in which they exist, the details of which can be configured in the advanced settings of each asset in a community on the Singularity Map. Markets are modelled following a hierarchical structure and are interconnected, allowing bids and offers to pass between markets until they are matched, following a select market clearing mechanism. Only one Grid Market can be set per simulation in the User Interface. The grid can be configured to sell an infinite amount of energy and/or to buy an infinite amount of energy, which can simulate a Feed-in Tariff scheme. By connecting through the Asset API , more than one grid market can be configured representing an example of a single energy community supplied by more than one energy retailer. Users can configure the grid market settings by selecting the black dot on the circle surrounding their energy community on the Singularity Map. Figure 2.15 . Map view of the grid market settings. Grid Market Configuration Options \u00b6 Express Mode 1. Name - Must be unique Advanced Mode 1. Mode - Users can choose either infinite power plant or infinite bus. - Infinite power plant mode has the ability to meet the infinite energy demand of consumers at the highest energy rate possible in that grid. - Infinite bus mode has both the ability to meet the infinite energy demand of consumers but also absorbs the infinite generation surplus of prosumers/producers at the lowest rate possible in that grid. 2. Role - If users select infinite bus mode, this option is set to grid connected, whereby the energy demanded of any consumer can be fulfilled and surplus generation can be absorbed. If users select infinite power plant mode, they can choose either Grid connected or Islanded, whereby the Market Maker would only be used as a reference point for the highest possible energy rate in that grid. 3. Selling Rate Type - Either select User Input to define a fixed selling rate or upload their custom selling rate profile. 4. Selling Rate - Users can enter a value in cents/kWh to represent the rate at which it will sell their energy. 5. Buying Rate Type (infinite bus mode only) - Users can select either User Input to define a fixed buying rate or upload their custom buying rate. 6. Buying Rate (infinite bus mode only) - Users can enter a value in cents/kWh to represent the Feed-in Tariff scheme Figure 2.16 . Advanced Configuration Options of the Grid Market.","title":"Grid Market Settings"},{"location":"grid-market-settings/#grid-market-configuration-options","text":"Express Mode 1. Name - Must be unique Advanced Mode 1. Mode - Users can choose either infinite power plant or infinite bus. - Infinite power plant mode has the ability to meet the infinite energy demand of consumers at the highest energy rate possible in that grid. - Infinite bus mode has both the ability to meet the infinite energy demand of consumers but also absorbs the infinite generation surplus of prosumers/producers at the lowest rate possible in that grid. 2. Role - If users select infinite bus mode, this option is set to grid connected, whereby the energy demanded of any consumer can be fulfilled and surplus generation can be absorbed. If users select infinite power plant mode, they can choose either Grid connected or Islanded, whereby the Market Maker would only be used as a reference point for the highest possible energy rate in that grid. 3. Selling Rate Type - Either select User Input to define a fixed selling rate or upload their custom selling rate profile. 4. Selling Rate - Users can enter a value in cents/kWh to represent the rate at which it will sell their energy. 5. Buying Rate Type (infinite bus mode only) - Users can select either User Input to define a fixed buying rate or upload their custom buying rate. 6. Buying Rate (infinite bus mode only) - Users can enter a value in cents/kWh to represent the Feed-in Tariff scheme Figure 2.16 . Advanced Configuration Options of the Grid Market.","title":"Grid Market Configuration Options"},{"location":"grid-operator-api-commands/","text":"The Grid Operator API can function once at the start of each market slot . When the current market slot ends, a new one is automatically created and the client is notified via the on_market_cycle event. It is possible to capture this event and perform operations when it occurs by overriding the functionality of the on_market_cycle method. The Grid Operator API can send batch commands, grouping different commands, for different markets. The commands can be grouped and then all executed at the same time. Three different commands are available for the Grid Operator API: last_market_dso_stats() \u00b6 This command is used to request information from different markets for the last market slot. This batch command receives one argument : area_uuid . This latter is the Universal Unique Identifier of the requested market statistic. Here is an example: self.add_to_batch_commands.last_market_dso_stats(area_uuid = \"62f827ec-ef86-4782-b5c3-88327751d97d\") grid_fees() \u00b6 This command is used to send the new grid fee for a specific market. The grid fee needs to be set as a positive value and the unit is cents/kWh. This batch command receives two arguments: area_uuid and fee_cents_kwh . Here is an example: self.add_to_batch_commands.grid_fees(area_uuid=62f827ec-ef86-4782-b5c3-88327751d97d\", fee_cents_kwh=3.2) After adding all the wanted commands in the batch, the API can execute it with the following command: response = self.execute_batch_commands() In return the simulation will provide a response for all commands submitted.","title":"Grid Operator API Commands"},{"location":"grid-operator-api-commands/#last_market_dso_stats","text":"This command is used to request information from different markets for the last market slot. This batch command receives one argument : area_uuid . This latter is the Universal Unique Identifier of the requested market statistic. Here is an example: self.add_to_batch_commands.last_market_dso_stats(area_uuid = \"62f827ec-ef86-4782-b5c3-88327751d97d\")","title":"last_market_dso_stats()"},{"location":"grid-operator-api-commands/#grid_fees","text":"This command is used to send the new grid fee for a specific market. The grid fee needs to be set as a positive value and the unit is cents/kWh. This batch command receives two arguments: area_uuid and fee_cents_kwh . Here is an example: self.add_to_batch_commands.grid_fees(area_uuid=62f827ec-ef86-4782-b5c3-88327751d97d\", fee_cents_kwh=3.2) After adding all the wanted commands in the batch, the API can execute it with the following command: response = self.execute_batch_commands() In return the simulation will provide a response for all commands submitted.","title":"grid_fees()"},{"location":"grid-operator-api-events/","text":"Market Information \u00b6 The Grid Operator API receives information concerning the markets that it manages. Different metrics are shared through the API : Minimum, median, average and maximum trade price [\u20ac/kWh] Total energy volume traded [kWh] Self-sufficiency / self-consumption [%] Import / Export [kWh] Current market fee [cents/kWh] Next market fee [cents/kWh] Market fee revenue [cents] Interaction with the running exchange \u00b6 As explained above the Grid Operator API function is triggered at the start of each market slot. Here is one example: At the end of the 12:45 market slot, the Grid Operator API function on_market_cycle is triggered. The Grid Operator agent receives a nested dictionary with information from the last market slot, including the grid tree ( 12:45-13:00 ). Based on these inputs, the agent script sets a new grid fee for the markets it manages. The grid fees sent during the 13:00 will be applied for the 13:15 market slot. API Events \u00b6 In the Grid Operator there are 3 events that are triggered while a simulation is running. Each new market slot \u00b6 def on_market_cycle(self, market_info): As shown in the schematic above, this event triggered at the start of every market slot. When a new market slot is created the API receives the market_info , containing market information and the code within the script event is executed. On event or response \u00b6 def on_event_or_response(self, message): In this event, the API receives a message for every event ( on_market_cycle ) or response for each commands (e.g. submitting new grid fees) On finish \u00b6 def on_finish(self, finish_info): This event is triggered when the simulation/collaboration finishes. Within that function, information stored during the simulation could potentially be exported for further analysis.","title":"Grid Operator API Events"},{"location":"grid-operator-api-events/#market-information","text":"The Grid Operator API receives information concerning the markets that it manages. Different metrics are shared through the API : Minimum, median, average and maximum trade price [\u20ac/kWh] Total energy volume traded [kWh] Self-sufficiency / self-consumption [%] Import / Export [kWh] Current market fee [cents/kWh] Next market fee [cents/kWh] Market fee revenue [cents]","title":"Market Information"},{"location":"grid-operator-api-events/#interaction-with-the-running-exchange","text":"As explained above the Grid Operator API function is triggered at the start of each market slot. Here is one example: At the end of the 12:45 market slot, the Grid Operator API function on_market_cycle is triggered. The Grid Operator agent receives a nested dictionary with information from the last market slot, including the grid tree ( 12:45-13:00 ). Based on these inputs, the agent script sets a new grid fee for the markets it manages. The grid fees sent during the 13:00 will be applied for the 13:15 market slot.","title":"Interaction with the running exchange"},{"location":"grid-operator-api-events/#api-events","text":"In the Grid Operator there are 3 events that are triggered while a simulation is running.","title":"API Events"},{"location":"grid-operator-api-events/#each-new-market-slot","text":"def on_market_cycle(self, market_info): As shown in the schematic above, this event triggered at the start of every market slot. When a new market slot is created the API receives the market_info , containing market information and the code within the script event is executed.","title":"Each new market slot"},{"location":"grid-operator-api-events/#on-event-or-response","text":"def on_event_or_response(self, message): In this event, the API receives a message for every event ( on_market_cycle ) or response for each commands (e.g. submitting new grid fees)","title":"On event or response"},{"location":"grid-operator-api-events/#on-finish","text":"def on_finish(self, finish_info): This event is triggered when the simulation/collaboration finishes. Within that function, information stored during the simulation could potentially be exported for further analysis.","title":"On finish"},{"location":"grid-operator-api-template-script/","text":"A Grid Operator API template script is available here . This is a flexible and versatile Python script for easy modification and implementation of custom grid fee strategies. See the TODO flags there to see how to configure your grid fee strategy and extract market data. In this script two template strategies are available: Time-of-Use (ToU) \u00b6 This is a strategy where grid fee is applied depending on the time of the day (hours and minutes) regardless of the market conditions. After analysing import and export patterns of their client, grid operators can create a time-based curve, increasing fees at peak predicted times (e.g. morning and dinner time). Here is an example of ToU strategy that was used by the DSOs in one of the experiments at Odyssey hackathon . Aziiz pricing \u00b6 The Aziiz model is using past market information to determine the next grid fee. The model looks at past imports and exports on a specific market, applies a moving average and then based on this number sets the next grid fee for that market. This model has the advantage of integrating market conditions into its strategy. For instance if past market slots experienced high imports, the model will increase fees in the relevant market to incentivise market participants to contain the energy within that area. Script Configuration \u00b6 At the start of the SDK Script, the user needs to specify the markets she/he wishes to connect and manage as well as the Oracle name . ################################################ # CONFIGURATIONS ################################################ automatic = True # List of market the Grid Operators connect to market_names = [\"Grid\", \"Community\"] # TODO list the market names as they are in the collaboration # Name of your aggregator oracle_name = \"dso Right after that, the user can select the strategy to use (Time of Use or Aziiz model). To select the Time of Use strategy, you have to set TimeOfUse to True and Aziiz to False. On the other hand, to select the Aziiz model, the user has to set TimeOfUse to False and Aziiz to True. If the Aziiz model is selected, the user can tune parameters such as applying the moving average and specifying the number of past market slots to average. # Grid tariff selection TimeOfUse = True # TODO Activate the Time of Use model if set to True Aziiz = False # TODO Activate the Aziiz model if set to True moving_average_peak = True # Perform a moving average of the last #look_back ptu (for the Aziiz tariff only) look_back = 4 # Number of past markets slots to apply the moving average (for the Aziiz tariff only) slot_length = 15 # leave as is def fee_strategy(): if TimeOfUse: market_prices = pd.read_excel(os.path.join(current_dir,\"resources/ToU.xlsx\")) # TODO upload an Excel/CSV file with prices of every market at each time slot (based on given template) planned_fee = {} for i in range(len(market_prices)): for j in market_names: planned_fee.update({(str(market_prices[\"Time\"][i])[0:5], j): market_prices[j][i]}) if Aziiz: market_prices = pd.ExcelFile(os.path.join(current_dir, \"resources/Aziiz.xlsx\")) # TODO upload an Excel/CSV file with thresholds and fees of every market (based on given template) return market_prices, planned_fee For both strategies, the script reads an Excel file to adjust the grid fees ( ToU.xlsx and Aziiz.xlsx ). In ToU.xlsx the user can define the grid fees for each market she/he manages for every quarter hours of the day. In Aziiz.xlsx grid fees can be set for every peak import/export thresholds for each market. The Aziiz strategy will compare the average of the last markets\u2019 peak import/export to the threshold. If the average is lower than the threshold the relevant grid fee will be applied (for instance on the figure below if the average peak is equal to 22kWh, the next grid fee will be 3 cents/KWh. Each sheet\u2019s name represents the market connected to. On_market_slot event is used to gather market statistics and set the grid fees for the next market slot. In the first part, the Grid Operator API is requesting market statistics from the simulation. ################################################ # STORE MARKET INFORMATION ################################################ for area_uuid, area_dict in self.latest_grid_tree_flat.items(): if area_dict[\"area_name\"] in market_names: self.add_to_batch_commands.last_market_dso_stats(area_uuid) self.dso_stats_response = self.execute_batch_commands() Later in the script, the API is storing some of the relevant market data to local variables, easier to manipulate. for area_uuid, area_dict in self.latest_grid_tree_flat.items(): if area_dict[\"area_name\"] in market_names: self.last_market_fee[area_dict[\"area_name\"]] = area_dict[\"last_market_fee\"] self.current_market_fee[area_dict[\"area_name\"]] = area_dict[\"current_market_fee\"] for uuid, market_event in self.dso_stats_response[\"responses\"].items(): # Store data from market info into variables - these variables are updated in a way that always just store the current/most updated values self.min_trade_rate[market_event[0]['name']] = market_event[0][\"market_stats\"][\"min_trade_rate\"] self.avg_trade_rate[market_event[0]['name']] = market_event[0][\"market_stats\"][\"avg_trade_rate\"] self.max_trade_rate[market_event[0]['name']] = market_event[0][\"market_stats\"][\"max_trade_rate\"] self.median_trade_rate[market_event[0]['name']] = market_event[0][\"market_stats\"][\"median_trade_rate\"] self.total_traded_energy_kWh[market_event[0]['name']] = market_event[0][\"market_stats\"][\"total_traded_energy_kWh\"] self.self_sufficiency[market_event[0]['name']] = market_event[0][\"market_stats\"][\"self_sufficiency\"] self.self_consumption[market_event[0]['name']] = market_event[0][\"market_stats\"][\"self_consumption\"] self.import_kWh[market_event[0]['name']] = market_event[0][\"market_stats\"]['area_throughput']['import'] self.export_kWh[market_event[0]['name']] = market_event[0][\"market_stats\"]['area_throughput']['export'] try: self.balance[market_event[0]['name']] = self.import_kWh[market_event[0]['name']] - self.export_kWh[market_event[0]['name']] except: self.balance[market_event[0]['name']] = 0 self.balance_hist = self.balance_hist.append(self.balance,ignore_index=True) # DataFrame that gets updated and grows at each market slot and contains the balance (import - export) for the areas # Print information in the terminal print('LAST MARKET STATISTICS') last_market_table1 = [] for i in range(len(market_names)): keys_list = list(self.total_traded_energy_kWh.keys()) values_list = list(self.total_traded_energy_kWh.values()) min_values_list = list(self.min_trade_rate.values()) avg_values_list = list(self.avg_trade_rate.values()) med_values_list = list(self.median_trade_rate.values()) max_values_list = list(self.max_trade_rate.values()) # Print None values as 0 values_list = [0 if x is None else x for x in values_list] min_values_list = [0 if x is None else x for x in min_values_list] avg_values_list = [0 if x is None else x for x in avg_values_list] med_values_list = [0 if x is None else x for x in med_values_list] max_values_list = [0 if x is None else x for x in max_values_list] last_market_table1.append( [keys_list[i], values_list[i], min_values_list[i], avg_values_list[i], med_values_list[i], max_values_list[i]]) last_market_headers1 = [\"Markets\", \"Total energy traded [kWh]\", \"Min trade rate [\u20accts/Kwh]\", \"Avg trade rate [\u20accts/Kwh]\", \"Med trade rate [\u20accts/Kwh]\", \"Max trade rate [\u20accts/Kwh]\"] print(tabulate(last_market_table1, last_market_headers1, tablefmt=\"fancy_grid\")) last_market_table2 = [] for i in range(len(market_names)): keys_list = list(self.total_traded_energy_kWh.keys()) ss_values_list = list(self.self_sufficiency.values()) sc_values_list = list(self.self_consumption.values()) energy_imp_values_list = list(self.import_kWh.values()) energy_exp_values_list = list(self.export_kWh.values()) last_fee_values_list = list(self.last_market_fee.values()) # Print None values as 0 ss_values_list = [0 if x is None else x for x in ss_values_list] sc_values_list = [0 if x is None else x for x in sc_values_list] energy_imp_values_list = [0 if x is None else x for x in energy_imp_values_list] energy_exp_values_list = [0 if x is None else x for x in energy_exp_values_list] last_fee_values_list = [0 if x is None else x for x in last_fee_values_list] last_market_table2.append([keys_list[i], ss_values_list[i], sc_values_list[i], energy_imp_values_list[i], energy_exp_values_list[i], last_fee_values_list[i]]) last_market_headers2 = [\"Markets\", \"Self sufficiency [%]\", \"Self consumption [%]\", \"Energy import [kWh]\", \"Energy export [kWh]\", \"Last fee [\u20accts/Kwh]\"] print(tabulate(last_market_table2, last_market_headers2, tablefmt=\"fancy_grid\")) ################################################ # SET NEW GRID FEE ################################################ for area_uuid, area_dict in self.latest_grid_tree_flat.items(): if area_dict[\"area_name\"] in market_names: ################################################################### # TIME OF USE STRATEGY ################################################################### if TimeOfUse: self.next_market_fee[area_dict[\"area_name\"]] = self.scheduled_fee(self.market_time, planned_fee, area_dict[\"area_name\"]) ################################################################### # AZIIZ STRATEGY ################################################################### if Aziiz: if moving_average_peak: self.max_ext_energy_kWh = abs(self.balance_hist[area_dict[\"area_name\"]].iloc[ -look_back:].mean()) # Calculate the absolute moving average of the net balance by looking back at 4 markets else: self.max_ext_energy_kWh = max(self.import_kWh[area_dict[\"area_name\"]], self.export_kWh[ area_dict[ \"area_name\"]]) # Calculate the max between the import and export of the defined market individual_market_prices = pd.read_excel(market_prices, area_dict[\"area_name\"]) # Select the market in the file for k in range(len(individual_market_prices)): if self.max_ext_energy_kWh <= individual_market_prices[\"Threshold\"][k]: # if the peak is lower than this value, the following grid fee will be applied. If the max is higher, it will go to the lower elif condition self.next_market_fee[area_dict[\"area_name\"]] = individual_market_prices[\"Grid fee\"][ k] # new grid fee break else: self.next_market_fee[area_dict[ \"area_name\"]] = 2000 # TODO set the last value if all the previous ones are not fulfilled self.add_to_batch_commands.grid_fees(area_uuid=area_uuid,fee_cents_kwh=self.next_market_fee[area_dict[\"area_name\"]]) next_fee_response = self.execute_batch_commands() # send batch command print() print('CURRENT AND NEXT MARKET FEES') current_market_table = [] for i in range(len(market_names)): keys_list = list(self.current_market_fee.keys()) current_fee_values_list = list(self.current_market_fee.values()) next_fee_values_list = list(self.next_market_fee.values()) current_fee_values_list = [0 if x is None else x for x in current_fee_values_list] next_fee_values_list = [0 if x is None else x for x in next_fee_values_list] current_market_table.append([keys_list[i], current_fee_values_list[i], next_fee_values_list[i]]) current_market_headers = [\"Markets\", \"Current fee [\u20accts/kWh]\", \"Next fee [\u20accts/kWh]\"] print(tabulate(current_market_table, current_market_headers, tablefmt=\"fancy_grid\")) ################################################ # TRIGGERS EACH COMMAND RESPONSE AND EVENT ################################################ def on_event_or_response(self, message): # print(\"message\",message) pass ################################################ # SIMULATION TERMINATION CONDITION ################################################ def on_finish(self, finish_info): # TODO export relevant information stored during the simulation (if needed) self.is_finished = True ################################################ # REGISTER FOR MARKETS ################################################ def get_assets_name(indict: dict) -> dict: \"\"\" This function is used to parse the grid tree and returned all registered assets wrapper for _get_assets_name \"\"\" if indict == {}: return {} outdict = {\"Area\": [], \"Load\": [], \"PV\": [], \"Storage\": []} _get_assets_name(indict, outdict) return outdict def _get_assets_name(indict: dict, outdict: dict): \"\"\" Parse the collaboration / Canary Network registry Returns a list of the Market, Load, PV and Storage nodes the user is registered to \"\"\" for key, value in indict.items(): if key == \"name\": name = value if key == \"type\": area_type = value if key == \"registered\" and value: outdict[area_type].append(name) if 'children' in key: for children in indict[key]: _get_assets_name(children, outdict) # Code to create the market aggregator and connect to the relevant simulation. Keep it as is if os.environ[\"API_CLIENT_RUN_ON_REDIS\"] == \"true\": MarketClient = RedisMarketClient market_args = {\"autoregister\": True} aggr = Oracle(aggregator_name=oracle_name) else: MarketClient = RestMarketClient simulation_id = os.environ[\"API_CLIENT_SIMULATION_ID\"] domain_name = os.environ[\"API_CLIENT_DOMAIN_NAME\"] websockets_domain_name = os.environ[\"API_CLIENT_WEBSOCKET_DOMAIN_NAME\"] market_args = {\"simulation_id\": simulation_id, \"domain_name\": domain_name, \"websockets_domain_name\": websockets_domain_name} aggr = Oracle(aggregator_name=oracle_name, **market_args) if automatic: registry = aggr.get_configuration_registry() market_names = get_assets_name(registry)[\"Area\"] market_prices, planned_fee = fee_strategy() print() print('Connecting to markets ...') for i in market_names: if os.environ[\"API_CLIENT_RUN_ON_REDIS\"] == \"true\": market_registered = RedisMarketClient(area_id=i) else: market_uuid = get_area_uuid_from_area_name_and_collaboration_id(market_args[\"simulation_id\"], i, market_args[\"domain_name\"]) market_args[\"area_id\"] = market_uuid market_registered = RestMarketClient(**market_args) selected = market_registered.select_aggregator(aggr.aggregator_uuid) print(\"----> Connected to \", i) sleep(0.3) print(aggr.device_uuid_list) # loop to allow persistence while not aggr.is_finished: sleep(0.5) In the following lines, to improve the API monitoring, the script is printing relevant data in the terminal: # Print information in the terminal print('LAST MARKET STATISTICS') last_market_table1 = [] for i in range(len(market_names)): keys_list = list(self.total_traded_energy_kWh.keys()) values_list = list(self.total_traded_energy_kWh.values()) min_values_list = list(self.min_trade_rate.values()) avg_values_list = list(self.avg_trade_rate.values()) med_values_list = list(self.median_trade_rate.values()) max_values_list = list(self.max_trade_rate.values()) # Print None values as 0 values_list = [0 if x is None else x for x in values_list] min_values_list = [0 if x is None else x for x in min_values_list] avg_values_list = [0 if x is None else x for x in avg_values_list] med_values_list = [0 if x is None else x for x in med_values_list] max_values_list = [0 if x is None else x for x in max_values_list] last_market_table1.append( [keys_list[i], values_list[i], min_values_list[i], avg_values_list[i], med_values_list[i], max_values_list[i]]) last_market_headers1 = [\"Markets\", \"Total energy traded [kWh]\", \"Min trade rate [\u20accts/Kwh]\", \"Avg trade rate [\u20accts/Kwh]\", \"Med trade rate [\u20accts/Kwh]\", \"Max trade rate [\u20accts/Kwh]\"] print(tabulate(last_market_table1, last_market_headers1, tablefmt=\"fancy_grid\")) last_market_table2 = [] for i in range(len(market_names)): keys_list = list(self.total_traded_energy_kWh.keys()) ss_values_list = list(self.self_sufficiency.values()) sc_values_list = list(self.self_consumption.values()) energy_imp_values_list = list(self.import_kWh.values()) energy_exp_values_list = list(self.export_kWh.values()) last_fee_values_list = list(self.last_market_fee.values()) # Print None values as 0 ss_values_list = [0 if x is None else x for x in ss_values_list] sc_values_list = [0 if x is None else x for x in sc_values_list] energy_imp_values_list = [0 if x is None else x for x in energy_imp_values_list] energy_exp_values_list = [0 if x is None else x for x in energy_exp_values_list] last_fee_values_list = [0 if x is None else x for x in last_fee_values_list] last_market_table2.append([keys_list[i], ss_values_list[i], sc_values_list[i], energy_imp_values_list[i], energy_exp_values_list[i], last_fee_values_list[i]]) last_market_headers2 = [\"Markets\", \"Self sufficiency [%]\", \"Self consumption [%]\", \"Energy import [kWh]\", \"Energy export [kWh]\", \"Last fee [\u20accts/Kwh]\"] print(tabulate(last_market_table2, last_market_headers2, tablefmt=\"fancy_grid\")) In the next section, the script applies the grid fee depending on the fee strategy chosen here. If the Time of Use was set, the markets\u2019 grid fee is set based on the ToU excel file. If the Aziiz model was chosen the next fee is defined based on the Aziiz excel file. Additionally, if the peak import/export is higher than all threshold defined in the excel sheets this line sets the next fee as 2000cts/kWh. All the fees are added to the batch command and then executed. ################################################ # SET NEW GRID FEE ################################################ for area_uuid, area_dict in self.latest_grid_tree_flat.items(): if area_dict[\"area_name\"] in market_names: ################################################################### # TIME OF USE STRATEGY ################################################################### if TimeOfUse: self.next_market_fee[area_dict[\"area_name\"]] = self.scheduled_fee(self.market_time, planned_fee, area_dict[\"area_name\"]) ################################################################### # AZIIZ STRATEGY ################################################################### if Aziiz: if moving_average_peak: self.max_ext_energy_kWh = abs(self.balance_hist[area_dict[\"area_name\"]].iloc[ -look_back:].mean()) # Calculate the absolute moving average of the net balance by looking back at 4 markets else: self.max_ext_energy_kWh = max(self.import_kWh[area_dict[\"area_name\"]], self.export_kWh[ area_dict[ \"area_name\"]]) # Calculate the max between the import and export of the defined market individual_market_prices = pd.read_excel(market_prices, area_dict[\"area_name\"]) # Select the market in the file for k in range(len(individual_market_prices)): if self.max_ext_energy_kWh <= individual_market_prices[\"Threshold\"][k]: # if the peak is lower than this value, the following grid fee will be applied. If the max is higher, it will go to the lower elif condition self.next_market_fee[area_dict[\"area_name\"]] = individual_market_prices[\"Grid fee\"][ k] # new grid fee break else: self.next_market_fee[area_dict[ \"area_name\"]] = 2000 # TODO set the last value if all the previous ones are not fulfilled self.add_to_batch_commands.grid_fees(area_uuid=area_uuid,fee_cents_kwh=self.next_market_fee[area_dict[\"area_name\"]]) next_fee_response = self.execute_batch_commands() # send batch command In the following lines, the script is printing the current fee and next fee for each market. print() print('CURRENT AND NEXT MARKET FEES') current_market_table = [] for i in range(len(market_names)): keys_list = list(self.current_market_fee.keys()) current_fee_values_list = list(self.current_market_fee.values()) next_fee_values_list = list(self.next_market_fee.values()) current_fee_values_list = [0 if x is None else x for x in current_fee_values_list] next_fee_values_list = [0 if x is None else x for x in next_fee_values_list] current_market_table.append([keys_list[i], current_fee_values_list[i], next_fee_values_list[i]]) current_market_headers = [\"Markets\", \"Current fee [\u20accts/kWh]\", \"Next fee [\u20accts/kWh]\"] print(tabulate(current_market_table, current_market_headers, tablefmt=\"fancy_grid\")) Later, the on_event_or_response is overwritten. By default we do not perform any operation in this event but the user could add some if needed. For instance the user could record all the grid fee change responses received in that event. ################################################ # TRIGGERS EACH COMMAND RESPONSE AND EVENT ################################################ def on_event_or_response(self, message): # print(\"message\",message) pass Lastly, the SDK Script overwrites the on_finish event so that whenever the function is triggered the script stops. If the user wishes to save some information recorded within the Exchange SDK this would be the opportunity to export them to external files. ################################################ # SIMULATION TERMINATION CONDITION ################################################ def on_finish(self, finish_info): # TODO export relevant information stored during the simulation (if needed) self.is_finished = True The rest of the script is used to connect to a running simulation/collaboration/Canary Test Network. These lines should work as is and no changes are required. ################################################ # REGISTER FOR MARKETS ################################################ def get_assets_name(indict: dict) -> dict: \"\"\" This function is used to parse the grid tree and returned all registered assets wrapper for _get_assets_name \"\"\" if indict == {}: return {} outdict = {\"Area\": [], \"Load\": [], \"PV\": [], \"Storage\": []} _get_assets_name(indict, outdict) return outdict def _get_assets_name(indict: dict, outdict: dict): \"\"\" Parse the collaboration / Canary Network registry Returns a list of the Market, Load, PV and Storage nodes the user is registered to \"\"\" for key, value in indict.items(): if key == \"name\": name = value if key == \"type\": area_type = value if key == \"registered\" and value: outdict[area_type].append(name) if 'children' in key: for children in indict[key]: _get_assets_name(children, outdict) # Code to create the market aggregator and connect to the relevant simulation. Keep it as is if os.environ[\"API_CLIENT_RUN_ON_REDIS\"] == \"true\": MarketClient = RedisMarketClient market_args = {\"autoregister\": True} aggr = Oracle(aggregator_name=oracle_name) else: MarketClient = RestMarketClient simulation_id = os.environ[\"API_CLIENT_SIMULATION_ID\"] domain_name = os.environ[\"API_CLIENT_DOMAIN_NAME\"] websockets_domain_name = os.environ[\"API_CLIENT_WEBSOCKET_DOMAIN_NAME\"] market_args = {\"simulation_id\": simulation_id, \"domain_name\": domain_name, \"websockets_domain_name\": websockets_domain_name} aggr = Oracle(aggregator_name=oracle_name, **market_args) if automatic: registry = aggr.get_configuration_registry() market_names = get_assets_name(registry)[\"Area\"] market_prices, planned_fee = fee_strategy() print() print('Connecting to markets ...') for i in market_names: if os.environ[\"API_CLIENT_RUN_ON_REDIS\"] == \"true\": market_registered = RedisMarketClient(area_id=i) else: market_uuid = get_area_uuid_from_area_name_and_collaboration_id(market_args[\"simulation_id\"], i, market_args[\"domain_name\"]) market_args[\"area_id\"] = market_uuid market_registered = RestMarketClient(**market_args) selected = market_registered.select_aggregator(aggr.aggregator_uuid) print(\"----> Connected to \", i) sleep(0.3) print(aggr.device_uuid_list) # loop to allow persistence while not aggr.is_finished: sleep(0.5) For a video tutorial on the Grid Operator API, please follow this link . The next step is to adapt the Grid Operator API template script ) developed by Grid Singularity to customize the grid fee strategies as you wish!","title":"Grid Operator API Template Script"},{"location":"grid-operator-api-template-script/#time-of-use-tou","text":"This is a strategy where grid fee is applied depending on the time of the day (hours and minutes) regardless of the market conditions. After analysing import and export patterns of their client, grid operators can create a time-based curve, increasing fees at peak predicted times (e.g. morning and dinner time). Here is an example of ToU strategy that was used by the DSOs in one of the experiments at Odyssey hackathon .","title":"Time-of-Use (ToU)"},{"location":"grid-operator-api-template-script/#aziiz-pricing","text":"The Aziiz model is using past market information to determine the next grid fee. The model looks at past imports and exports on a specific market, applies a moving average and then based on this number sets the next grid fee for that market. This model has the advantage of integrating market conditions into its strategy. For instance if past market slots experienced high imports, the model will increase fees in the relevant market to incentivise market participants to contain the energy within that area.","title":"Aziiz pricing"},{"location":"grid-operator-api-template-script/#script-configuration","text":"At the start of the SDK Script, the user needs to specify the markets she/he wishes to connect and manage as well as the Oracle name . ################################################ # CONFIGURATIONS ################################################ automatic = True # List of market the Grid Operators connect to market_names = [\"Grid\", \"Community\"] # TODO list the market names as they are in the collaboration # Name of your aggregator oracle_name = \"dso Right after that, the user can select the strategy to use (Time of Use or Aziiz model). To select the Time of Use strategy, you have to set TimeOfUse to True and Aziiz to False. On the other hand, to select the Aziiz model, the user has to set TimeOfUse to False and Aziiz to True. If the Aziiz model is selected, the user can tune parameters such as applying the moving average and specifying the number of past market slots to average. # Grid tariff selection TimeOfUse = True # TODO Activate the Time of Use model if set to True Aziiz = False # TODO Activate the Aziiz model if set to True moving_average_peak = True # Perform a moving average of the last #look_back ptu (for the Aziiz tariff only) look_back = 4 # Number of past markets slots to apply the moving average (for the Aziiz tariff only) slot_length = 15 # leave as is def fee_strategy(): if TimeOfUse: market_prices = pd.read_excel(os.path.join(current_dir,\"resources/ToU.xlsx\")) # TODO upload an Excel/CSV file with prices of every market at each time slot (based on given template) planned_fee = {} for i in range(len(market_prices)): for j in market_names: planned_fee.update({(str(market_prices[\"Time\"][i])[0:5], j): market_prices[j][i]}) if Aziiz: market_prices = pd.ExcelFile(os.path.join(current_dir, \"resources/Aziiz.xlsx\")) # TODO upload an Excel/CSV file with thresholds and fees of every market (based on given template) return market_prices, planned_fee For both strategies, the script reads an Excel file to adjust the grid fees ( ToU.xlsx and Aziiz.xlsx ). In ToU.xlsx the user can define the grid fees for each market she/he manages for every quarter hours of the day. In Aziiz.xlsx grid fees can be set for every peak import/export thresholds for each market. The Aziiz strategy will compare the average of the last markets\u2019 peak import/export to the threshold. If the average is lower than the threshold the relevant grid fee will be applied (for instance on the figure below if the average peak is equal to 22kWh, the next grid fee will be 3 cents/KWh. Each sheet\u2019s name represents the market connected to. On_market_slot event is used to gather market statistics and set the grid fees for the next market slot. In the first part, the Grid Operator API is requesting market statistics from the simulation. ################################################ # STORE MARKET INFORMATION ################################################ for area_uuid, area_dict in self.latest_grid_tree_flat.items(): if area_dict[\"area_name\"] in market_names: self.add_to_batch_commands.last_market_dso_stats(area_uuid) self.dso_stats_response = self.execute_batch_commands() Later in the script, the API is storing some of the relevant market data to local variables, easier to manipulate. for area_uuid, area_dict in self.latest_grid_tree_flat.items(): if area_dict[\"area_name\"] in market_names: self.last_market_fee[area_dict[\"area_name\"]] = area_dict[\"last_market_fee\"] self.current_market_fee[area_dict[\"area_name\"]] = area_dict[\"current_market_fee\"] for uuid, market_event in self.dso_stats_response[\"responses\"].items(): # Store data from market info into variables - these variables are updated in a way that always just store the current/most updated values self.min_trade_rate[market_event[0]['name']] = market_event[0][\"market_stats\"][\"min_trade_rate\"] self.avg_trade_rate[market_event[0]['name']] = market_event[0][\"market_stats\"][\"avg_trade_rate\"] self.max_trade_rate[market_event[0]['name']] = market_event[0][\"market_stats\"][\"max_trade_rate\"] self.median_trade_rate[market_event[0]['name']] = market_event[0][\"market_stats\"][\"median_trade_rate\"] self.total_traded_energy_kWh[market_event[0]['name']] = market_event[0][\"market_stats\"][\"total_traded_energy_kWh\"] self.self_sufficiency[market_event[0]['name']] = market_event[0][\"market_stats\"][\"self_sufficiency\"] self.self_consumption[market_event[0]['name']] = market_event[0][\"market_stats\"][\"self_consumption\"] self.import_kWh[market_event[0]['name']] = market_event[0][\"market_stats\"]['area_throughput']['import'] self.export_kWh[market_event[0]['name']] = market_event[0][\"market_stats\"]['area_throughput']['export'] try: self.balance[market_event[0]['name']] = self.import_kWh[market_event[0]['name']] - self.export_kWh[market_event[0]['name']] except: self.balance[market_event[0]['name']] = 0 self.balance_hist = self.balance_hist.append(self.balance,ignore_index=True) # DataFrame that gets updated and grows at each market slot and contains the balance (import - export) for the areas # Print information in the terminal print('LAST MARKET STATISTICS') last_market_table1 = [] for i in range(len(market_names)): keys_list = list(self.total_traded_energy_kWh.keys()) values_list = list(self.total_traded_energy_kWh.values()) min_values_list = list(self.min_trade_rate.values()) avg_values_list = list(self.avg_trade_rate.values()) med_values_list = list(self.median_trade_rate.values()) max_values_list = list(self.max_trade_rate.values()) # Print None values as 0 values_list = [0 if x is None else x for x in values_list] min_values_list = [0 if x is None else x for x in min_values_list] avg_values_list = [0 if x is None else x for x in avg_values_list] med_values_list = [0 if x is None else x for x in med_values_list] max_values_list = [0 if x is None else x for x in max_values_list] last_market_table1.append( [keys_list[i], values_list[i], min_values_list[i], avg_values_list[i], med_values_list[i], max_values_list[i]]) last_market_headers1 = [\"Markets\", \"Total energy traded [kWh]\", \"Min trade rate [\u20accts/Kwh]\", \"Avg trade rate [\u20accts/Kwh]\", \"Med trade rate [\u20accts/Kwh]\", \"Max trade rate [\u20accts/Kwh]\"] print(tabulate(last_market_table1, last_market_headers1, tablefmt=\"fancy_grid\")) last_market_table2 = [] for i in range(len(market_names)): keys_list = list(self.total_traded_energy_kWh.keys()) ss_values_list = list(self.self_sufficiency.values()) sc_values_list = list(self.self_consumption.values()) energy_imp_values_list = list(self.import_kWh.values()) energy_exp_values_list = list(self.export_kWh.values()) last_fee_values_list = list(self.last_market_fee.values()) # Print None values as 0 ss_values_list = [0 if x is None else x for x in ss_values_list] sc_values_list = [0 if x is None else x for x in sc_values_list] energy_imp_values_list = [0 if x is None else x for x in energy_imp_values_list] energy_exp_values_list = [0 if x is None else x for x in energy_exp_values_list] last_fee_values_list = [0 if x is None else x for x in last_fee_values_list] last_market_table2.append([keys_list[i], ss_values_list[i], sc_values_list[i], energy_imp_values_list[i], energy_exp_values_list[i], last_fee_values_list[i]]) last_market_headers2 = [\"Markets\", \"Self sufficiency [%]\", \"Self consumption [%]\", \"Energy import [kWh]\", \"Energy export [kWh]\", \"Last fee [\u20accts/Kwh]\"] print(tabulate(last_market_table2, last_market_headers2, tablefmt=\"fancy_grid\")) ################################################ # SET NEW GRID FEE ################################################ for area_uuid, area_dict in self.latest_grid_tree_flat.items(): if area_dict[\"area_name\"] in market_names: ################################################################### # TIME OF USE STRATEGY ################################################################### if TimeOfUse: self.next_market_fee[area_dict[\"area_name\"]] = self.scheduled_fee(self.market_time, planned_fee, area_dict[\"area_name\"]) ################################################################### # AZIIZ STRATEGY ################################################################### if Aziiz: if moving_average_peak: self.max_ext_energy_kWh = abs(self.balance_hist[area_dict[\"area_name\"]].iloc[ -look_back:].mean()) # Calculate the absolute moving average of the net balance by looking back at 4 markets else: self.max_ext_energy_kWh = max(self.import_kWh[area_dict[\"area_name\"]], self.export_kWh[ area_dict[ \"area_name\"]]) # Calculate the max between the import and export of the defined market individual_market_prices = pd.read_excel(market_prices, area_dict[\"area_name\"]) # Select the market in the file for k in range(len(individual_market_prices)): if self.max_ext_energy_kWh <= individual_market_prices[\"Threshold\"][k]: # if the peak is lower than this value, the following grid fee will be applied. If the max is higher, it will go to the lower elif condition self.next_market_fee[area_dict[\"area_name\"]] = individual_market_prices[\"Grid fee\"][ k] # new grid fee break else: self.next_market_fee[area_dict[ \"area_name\"]] = 2000 # TODO set the last value if all the previous ones are not fulfilled self.add_to_batch_commands.grid_fees(area_uuid=area_uuid,fee_cents_kwh=self.next_market_fee[area_dict[\"area_name\"]]) next_fee_response = self.execute_batch_commands() # send batch command print() print('CURRENT AND NEXT MARKET FEES') current_market_table = [] for i in range(len(market_names)): keys_list = list(self.current_market_fee.keys()) current_fee_values_list = list(self.current_market_fee.values()) next_fee_values_list = list(self.next_market_fee.values()) current_fee_values_list = [0 if x is None else x for x in current_fee_values_list] next_fee_values_list = [0 if x is None else x for x in next_fee_values_list] current_market_table.append([keys_list[i], current_fee_values_list[i], next_fee_values_list[i]]) current_market_headers = [\"Markets\", \"Current fee [\u20accts/kWh]\", \"Next fee [\u20accts/kWh]\"] print(tabulate(current_market_table, current_market_headers, tablefmt=\"fancy_grid\")) ################################################ # TRIGGERS EACH COMMAND RESPONSE AND EVENT ################################################ def on_event_or_response(self, message): # print(\"message\",message) pass ################################################ # SIMULATION TERMINATION CONDITION ################################################ def on_finish(self, finish_info): # TODO export relevant information stored during the simulation (if needed) self.is_finished = True ################################################ # REGISTER FOR MARKETS ################################################ def get_assets_name(indict: dict) -> dict: \"\"\" This function is used to parse the grid tree and returned all registered assets wrapper for _get_assets_name \"\"\" if indict == {}: return {} outdict = {\"Area\": [], \"Load\": [], \"PV\": [], \"Storage\": []} _get_assets_name(indict, outdict) return outdict def _get_assets_name(indict: dict, outdict: dict): \"\"\" Parse the collaboration / Canary Network registry Returns a list of the Market, Load, PV and Storage nodes the user is registered to \"\"\" for key, value in indict.items(): if key == \"name\": name = value if key == \"type\": area_type = value if key == \"registered\" and value: outdict[area_type].append(name) if 'children' in key: for children in indict[key]: _get_assets_name(children, outdict) # Code to create the market aggregator and connect to the relevant simulation. Keep it as is if os.environ[\"API_CLIENT_RUN_ON_REDIS\"] == \"true\": MarketClient = RedisMarketClient market_args = {\"autoregister\": True} aggr = Oracle(aggregator_name=oracle_name) else: MarketClient = RestMarketClient simulation_id = os.environ[\"API_CLIENT_SIMULATION_ID\"] domain_name = os.environ[\"API_CLIENT_DOMAIN_NAME\"] websockets_domain_name = os.environ[\"API_CLIENT_WEBSOCKET_DOMAIN_NAME\"] market_args = {\"simulation_id\": simulation_id, \"domain_name\": domain_name, \"websockets_domain_name\": websockets_domain_name} aggr = Oracle(aggregator_name=oracle_name, **market_args) if automatic: registry = aggr.get_configuration_registry() market_names = get_assets_name(registry)[\"Area\"] market_prices, planned_fee = fee_strategy() print() print('Connecting to markets ...') for i in market_names: if os.environ[\"API_CLIENT_RUN_ON_REDIS\"] == \"true\": market_registered = RedisMarketClient(area_id=i) else: market_uuid = get_area_uuid_from_area_name_and_collaboration_id(market_args[\"simulation_id\"], i, market_args[\"domain_name\"]) market_args[\"area_id\"] = market_uuid market_registered = RestMarketClient(**market_args) selected = market_registered.select_aggregator(aggr.aggregator_uuid) print(\"----> Connected to \", i) sleep(0.3) print(aggr.device_uuid_list) # loop to allow persistence while not aggr.is_finished: sleep(0.5) In the following lines, to improve the API monitoring, the script is printing relevant data in the terminal: # Print information in the terminal print('LAST MARKET STATISTICS') last_market_table1 = [] for i in range(len(market_names)): keys_list = list(self.total_traded_energy_kWh.keys()) values_list = list(self.total_traded_energy_kWh.values()) min_values_list = list(self.min_trade_rate.values()) avg_values_list = list(self.avg_trade_rate.values()) med_values_list = list(self.median_trade_rate.values()) max_values_list = list(self.max_trade_rate.values()) # Print None values as 0 values_list = [0 if x is None else x for x in values_list] min_values_list = [0 if x is None else x for x in min_values_list] avg_values_list = [0 if x is None else x for x in avg_values_list] med_values_list = [0 if x is None else x for x in med_values_list] max_values_list = [0 if x is None else x for x in max_values_list] last_market_table1.append( [keys_list[i], values_list[i], min_values_list[i], avg_values_list[i], med_values_list[i], max_values_list[i]]) last_market_headers1 = [\"Markets\", \"Total energy traded [kWh]\", \"Min trade rate [\u20accts/Kwh]\", \"Avg trade rate [\u20accts/Kwh]\", \"Med trade rate [\u20accts/Kwh]\", \"Max trade rate [\u20accts/Kwh]\"] print(tabulate(last_market_table1, last_market_headers1, tablefmt=\"fancy_grid\")) last_market_table2 = [] for i in range(len(market_names)): keys_list = list(self.total_traded_energy_kWh.keys()) ss_values_list = list(self.self_sufficiency.values()) sc_values_list = list(self.self_consumption.values()) energy_imp_values_list = list(self.import_kWh.values()) energy_exp_values_list = list(self.export_kWh.values()) last_fee_values_list = list(self.last_market_fee.values()) # Print None values as 0 ss_values_list = [0 if x is None else x for x in ss_values_list] sc_values_list = [0 if x is None else x for x in sc_values_list] energy_imp_values_list = [0 if x is None else x for x in energy_imp_values_list] energy_exp_values_list = [0 if x is None else x for x in energy_exp_values_list] last_fee_values_list = [0 if x is None else x for x in last_fee_values_list] last_market_table2.append([keys_list[i], ss_values_list[i], sc_values_list[i], energy_imp_values_list[i], energy_exp_values_list[i], last_fee_values_list[i]]) last_market_headers2 = [\"Markets\", \"Self sufficiency [%]\", \"Self consumption [%]\", \"Energy import [kWh]\", \"Energy export [kWh]\", \"Last fee [\u20accts/Kwh]\"] print(tabulate(last_market_table2, last_market_headers2, tablefmt=\"fancy_grid\")) In the next section, the script applies the grid fee depending on the fee strategy chosen here. If the Time of Use was set, the markets\u2019 grid fee is set based on the ToU excel file. If the Aziiz model was chosen the next fee is defined based on the Aziiz excel file. Additionally, if the peak import/export is higher than all threshold defined in the excel sheets this line sets the next fee as 2000cts/kWh. All the fees are added to the batch command and then executed. ################################################ # SET NEW GRID FEE ################################################ for area_uuid, area_dict in self.latest_grid_tree_flat.items(): if area_dict[\"area_name\"] in market_names: ################################################################### # TIME OF USE STRATEGY ################################################################### if TimeOfUse: self.next_market_fee[area_dict[\"area_name\"]] = self.scheduled_fee(self.market_time, planned_fee, area_dict[\"area_name\"]) ################################################################### # AZIIZ STRATEGY ################################################################### if Aziiz: if moving_average_peak: self.max_ext_energy_kWh = abs(self.balance_hist[area_dict[\"area_name\"]].iloc[ -look_back:].mean()) # Calculate the absolute moving average of the net balance by looking back at 4 markets else: self.max_ext_energy_kWh = max(self.import_kWh[area_dict[\"area_name\"]], self.export_kWh[ area_dict[ \"area_name\"]]) # Calculate the max between the import and export of the defined market individual_market_prices = pd.read_excel(market_prices, area_dict[\"area_name\"]) # Select the market in the file for k in range(len(individual_market_prices)): if self.max_ext_energy_kWh <= individual_market_prices[\"Threshold\"][k]: # if the peak is lower than this value, the following grid fee will be applied. If the max is higher, it will go to the lower elif condition self.next_market_fee[area_dict[\"area_name\"]] = individual_market_prices[\"Grid fee\"][ k] # new grid fee break else: self.next_market_fee[area_dict[ \"area_name\"]] = 2000 # TODO set the last value if all the previous ones are not fulfilled self.add_to_batch_commands.grid_fees(area_uuid=area_uuid,fee_cents_kwh=self.next_market_fee[area_dict[\"area_name\"]]) next_fee_response = self.execute_batch_commands() # send batch command In the following lines, the script is printing the current fee and next fee for each market. print() print('CURRENT AND NEXT MARKET FEES') current_market_table = [] for i in range(len(market_names)): keys_list = list(self.current_market_fee.keys()) current_fee_values_list = list(self.current_market_fee.values()) next_fee_values_list = list(self.next_market_fee.values()) current_fee_values_list = [0 if x is None else x for x in current_fee_values_list] next_fee_values_list = [0 if x is None else x for x in next_fee_values_list] current_market_table.append([keys_list[i], current_fee_values_list[i], next_fee_values_list[i]]) current_market_headers = [\"Markets\", \"Current fee [\u20accts/kWh]\", \"Next fee [\u20accts/kWh]\"] print(tabulate(current_market_table, current_market_headers, tablefmt=\"fancy_grid\")) Later, the on_event_or_response is overwritten. By default we do not perform any operation in this event but the user could add some if needed. For instance the user could record all the grid fee change responses received in that event. ################################################ # TRIGGERS EACH COMMAND RESPONSE AND EVENT ################################################ def on_event_or_response(self, message): # print(\"message\",message) pass Lastly, the SDK Script overwrites the on_finish event so that whenever the function is triggered the script stops. If the user wishes to save some information recorded within the Exchange SDK this would be the opportunity to export them to external files. ################################################ # SIMULATION TERMINATION CONDITION ################################################ def on_finish(self, finish_info): # TODO export relevant information stored during the simulation (if needed) self.is_finished = True The rest of the script is used to connect to a running simulation/collaboration/Canary Test Network. These lines should work as is and no changes are required. ################################################ # REGISTER FOR MARKETS ################################################ def get_assets_name(indict: dict) -> dict: \"\"\" This function is used to parse the grid tree and returned all registered assets wrapper for _get_assets_name \"\"\" if indict == {}: return {} outdict = {\"Area\": [], \"Load\": [], \"PV\": [], \"Storage\": []} _get_assets_name(indict, outdict) return outdict def _get_assets_name(indict: dict, outdict: dict): \"\"\" Parse the collaboration / Canary Network registry Returns a list of the Market, Load, PV and Storage nodes the user is registered to \"\"\" for key, value in indict.items(): if key == \"name\": name = value if key == \"type\": area_type = value if key == \"registered\" and value: outdict[area_type].append(name) if 'children' in key: for children in indict[key]: _get_assets_name(children, outdict) # Code to create the market aggregator and connect to the relevant simulation. Keep it as is if os.environ[\"API_CLIENT_RUN_ON_REDIS\"] == \"true\": MarketClient = RedisMarketClient market_args = {\"autoregister\": True} aggr = Oracle(aggregator_name=oracle_name) else: MarketClient = RestMarketClient simulation_id = os.environ[\"API_CLIENT_SIMULATION_ID\"] domain_name = os.environ[\"API_CLIENT_DOMAIN_NAME\"] websockets_domain_name = os.environ[\"API_CLIENT_WEBSOCKET_DOMAIN_NAME\"] market_args = {\"simulation_id\": simulation_id, \"domain_name\": domain_name, \"websockets_domain_name\": websockets_domain_name} aggr = Oracle(aggregator_name=oracle_name, **market_args) if automatic: registry = aggr.get_configuration_registry() market_names = get_assets_name(registry)[\"Area\"] market_prices, planned_fee = fee_strategy() print() print('Connecting to markets ...') for i in market_names: if os.environ[\"API_CLIENT_RUN_ON_REDIS\"] == \"true\": market_registered = RedisMarketClient(area_id=i) else: market_uuid = get_area_uuid_from_area_name_and_collaboration_id(market_args[\"simulation_id\"], i, market_args[\"domain_name\"]) market_args[\"area_id\"] = market_uuid market_registered = RestMarketClient(**market_args) selected = market_registered.select_aggregator(aggr.aggregator_uuid) print(\"----> Connected to \", i) sleep(0.3) print(aggr.device_uuid_list) # loop to allow persistence while not aggr.is_finished: sleep(0.5) For a video tutorial on the Grid Operator API, please follow this link . The next step is to adapt the Grid Operator API template script ) developed by Grid Singularity to customize the grid fee strategies as you wish!","title":"Script Configuration"},{"location":"home/","text":"Users can add homes/buildings to their community by selecting the custom home or one of the template home types. For the custom home the user has to manually add all assets, while the template home types have diverse assets included. The number of assets included in template homes can be seen in the individual listings. All template homes have at least one consumption profile by default, while some others also have PV generation profiles or batteries. For example, the template of a retired couple's home has 1 asset included, as shown in the Figure below. The 6-apartments building + PV template has 7 assets, including consumption profiles representing a 6-apartment building and a PV generation profile. Figure 2.6 . A selection of template home types A home functions as a market, where multiple assets can trade with each other or trade together as a single entity. The custom home has no assets included initially and it is suited for users who would prefer to configure the energy assets manually or upload their own energy data. The template homes are suitable for users who are interested in quickly building a prototype of an energy community using template data to represent the homes and assets. They can still add, remove or edit assets to assess the impact of different configurations. The template homes have been created using data from Load Profile Generator and Energy Data Map to represent the typical consumption and generation behaviour for different types of homes in an active energy community. Configuration options \u00b6 Homes can be configured using the express and advanced mode: Express Mode Name - Must be unique Geo-tag - This automatically uploads the location a user selects Advanced Mode Exchange Information; Users can choose between different market types where the market can clear bids and offers. At the moment only the spot market is available. Grid Fees - Users can choose to switch this on \u2705 or off \ud83c\udd87. If switched on, users can enter a constant grid fee value expressed in cents/kWh. This value will then function as a fee that will be applied to each trade that passes through or is cleared in this market. Transformer Capacity - Users can choose to switch this on \u2705 or off \ud83c\udd87. If switched on, users can choose import and export limits of the transformer in kVA. In the current implementation these limits are purely visual indicators and do not limit actual import/export of the market. Energy Peak Percentage - The energy peak imports/exports is the maximum value of the aggregate imports/exports of each asset inside a market. The user has the possibility to set a baseline_peak_energy_import_kWh and a baseline_peak_energy_export_kWh that they may have gotten from another simulation in order to calculate the energy peak percentage. The peak percentage is a tool used to measure how much the peak imports or exports have changed between a defined baseline and the current simulation. Users can choose to switch this on \u2705 or off \ud83c\udd87. If switched on, users can choose baseline peak import and export. These two values will be used for the calculation of the peak percentage . Figure 2.7 . Advanced Home Configuration Options","title":"Home"},{"location":"home/#configuration-options","text":"Homes can be configured using the express and advanced mode: Express Mode Name - Must be unique Geo-tag - This automatically uploads the location a user selects Advanced Mode Exchange Information; Users can choose between different market types where the market can clear bids and offers. At the moment only the spot market is available. Grid Fees - Users can choose to switch this on \u2705 or off \ud83c\udd87. If switched on, users can enter a constant grid fee value expressed in cents/kWh. This value will then function as a fee that will be applied to each trade that passes through or is cleared in this market. Transformer Capacity - Users can choose to switch this on \u2705 or off \ud83c\udd87. If switched on, users can choose import and export limits of the transformer in kVA. In the current implementation these limits are purely visual indicators and do not limit actual import/export of the market. Energy Peak Percentage - The energy peak imports/exports is the maximum value of the aggregate imports/exports of each asset inside a market. The user has the possibility to set a baseline_peak_energy_import_kWh and a baseline_peak_energy_export_kWh that they may have gotten from another simulation in order to calculate the energy peak percentage. The peak percentage is a tool used to measure how much the peak imports or exports have changed between a defined baseline and the current simulation. Users can choose to switch this on \u2705 or off \ud83c\udd87. If switched on, users can choose baseline peak import and export. These two values will be used for the calculation of the peak percentage . Figure 2.7 . Advanced Home Configuration Options","title":"Configuration options"},{"location":"implement-grid-fees-walkthrough/","text":"The Grid Singularity Grid Operator API is designed for grid operators (notably Distribution System Operators or DSOs) to manage congestion and grid constraints in different markets across the grid. The structure is designed so that multiple markets can be managed by a single agent (digital representation of the grid operator preferences), allowing information to be aggregated for integrated grid management. It allows users to create agents that can dynamically change the grid fee in different markets. These agents can request and receive information through the Grid Operator API, feed that information into a tariff model, and submit grid fees through the Exchange SDK to change grid fees on the exchange. For more information, see this article . To actively manage grid congestion by sending new grid fees at every market slot for different markets at different levels of the grid, please follow the following steps: Install the Grid Singularity Exchange SDK on your computer by launching the following commands on your terminal window: Install gsy-e-sdk mkvirtualenv gsy-e-sdk pip install https://github.com/gridsingularity/gsy-e-sdk.git Update gsy-e-sdk (needed when an update is deployed) pip uninstall -y gsy-e-sdk pip install git+https://github.com/gridsingularity/gsy-e-sdk.git Install the following Python packages pip install pandas pip install openpyxl Go to the Registry and Scoreboard section of the Collaboration of your interest and apply to every market that you wish to connect and to actively manage by sending new grid fees for each market slot. Then click on Submit your actions . If you have not already created a Collaboration / Canary Test Network, please follow instructions respectively here or here first. Notify Grid Singularity administration by sending an email to contact@gridsingularity.com to accept your applications) (note: this action will be automated in the future). Edit the Grid Operator SDK Script template to experiment with different grid fee models. Launch the Grid Operator SDK Script to connect with the Grid Singularity Collaboration / Canary Test Network. A video tutorial is also available here . Run the Collaboration or notify the collaboration owner that you are ready.","title":"Walkthrough"},{"location":"ios-installation-instructions/","text":"Step 1: Installation prerequisites: \u00b6 make sure the command line compiler tools are installed: \u00b6 xcode-select --install (Select Install in the window that opens) Step 2: Install homebrew \u00b6 /usr/bin/ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\" Step 3: Install other required libraries: \u00b6 brew install automake libtool pkg-config libffi gmp openssl readline xz Step 4: Install pyenv: \u00b6 brew install pyenv echo -e 'if command -v pyenv 1>/dev/null 2>&1; then\\n eval \"$(pyenv init -)\"\\nfi' >> ~/.bash_profile Step 5: Close and re-open the terminal \u00b6 Step 6: Install python 3.6 and set as default: \u00b6 pyenv install 3.8.6 pyenv global 3.8.6 Step 7: Install virtualenvwrapper: \u00b6 pip install virtualenvwrapper echo -e 'export WORKON_HOME=~/Envs\\nsource ~/.pyenv/versions/3.8.6/bin/virtualenvwrapper.sh' >> ~/.bash_profile Step 8: Setup paths for compiling python libraries: \u00b6 echo -e 'BREW_PREFIX=\"$(brew --prefix openssl)\"\\nexport CFLAGS=\"-I${BREW_PREFIX}/include\"\\nexport LDFLAGS=\"-L${BREW_PREFIX}/lib\"' >> ~/.bash_profile Step 9: Close and re-open the terminal \u00b6 Step 10: Clone gsy-e repository (do this inside the directory where you want the project to be): \u00b6 git clone \"https://github.com/gridsingularity/gsy-e.git\" cd gsy-e Step 11: Create and initialise gsy-e virtualenv \u00b6 brew install npm npm install --global ganache-cli mkvirtualenv gsy-e pip install pendulum pip-tools pip install -e . You now should have a working gsy-e setup. For help in the terminal ani to test your installation, run gsy-e run -\u2013help .","title":"Mac Installation Instructions"},{"location":"ios-installation-instructions/#step-1-installation-prerequisites","text":"","title":"Step 1: Installation prerequisites:"},{"location":"ios-installation-instructions/#make-sure-the-command-line-compiler-tools-are-installed","text":"xcode-select --install (Select Install in the window that opens)","title":"make sure the command line compiler tools are installed:"},{"location":"ios-installation-instructions/#step-2-install-homebrew","text":"/usr/bin/ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\"","title":"Step 2: Install homebrew"},{"location":"ios-installation-instructions/#step-3-install-other-required-libraries","text":"brew install automake libtool pkg-config libffi gmp openssl readline xz","title":"Step 3: Install other required libraries:"},{"location":"ios-installation-instructions/#step-4-install-pyenv","text":"brew install pyenv echo -e 'if command -v pyenv 1>/dev/null 2>&1; then\\n eval \"$(pyenv init -)\"\\nfi' >> ~/.bash_profile","title":"Step 4: Install pyenv:"},{"location":"ios-installation-instructions/#step-5-close-and-re-open-the-terminal","text":"","title":"Step 5: Close and re-open the terminal"},{"location":"ios-installation-instructions/#step-6-install-python-36-and-set-as-default","text":"pyenv install 3.8.6 pyenv global 3.8.6","title":"Step 6: Install python 3.6 and set as default:"},{"location":"ios-installation-instructions/#step-7-install-virtualenvwrapper","text":"pip install virtualenvwrapper echo -e 'export WORKON_HOME=~/Envs\\nsource ~/.pyenv/versions/3.8.6/bin/virtualenvwrapper.sh' >> ~/.bash_profile","title":"Step 7: Install virtualenvwrapper:"},{"location":"ios-installation-instructions/#step-8-setup-paths-for-compiling-python-libraries","text":"echo -e 'BREW_PREFIX=\"$(brew --prefix openssl)\"\\nexport CFLAGS=\"-I${BREW_PREFIX}/include\"\\nexport LDFLAGS=\"-L${BREW_PREFIX}/lib\"' >> ~/.bash_profile","title":"Step 8: Setup paths for compiling python libraries:"},{"location":"ios-installation-instructions/#step-9-close-and-re-open-the-terminal","text":"","title":"Step 9: Close and re-open the terminal"},{"location":"ios-installation-instructions/#step-10-clone-gsy-e-repository-do-this-inside-the-directory-where-you-want-the-project-to-be","text":"git clone \"https://github.com/gridsingularity/gsy-e.git\" cd gsy-e","title":"Step 10: Clone gsy-e repository (do this inside the directory where you want the project to be):"},{"location":"ios-installation-instructions/#step-11-create-and-initialise-gsy-e-virtualenv","text":"brew install npm npm install --global ganache-cli mkvirtualenv gsy-e pip install pendulum pip-tools pip install -e . You now should have a working gsy-e setup. For help in the terminal ani to test your installation, run gsy-e run -\u2013help .","title":"Step 11: Create and initialise gsy-e virtualenv"},{"location":"library/","text":"Libraries contain preconfigured energy assets, markets, and even small grids that can be reused in different simulations (e.g. loads, PVs, houses and even entire communities). The list of libraries is paginated. You can either click through the pages by pressing the Prev or Next button in the bottom right corner or use the search field in the top right corner to filter the list by the library names. The following buttons and labels can be seen in the Library page: Denotes public libraries (other users can see the Library and the uploaded profiles): & (in the search bar) Quicklook labels for showing type and number of assets and the number of markets in the library: With this button the user can edit library content or view public libraries: With this button the user can rename, duplicate or delete an existing library (only user\u2019s own library may be deleted): The user can also create a new library (button redirects to Grid setup ):","title":"Library"},{"location":"licensing/","text":"Grid Singularity\u2019s software is available under an open source GNU General Public License . We believe that disruptive innovation yields new solutions to bring about the energy transition and can only be achieved by an open source community. The GPLv.3 license protects our code in a way that anyone who wishes to pursue proprietary commercialisation of the software would need to apply for a license, while open source applications supporting sustainable development continue to be free.","title":"Licensing and Open Source Ethos"},{"location":"linux-installation-instructions/","text":"Installing Grid Singularity Exchange on Linux Ubuntu 18.04: \u00b6 Step 1: In case you have not already installed git, python3.8 and pip (otherwise please go directly to step 2): \u00b6 sudo apt-get update sudo apt-get install git-core software-properties-common -y sudo add-apt-repository ppa:deadsnakes/ppa sudo apt-get update sudo apt-get install python3.8 -y sudo apt-get install git-core -y sudo apt-get install python3-pip -y Step 2: Install virtualenv and create a python virtual environment \u00b6 pip3 install virtualenv mkdir envs cd envs virtualenv -p /usr/bin/python3.8 gsy-e How to activate the environment: \u00b6 source gsy-e/bin/activate How to deactivate the environment: \u00b6 deactivate Step 3: Please add the following lines to your .bashrc and reopen the shell: \u00b6 export LC_ALL=C.UTF-8 export LANG=C.UTF-8 Step 4: Clone the Grid Singularity Exchange repository, gsy-e, to a directory of your choice: \u00b6 git clone https://github.com/gridsingularity/gsy-e.git Step 5: Install \u00b6 Activate your virtual environment and go into the d3a repository \u00b6 source gsy-e/bin/activate Install pip-tools \u00b6 pip3 install pendulum pip-tools Install dependencies \u00b6 pip install -e. Now, if you run gsy-e run -\u2013help , the help of gsy-e should be shown. Installing Grid Singularity Exchange on Linux Ubuntu 20.04: \u00b6 Please follow the installation instructions for Ubuntu 18.04. In case you encounter the following error: error: command 'x86_64-linux-gnu-gcc' failed with exit status 1 please install the following package: sudo apt-get install build-essential python3.8-dev -y","title":"Linux Installation Instructions"},{"location":"linux-installation-instructions/#installing-grid-singularity-exchange-on-linux-ubuntu-1804","text":"","title":"Installing Grid Singularity Exchange on Linux Ubuntu 18.04:"},{"location":"linux-installation-instructions/#step-1-in-case-you-have-not-already-installed-git-python38-and-pip-otherwise-please-go-directly-to-step-2","text":"sudo apt-get update sudo apt-get install git-core software-properties-common -y sudo add-apt-repository ppa:deadsnakes/ppa sudo apt-get update sudo apt-get install python3.8 -y sudo apt-get install git-core -y sudo apt-get install python3-pip -y","title":"Step 1: In case you have not already installed git, python3.8 and pip (otherwise please go directly to step 2):"},{"location":"linux-installation-instructions/#step-2-install-virtualenv-and-create-a-python-virtual-environment","text":"pip3 install virtualenv mkdir envs cd envs virtualenv -p /usr/bin/python3.8 gsy-e","title":"Step 2: Install virtualenv and create a python virtual environment"},{"location":"linux-installation-instructions/#how-to-activate-the-environment","text":"source gsy-e/bin/activate","title":"How to activate the environment:"},{"location":"linux-installation-instructions/#how-to-deactivate-the-environment","text":"deactivate","title":"How to deactivate the environment:"},{"location":"linux-installation-instructions/#step-3-please-add-the-following-lines-to-your-bashrc-and-reopen-the-shell","text":"export LC_ALL=C.UTF-8 export LANG=C.UTF-8","title":"Step 3: Please add the following lines to your .bashrc and reopen the shell:"},{"location":"linux-installation-instructions/#step-4-clone-the-grid-singularity-exchange-repository-gsy-e-to-a-directory-of-your-choice","text":"git clone https://github.com/gridsingularity/gsy-e.git","title":"Step 4: Clone the Grid Singularity Exchange repository, gsy-e, to a directory of your choice:"},{"location":"linux-installation-instructions/#step-5-install","text":"","title":"Step 5: Install"},{"location":"linux-installation-instructions/#activate-your-virtual-environment-and-go-into-the-d3a-repository","text":"source gsy-e/bin/activate","title":"Activate your virtual environment and go into the d3a repository"},{"location":"linux-installation-instructions/#install-pip-tools","text":"pip3 install pendulum pip-tools","title":"Install pip-tools"},{"location":"linux-installation-instructions/#install-dependencies","text":"pip install -e. Now, if you run gsy-e run -\u2013help , the help of gsy-e should be shown.","title":"Install dependencies"},{"location":"linux-installation-instructions/#installing-grid-singularity-exchange-on-linux-ubuntu-2004","text":"Please follow the installation instructions for Ubuntu 18.04. In case you encounter the following error: error: command 'x86_64-linux-gnu-gcc' failed with exit status 1 please install the following package: sudo apt-get install build-essential python3.8-dev -y","title":"Installing Grid Singularity Exchange on Linux Ubuntu 20.04:"},{"location":"map/","text":"In the User Interface , each energy asset and market can be pinned on a map with geographic coordinates in the form of a geotag, linked to a physical address . If a geotag is set at the market level, all submarkets and their assets are tied to these coordinates. In this example, Neuk\u00f6ln market includes all submarkets and assets under the same geotag (House 1, House 2, PV 4, Market and PV 5). If a market geo-tag type is set to location , the market can be pinned on the map and all of its submarkets and assets will inherit the same location: In this example, House 2\u2019s assets are assigned the same location as the House 2 submarket. Once the user has added locations via geotags for its markets and energy assets, the simulation will be shown on the Grid Singularity\u2019s public map, which will disclose the location of the simulation\u2019s highest market and the total number of markets and energy assets. For a video tutorial on the map feature, please follow this link .","title":"Map"},{"location":"market-agent/","text":"The MarketAgent (MA) plays a crucial role in the communication architecture of Grid Singularity\u2019s exchange, allowing different markets in the hierarchy to interact and trade with each other. The MarketAgent is created for each market (households/buildings, streets, etc. that do not have preset trading strategies) and mainly deals with forwarding bids and offers markets of different hierarchy levels. The following illustration shows a sample grid setup and the role of the MarketAgent in the market hierarchy during one time slot: Figure 3.12 . The MarketAgent and bids / offers propagation in the Grid Singularity Exchange. The MA is responsible for modelling hierarchical market operations, as follows: Forwarding bids and offers from a lower hierarchy (market) to an upper hierarchy. Reacting to bids, offers and trades reported by MAs in connected markets, in order to propagate the event for an offer/bid that has been forwarded from this MA. Triggering the matching of bids and offers for the two-sided market. To prioritize local trades, MAs forward bids and offers to higher/lower markets with a two-tick delay.","title":"Bids/Offers Process and Hierarchical Market Structure"},{"location":"market-backend-configuration/","text":"These parameters can be set in the backend in the Market class : Market('Market', [ ... \"some assets here\" ], grid_fee_constant=2, throughput=ThroughputParameters(import_capacity_kVA=2.0, export_capacity_kVA=2.0, baseline_peak_energy_import_kWh=0.4, baseline_peak_energy_export_kWh=0.4))","title":"Market Backend Configuration"},{"location":"market-types/","text":"The main goal of an electricity market exchange is to balance the grid in terms of demand and supply. Since efficient storage of large quantities of energy is currently not economically feasible and electrical current varies within seconds, a market mechanism that efficiently accounts for the physical energy production and consumption is required. Generally, trading occurs in three types of markets with different time intervals: Spot market : short-term trades for immediate or near-term delivery. Energy transactions are divided into small time blocks (typically 15 minute slots) that can either be traded on the Day-ahead or in the Intraday market. Balancing market : balancing capacity and reserves purchased by the balancing responsible parties (BRP) or other local balancing agents to be deployed for future grid imbalances. Settlement market : post-delivery trades of deviations between energy physically produced/consumed and energy purchased in the spot or futures market to settle imbalances locally before BRP billing. Futures market : Trades for the longer term future consumption and production of energy are agreed in advance. This market is currently in development of Grid Singularity energy exchange implementation. Figure 3.1 . Market Types implemented in Grid Singularity Exchange. Market Slots \u00b6 The energy spot market is broken into time slots, with the default set to 15 minutes of simulated time. For a one-day simulation, 96 market slots would occur with the default setting. Learn how to adjust market slot length here . Depending on the market type, bids and offers are either matched within or at the end of each slot. Bids and offers that remain unmatched at the end of a market slot are annulled, and assets may be penalised for any energy they physically produce or consume that is not transacted for. Market Ticks \u00b6 Each slot is further segmented into ticks. The default setting for a tick is 15 seconds of simulated time (simulated time is the time unit within a simulation as opposed to real-time which is the real-life time that the simulation takes; e.g. a simulation can simulate 7 days of trading in minutes or hours), and this configuration may be changed. The default 15 minute market slot is made up of 60 15-second ticks. In a pay-as-bid market, for instance, the market is cleared at the end of each tick. If an order is not matched, it is propagated to all adjacent markets by a MarketAgent after two ticks (explained in more detail below ). If an order is not matched at the end of two next ticks, it is further propagated to connected markets in the subsequent ticks following the same logic. The current implementation of Grid Singularity exchange currently focuses on the spot and balancing markets. Balancing markets take place immediately after each spot market slot (if enabled). The duration of the markets can be configured.","title":"Overview"},{"location":"market-types/#market-slots","text":"The energy spot market is broken into time slots, with the default set to 15 minutes of simulated time. For a one-day simulation, 96 market slots would occur with the default setting. Learn how to adjust market slot length here . Depending on the market type, bids and offers are either matched within or at the end of each slot. Bids and offers that remain unmatched at the end of a market slot are annulled, and assets may be penalised for any energy they physically produce or consume that is not transacted for.","title":"Market Slots"},{"location":"market-types/#market-ticks","text":"Each slot is further segmented into ticks. The default setting for a tick is 15 seconds of simulated time (simulated time is the time unit within a simulation as opposed to real-time which is the real-life time that the simulation takes; e.g. a simulation can simulate 7 days of trading in minutes or hours), and this configuration may be changed. The default 15 minute market slot is made up of 60 15-second ticks. In a pay-as-bid market, for instance, the market is cleared at the end of each tick. If an order is not matched, it is propagated to all adjacent markets by a MarketAgent after two ticks (explained in more detail below ). If an order is not matched at the end of two next ticks, it is further propagated to connected markets in the subsequent ticks following the same logic. The current implementation of Grid Singularity exchange currently focuses on the spot and balancing markets. Balancing markets take place immediately after each spot market slot (if enabled). The duration of the markets can be configured.","title":"Market Ticks"},{"location":"markets-rotation/","text":"If ConstSettings.SettlementMarketSettings.ENABLE_SETTLEMENT_MARKETS is set to True, settlement markets are created on each market cycle. For each past spot market, there is always a respective settlement market. The settlement markets are kept open for placing bids and offers for the amount of hours the user sets with Const.Settings.SettlementMarketSettings.MAX_AGE_SETTLEMENT_MARKET_HOURS . In contrast to a normal simulation run, the past slot markets are also kept in memory for the same amount of time in order to generate live results including past markets and the settlement markets. Only one past settlement market is kept in memory. This is also only for keeping track of the statistics, no offers and bids can be placed there. Figure 3.9 . Example of settlement markets available for each market slot and their rotation.","title":"Markets and rotation"},{"location":"markets/","text":"The main goal of an electricity market exchange is to balance the grid in terms of demand and supply. Since efficient storage of large quantities of energy is currently not economically feasible and electrical current varies within seconds, a market mechanism that efficiently accounts for the physical energy production and consumption is required. Generally, trading occurs in three types of markets with different time intervals: Spot market : short-term trades for immediate or near-term delivery. Energy transactions are divided into small time blocks (typically 15 minute slots) that can either be traded on the Day-ahead or in the Intraday market. Balancing market : imbalances that occur due to deviations between energy traded in the spot market and actual energy consumption and production are absorbed by balance responsible parties (BRP) that are reimbursed for their service with a fee based on the energy deviation. Futures market : trades for the longer term future consumption and production of energy are agreed in advance. This market is currently outside the scope of Grid Singularity energy exchange implementation. The current implementation of Grid Singularity software focuses on the spot and balancing markets. Balancing markets take place immediately after each spot market slot (if enabled). The duration of the markets can be configured. Currently, three spot market types are implemented: One-sided Pay-as-Offer Two-sided Pay-as-Bid Two-sided Pay-as-Clear Market Slots \u00b6 The energy spot market is broken into time slots, with the default set to 15 minutes of simulated time. For a one-day simulation, 96 market slots would occur with the default setting. Learn how to adjust market slot length here . Depending on the market type, bids and offers are either matched within or at the end of each slot. Bids and offers that remain unmatched at the end of a market slot are annulled, and assets may be penalised for any energy they physically produce or consume that is not transacted for. Market Ticks \u00b6 Each slot is further segmented into ticks. The default setting for a tick is 15 seconds of simulated time (simulated time is the time unit within a simulation as opposed to real-time which is the real-life time that the simulation takes; e.g. a simulation can simulate 7 days of trading in minutes or hours), and this configuration may be changed. The default 15 minute market slot is made up of 60 15-second ticks. In a pay-as-bid market, the market is cleared at the end of each tick. If an order is not matched, it is propagated to all adjacent markets by an Inter-Area Agent after two ticks. If an order is not matched at the end of two next ticks, it is further propagated to connected markets in the subsequent ticks following the same logic.","title":"Markets"},{"location":"markets/#market-slots","text":"The energy spot market is broken into time slots, with the default set to 15 minutes of simulated time. For a one-day simulation, 96 market slots would occur with the default setting. Learn how to adjust market slot length here . Depending on the market type, bids and offers are either matched within or at the end of each slot. Bids and offers that remain unmatched at the end of a market slot are annulled, and assets may be penalised for any energy they physically produce or consume that is not transacted for.","title":"Market Slots"},{"location":"markets/#market-ticks","text":"Each slot is further segmented into ticks. The default setting for a tick is 15 seconds of simulated time (simulated time is the time unit within a simulation as opposed to real-time which is the real-life time that the simulation takes; e.g. a simulation can simulate 7 days of trading in minutes or hours), and this configuration may be changed. The default 15 minute market slot is made up of 60 15-second ticks. In a pay-as-bid market, the market is cleared at the end of each tick. If an order is not matched, it is propagated to all adjacent markets by an Inter-Area Agent after two ticks. If an order is not matched at the end of two next ticks, it is further propagated to connected markets in the subsequent ticks following the same logic.","title":"Market Ticks"},{"location":"matching-api-commands/","text":"The Matching API is responsible for communicating with a running local simulation of the Grid Singularity Exchange. The client uses the Matching API to dynamically connect to the simulated electrical grid and query the open bids/offers and post-trading recommendations back to Grid Singularity Exchange. request_offers_bids() \u00b6 This command is used to request bids and offers from a specific market or family of markets, that can be specified through the filters dictionary and it is the output of the on_area_map_response method above explained. self.request_offers_bids(filters={\u201cmarkets: self.id_list})","title":"Matching API Commands"},{"location":"matching-api-commands/#request_offers_bids","text":"This command is used to request bids and offers from a specific market or family of markets, that can be specified through the filters dictionary and it is the output of the on_area_map_response method above explained. self.request_offers_bids(filters={\u201cmarkets: self.id_list})","title":"request_offers_bids()"},{"location":"matching-api-events/","text":"In the Matching API, seven event types are triggered while a simulation is running. To facilitate offer and bid requests and clearing, the client will get notified via events. It is possible to capture these events and react to them by overriding the corresponding methods. Each new market slot \u00b6 def on_market_cycle(self, data): The method on_market_cycle is triggered at the start of every market slot. On % of market completion \u00b6 def on_tick(self, data): The method on_tick is called when a new tick is started, at each 1-2% of the market slot completion. It fires a request to get all open bids and offers posted on the exchange. The response can be received in the method named on_offers_bids_response. On offers bids response \u00b6 def on_offers_bids_response(self, data): The method on_offers_bids_response is triggered when open offers/bids responses are returned. The data dictionary received from the exchange contains information on all open bids/offers posted. The structure is shown below: {'8f7b7e7b-0f4a-490b-853f-6017af84ef60': {\u20182021-12-20T00:00\u2019: {'bids': [{'type': 'Bid', 'id': '5934bfff-43c6-4870-8f1f-52bb8374a1f9', 'energy': 0.05, 'energy_rate': 2.5, 'original_price': 0.125, \u2018creation_time\u2019: \u20182021-12-20T00.00:25\u2019, \u2018time_slot\u2019: \u20182021-12-20T00:00\u2019, \u2018attributes\u2019: None, \u2018requirements\u2019: None, 'buyer_origin': 'load', 'buyer_origin_id': 'fcbe2390-5bcf-4cbd-b4f4-7c6d44fda34f', 'buyer_id': 'fcbe2390-5bcf-4cbd-b4f4-7c6d44fda34f', 'buyer': 'load'}], 'offers': [{'type': 'Offer', 'id': 'c4b10dd5-eb5f-4807-859a-9b6a0592a21c', 'energy': 1.25, 'energy_rate': 29.64285714288, 'original_price': 37.0535714286, \u2018creation_time\u2019: \u20182021-12-20T00.00:25\u2019, \u2018time_slot\u2019: \u20182021-12-20T00:00\u2019, \u2018attributes\u2019: None, \u2018requirements\u2019: None, 'seller': 'IAA House 2', 'seller_origin': 'H1 Storage1', 'seller_origin_id': 'e9faeda1-ce20-4789-b61c-61559a95f9fb', 'seller_id': 'a4403967-3e47-4d47-8c63-b5145d6c1e42'} ]}]}} where '8f7b7e7b-0f4a-490b-853f-6017af84ef60' refers to a unique identifier of both the market slot and the market in which the corresponding bids / offers have been posted. On matched recommendations response \u00b6 def on_matched_recommendations_response(self, data): When the myco client sends trades recommendations, this function is triggered and a response is passed through the data dictionary. On area map response \u00b6 def on_area_map_response(self, data): This method is triggered once at the beginning of the simulation and it is used to build the list of market IDs from which the user wants to request bids and offers from through the request_offers_bids() command, as explained here . On event or response \u00b6 def on_event_or_response(self, data): Each time an event arrives or any response (from sending a batch of recommendations) is triggered, this information is passed through on_event_or_response. On finish \u00b6 def on_finish(self, data): This executes when the simulation ends and can be used to trigger exporting data, training a model or exiting the code.","title":"Matching API Events"},{"location":"matching-api-events/#each-new-market-slot","text":"def on_market_cycle(self, data): The method on_market_cycle is triggered at the start of every market slot.","title":"Each new market slot"},{"location":"matching-api-events/#on-of-market-completion","text":"def on_tick(self, data): The method on_tick is called when a new tick is started, at each 1-2% of the market slot completion. It fires a request to get all open bids and offers posted on the exchange. The response can be received in the method named on_offers_bids_response.","title":"On % of market completion"},{"location":"matching-api-events/#on-offers-bids-response","text":"def on_offers_bids_response(self, data): The method on_offers_bids_response is triggered when open offers/bids responses are returned. The data dictionary received from the exchange contains information on all open bids/offers posted. The structure is shown below: {'8f7b7e7b-0f4a-490b-853f-6017af84ef60': {\u20182021-12-20T00:00\u2019: {'bids': [{'type': 'Bid', 'id': '5934bfff-43c6-4870-8f1f-52bb8374a1f9', 'energy': 0.05, 'energy_rate': 2.5, 'original_price': 0.125, \u2018creation_time\u2019: \u20182021-12-20T00.00:25\u2019, \u2018time_slot\u2019: \u20182021-12-20T00:00\u2019, \u2018attributes\u2019: None, \u2018requirements\u2019: None, 'buyer_origin': 'load', 'buyer_origin_id': 'fcbe2390-5bcf-4cbd-b4f4-7c6d44fda34f', 'buyer_id': 'fcbe2390-5bcf-4cbd-b4f4-7c6d44fda34f', 'buyer': 'load'}], 'offers': [{'type': 'Offer', 'id': 'c4b10dd5-eb5f-4807-859a-9b6a0592a21c', 'energy': 1.25, 'energy_rate': 29.64285714288, 'original_price': 37.0535714286, \u2018creation_time\u2019: \u20182021-12-20T00.00:25\u2019, \u2018time_slot\u2019: \u20182021-12-20T00:00\u2019, \u2018attributes\u2019: None, \u2018requirements\u2019: None, 'seller': 'IAA House 2', 'seller_origin': 'H1 Storage1', 'seller_origin_id': 'e9faeda1-ce20-4789-b61c-61559a95f9fb', 'seller_id': 'a4403967-3e47-4d47-8c63-b5145d6c1e42'} ]}]}} where '8f7b7e7b-0f4a-490b-853f-6017af84ef60' refers to a unique identifier of both the market slot and the market in which the corresponding bids / offers have been posted.","title":"On offers bids response"},{"location":"matching-api-events/#on-matched-recommendations-response","text":"def on_matched_recommendations_response(self, data): When the myco client sends trades recommendations, this function is triggered and a response is passed through the data dictionary.","title":"On matched recommendations response"},{"location":"matching-api-events/#on-area-map-response","text":"def on_area_map_response(self, data): This method is triggered once at the beginning of the simulation and it is used to build the list of market IDs from which the user wants to request bids and offers from through the request_offers_bids() command, as explained here .","title":"On area map response"},{"location":"matching-api-events/#on-event-or-response","text":"def on_event_or_response(self, data): Each time an event arrives or any response (from sending a batch of recommendations) is triggered, this information is passed through on_event_or_response.","title":"On event or response"},{"location":"matching-api-events/#on-finish","text":"def on_finish(self, data): This executes when the simulation ends and can be used to trigger exporting data, training a model or exiting the code.","title":"On finish"},{"location":"matching-api-template-script/","text":"A Matching API template script is available here . See the TODO flags there connect to your preferred customized clearing algorithm and to request, if desired, bids and offers from specific markets. At the beginning of the Matching API script, the MycoMatcher class is defined as well as the on_area_map_response method, which allows the users to define the list of markets from which they want to request bids and offers from. class MycoMatcher(base_matcher): def __init__(self, *args, **kwargs): super().__init__(*args, **kwargs) self.is_finished = False self.request_area_id_name_map() def on_area_map_response(self, data): self.id_list = [] market_list = [\"Community\"] for market in market_list: for market_id, name in data[\"area_mapping\"].items(): if name == market: self.id_list.append(market_id) Right after, the on_market_cyce and the on_tick methods are triggered. In the latter, the user requests bids / offers from the market. def on_market_cycle(self, data): pass def on_tick(self, data): self.request_offers_bids(filters={}) In the next section, the bids/offers that had been previously requested from the market are stored in the matching_data variable. The matching algorithm ( AttributedMatchingAlgorithm in the example here) takes those data as input and outputs a list of recommendations. Each recommendation is a nested dictionary with the following structure: [{'market_id': '0fd481d9-98af-43cd-9e98-196c1fe9877f', 'time_slot': '2021-12-20T00:15', 'bids': [{'type': 'Bid', 'id': '6d71f933-0474-4cd8-baa4-97a1f01553c5', 'energy': 0.05, 'energy_rate': 22.5, 'original_price': 1.125, 'creation_time': '2021-12-20T00:24:00', 'time_slot': '2021-12-20T00:15:00', 'attributes': None, 'requirements': None, 'buyer_origin': 'H2 General Load1', 'buyer_origin_id': 'd5133b0b-5c06-4cc8-aaaa-317756659695', 'buyer_id': 'd5133b0b-5c06-4cc8-aaaa-317756659695', 'buyer': 'H2 General Load1'}], 'offers': [{'type': 'Offer', 'id': '7760bf1d-ddad-47bb-a2ea-7067ea177c07', 'energy': 9223372036854775807, 'energy_rate': 22.0, 'original_price': 2.0291418481080507e+20, 'creation_time': '2021-12-20T00:15:25', 'time_slot': '2021-12-20T00:15:00', 'attributes': None, 'requirements': None, 'seller': 'MA House 2', 'seller_origin': 'Market Maker', 'seller_origin_id': '4493f3ce-eece-4386-8fc1-e715cf32b85f', 'seller_id': '0fd481d9-98af-43cd-9e98-196c1fe9877f'}], 'selected_energy': 0.05, 'trade_rate': 22.5, 'matching_requirements': None}] The matching algorithm can be written as a separate class file and can be referenced in the on_offers_bids_response function as: recommendations = YourMatchingAlgorithm.get_matches_recommendations( matching_data) At the moment, there are 3 default matching algorithms available to use and to build upon: Pay as Bid algorithm - this clears markets continuously during the market slot following this strategy ; Pay as Clear algorithm - this clears markets by ordering bids and offers and defining a single clearing price, following this strategy ; Attributed matching algorithm - this follows the same logic as the Pay-as-Bid clearing but takes into account degrees of freedom such as attributes and requirements (listed as dictionaries for bids and offers): Attributes - \u201cenergy type\u201d, currently implemented only for offers (e.g. \u201cgreen\u201d energy) Requirements - \u201ctrading partners\u201d implemented for offers and \u201cenergy type\u201d, \u201ctrading partners\u201d, \u201cenergy\u201d, and \u201cprice\u201d implemented for bids. def on_offers_bids_response(self, data): matching_data = data.get(\"bids_offers\") if not matching_data: return recommendations = AttributedMatchingAlgorithm.get_matches_recommendations( matching_data) if recommendations: logging.info(\"Submitting %s recommendations.\", len(recommendations)) self.submit_matches(recommendations) Later in the script, the on_matched_recommendations_response is triggered and useful information about the recommendation posted, such as seller, buyer, trading price and energy as well as the status, if successful or not, are printed in the terminal window of the user. Later, the on_event_or_response is overwritten. By default we do not perform any operation in this event but the user could add some if needed. def on_matched_recommendations_response(self, data): pass def on_event_or_response(self, data): logging.debug(\"Event arrived %s\", data) Lastly, the Matching API Script overwrites the on_finish event so that whenever the function is triggered the script stops. If the user wishes to save some information recorded within the Myco SDK this would be the opportunity to export them to external files. def on_finish(self, data): self.is_finished = True","title":"Matching API Template Script"},{"location":"matching-api-walkthrough/","text":"The Grid Singularity Matching Application Programming Interface (or Matching API) allows custom matching algorithms to be used to clear orders in local energy exchanges. The Matching API decouples the matching process from the exchange, allowing external algorithm providers (also termed mycos here) to read the exchange\u2019s order book, run custom matching algorithms and send the resulting energy transactions to be verified and executed by the exchange, as shown in Figure 4 and explained below. Figure 4 . Flow diagram of the role of mycos (third party matching algorithm providers) in the Grid Singularity Exchange. Trading process through the Matching API: Bids and Offers creation - Bids and Offers are created on behalf of the energy assets (either by using the default GSy trading strategy or through the Asset API ) and sent to the exchange. Order book - The exchange gathers the bids and offers for all the different markets, which are currently organized in a hierarchical structure . Request Bids and Offers - The Matching API requests bids and offers for specific markets , and receives a dictionary containing all bids and offers posted in the chosen markets. Matching - The Matching API pairs bids and offers together according to an external matching algorithm provided by a third-party matching algorithm provider and sends the proposed bid/offer pairs (technically called recommendations ) back to the exchange. Verification function - Each recommendation is submitted to the exchange\u2019s verification function, a mechanism that checks whether the clearing rate and the energy to be traded proposed by the recommendation respect the bids and offers\u2019 attributes and requirements . Transactions and rejections - Recommended matches that pass the verification function\u2019s check will be submitted as transactions in the Grid Singularity exchange. Recommendations rejected by the verification function will trigger a notification through the Matching API and not be sent to the exchange for clearing. It is important to note that the Matching API is asynchronous towards the exchange, meaning that it can request bids and offers and send recommendations at any time during the market slots . To decouple the bids / offers matching mechanism from the exchange and to develop your customised clearing algorithm, please follow the following steps: Install the Grid Singularity Myco SDK on your computer by launching the following commands on your terminal window: Install gsy-e-sdk mkvirtualenv gsy-myco-sdk pip install https://github.com/gridsingularity/gsy-myco-sdk.git Update gsy-myco-sdk (needed when an update is deployed) pip uninstall -y gsy-myco-sdk pip install git+https://github.com/gridsingularity/gsy-myco-sdk.git Edit the Matching API template script to connect with your customised matching algorithm. Launch the Matching API script in a local (backend) simulation. Currently, it is not possible to connect the Matching API through a Collaboration / Canary Network.","title":"Walkthrough"},{"location":"model-load/","text":"The load is an energy asset that consumes energy over time. It is possible to use a single load to represent an entire consuming building, as well as to configure multiple loads to represent different assets within a building (e.g. washing machine, air-conditioner, etc.). User Interface Configuration \u00b6 The following parameters can be configured: Load name : Must be unique Load profile : The user can choose between two options: User upload profile (a load profile can be uploaded when compliant with Upload File Formats) User configure profile (the user provides the load average power) Average power : average consuming power of the load in Watts. Hours per day : The number of hours the load operates per day. Hours of day : The time range in which the load operates. Initial buying rate : Initial energy buying rate at the beginning of each market slot in cents/kWh. Final buying rate : Final energy buying rate at the end of each market slot in cents/kWh. It can either be a user-defined value or equal to the Market Maker + Grid Fee. Rate increase : Explicit rate increase increment per update interval in cents/kWh Fit to limits : Derive bidding behavior from a linear fitted curve of a buying rate between initial_buying_rate and final_buying_rate within the bidding interval. If activated, energy rate_increase = (final_buying_rate - initial_buying_rate) / max(int((slot_length / update_interval) -1), 1) Update interval : The frequency at which the rate is updated. The Load configuration interface is shown below: Backend Configuration \u00b6 To implement the load in a backend simulation, two options are available : User configure Profile Market('Load', strategy=LoadHoursStrategy(avg_power_W=200, hrs_per_day=6,hrs_of_day=list(range(12, 18)), initial_buying_rate=0, final_buying_rate=35)) User upload Profile user_profile_path = os.path.join(d3a_path,\"assets/load.csv\") Market('Load', strategy=LoadProfileStrategy(daily_load_profile=user_profile_path, initial_buying_rate=0, final_buying_rate=35)) Addendum: hrs_of_day and hrs_per_day \u00b6 hrs_of_day defines the allowed time-window in which the load has to consume for a time defined by hrs_per_day. For example, a user can input 5 hrs_per_day and give a wider range for hrs_of_day like (2,18). The Load will try to consume as fast as possible during this time if there is any offered energy to purchase within the limits of initial_buying_rate and final_buying_rate set parameters. If there is sufficient energy at affordable rates, the load will consume in the first 5 hours, i.e. from 02:00 until 07:00, with no energy demand unmatched. In case energy prices are too high during the time-interval from 04:00 to 16:00, the load will consume from 02:00 until 04:00, turn off, and consume from 16:00 until 18:00, resulting in one hour of energy demand unmatched. For information on changes in buying and selling rates, please see: Trading strategies","title":"Model load"},{"location":"model-load/#user-interface-configuration","text":"The following parameters can be configured: Load name : Must be unique Load profile : The user can choose between two options: User upload profile (a load profile can be uploaded when compliant with Upload File Formats) User configure profile (the user provides the load average power) Average power : average consuming power of the load in Watts. Hours per day : The number of hours the load operates per day. Hours of day : The time range in which the load operates. Initial buying rate : Initial energy buying rate at the beginning of each market slot in cents/kWh. Final buying rate : Final energy buying rate at the end of each market slot in cents/kWh. It can either be a user-defined value or equal to the Market Maker + Grid Fee. Rate increase : Explicit rate increase increment per update interval in cents/kWh Fit to limits : Derive bidding behavior from a linear fitted curve of a buying rate between initial_buying_rate and final_buying_rate within the bidding interval. If activated, energy rate_increase = (final_buying_rate - initial_buying_rate) / max(int((slot_length / update_interval) -1), 1) Update interval : The frequency at which the rate is updated. The Load configuration interface is shown below:","title":"User Interface Configuration"},{"location":"model-load/#backend-configuration","text":"To implement the load in a backend simulation, two options are available : User configure Profile Market('Load', strategy=LoadHoursStrategy(avg_power_W=200, hrs_per_day=6,hrs_of_day=list(range(12, 18)), initial_buying_rate=0, final_buying_rate=35)) User upload Profile user_profile_path = os.path.join(d3a_path,\"assets/load.csv\") Market('Load', strategy=LoadProfileStrategy(daily_load_profile=user_profile_path, initial_buying_rate=0, final_buying_rate=35))","title":"Backend Configuration"},{"location":"model-load/#addendum-hrs_of_day-and-hrs_per_day","text":"hrs_of_day defines the allowed time-window in which the load has to consume for a time defined by hrs_per_day. For example, a user can input 5 hrs_per_day and give a wider range for hrs_of_day like (2,18). The Load will try to consume as fast as possible during this time if there is any offered energy to purchase within the limits of initial_buying_rate and final_buying_rate set parameters. If there is sufficient energy at affordable rates, the load will consume in the first 5 hours, i.e. from 02:00 until 07:00, with no energy demand unmatched. In case energy prices are too high during the time-interval from 04:00 to 16:00, the load will consume from 02:00 until 04:00, turn off, and consume from 16:00 until 18:00, resulting in one hour of energy demand unmatched. For information on changes in buying and selling rates, please see: Trading strategies","title":"Addendum: hrs_of_day and hrs_per_day"},{"location":"model-market-maker/","text":"The Market Maker mimics the behaviour of a typical energy utility and is used as a price reference point. Only one Market Maker can be set per simulation. The Market Maker can be configured to sell an infinite amount of energy as well as to buy an infinite amount of energy to simulate a Feed-in Tariff. User Interface Configuration \u00b6 The following parameters can be set: Name : The name of the Market Maker. Mode : The user has two options: Infinite power plant: In this mode, it has the ability to meet the infinite energy demand of consumers at the highest rate possible in that grid. Infinite bus: In this mode, the Market Maker has not only the ability to meet the infinite energy demand of the consumer but can also absorb the infinite generation surplus of prosumers/producers at the lowest rate possible in that grid. Role : The user has two options: Grid connected : In this mode, the Market Maker is connected to the grid and thus can fulfil the energy demand of any consumer and absorb surplus generation (if infinite bus mode selected) Islanded : In this mode, the Market Maker would only be used as a reference point for the highest possible energy_rate in that grid. Selling rate type : The user can either select User Input to define a fixed selling rate or upload their custom selling rate profile. Selling rate : The fixed rate the Market Maker will enforce, if User Input is chosen for the selling rate type. Buying rate type (infinite bus only) : The user can either select User Input to define a fixed buying rate or upload their custom buying rate profile. Buying rate (infinite bus only) : The fixed rate the Market Maker will enforce, if User Input is chosen for the buying rate type. The Market Maker configuration interface is shown below: Backend Configuration \u00b6 To implement a market maker in a backend simulation, two methods are available : infinite power plant : Market ('Market Maker', strategy=MarketMakerStrategy(energy_rate=selling_rate, grid_connected=True)) infinite bus : Market ('Market Maker', strategy=InfiniteBusStrategy(energy_buy_rate=22, energy_sell_rate=22))","title":"Model market maker"},{"location":"model-market-maker/#user-interface-configuration","text":"The following parameters can be set: Name : The name of the Market Maker. Mode : The user has two options: Infinite power plant: In this mode, it has the ability to meet the infinite energy demand of consumers at the highest rate possible in that grid. Infinite bus: In this mode, the Market Maker has not only the ability to meet the infinite energy demand of the consumer but can also absorb the infinite generation surplus of prosumers/producers at the lowest rate possible in that grid. Role : The user has two options: Grid connected : In this mode, the Market Maker is connected to the grid and thus can fulfil the energy demand of any consumer and absorb surplus generation (if infinite bus mode selected) Islanded : In this mode, the Market Maker would only be used as a reference point for the highest possible energy_rate in that grid. Selling rate type : The user can either select User Input to define a fixed selling rate or upload their custom selling rate profile. Selling rate : The fixed rate the Market Maker will enforce, if User Input is chosen for the selling rate type. Buying rate type (infinite bus only) : The user can either select User Input to define a fixed buying rate or upload their custom buying rate profile. Buying rate (infinite bus only) : The fixed rate the Market Maker will enforce, if User Input is chosen for the buying rate type. The Market Maker configuration interface is shown below:","title":"User Interface Configuration"},{"location":"model-market-maker/#backend-configuration","text":"To implement a market maker in a backend simulation, two methods are available : infinite power plant : Market ('Market Maker', strategy=MarketMakerStrategy(energy_rate=selling_rate, grid_connected=True)) infinite bus : Market ('Market Maker', strategy=InfiniteBusStrategy(energy_buy_rate=22, energy_sell_rate=22))","title":"Backend Configuration"},{"location":"model-markets/","text":"Markets contain submarkets and energy assets. Energy assets can post bids and offers in their market. Markets are interconnected by inter-area agents in a hierarchical network, which pass bids and offers between markets until they are matched, following a select market clearing mechanism . User Interface configuration \u00b6 The following market parameters can be set: Name : Must be unique Grid fee : If set to yes and with a non-None value, a fee will be applied to each trade that passes through or is cleared in this market. The grid fee is either constant , expressed in cents/kWh, or variable , expressed as a share of total price in percentage terms (%) depending on the parameters set in the simulation general settings . Transformers capacity : Import and export limits of the transformer in kVA. In the current implementation these limits are purely visual indicators and do not limit actual import/export of the market. Baseline import/export : Allows the user to compare the current simulation imports/exports to a baseline, set in kWh. These values are used in the calculation of the Peak Percentage KPI . The simulation configuration interface is shown below: Backend configuration \u00b6 These parameters can be set in the backend in the Area / Market class : Area('Market', [ ... \"some assets here\" ], grid_fee_constant=2, throughput=ThroughputParameters(import_capacity_kVA=2.0, export_capacity_kVA=2.0, baseline_peak_energy_import_kWh=0.4, baseline_peak_energy_export_kWh=0.4))","title":"Model markets"},{"location":"model-markets/#user-interface-configuration","text":"The following market parameters can be set: Name : Must be unique Grid fee : If set to yes and with a non-None value, a fee will be applied to each trade that passes through or is cleared in this market. The grid fee is either constant , expressed in cents/kWh, or variable , expressed as a share of total price in percentage terms (%) depending on the parameters set in the simulation general settings . Transformers capacity : Import and export limits of the transformer in kVA. In the current implementation these limits are purely visual indicators and do not limit actual import/export of the market. Baseline import/export : Allows the user to compare the current simulation imports/exports to a baseline, set in kWh. These values are used in the calculation of the Peak Percentage KPI . The simulation configuration interface is shown below:","title":"User Interface configuration"},{"location":"model-markets/#backend-configuration","text":"These parameters can be set in the backend in the Area / Market class : Area('Market', [ ... \"some assets here\" ], grid_fee_constant=2, throughput=ThroughputParameters(import_capacity_kVA=2.0, export_capacity_kVA=2.0, baseline_peak_energy_import_kWh=0.4, baseline_peak_energy_export_kWh=0.4))","title":"Backend configuration"},{"location":"model-power-plant/","text":"A finite power plant is an energy supplier that offers a configurable amount of power per time slot at a set rate. User Interface Configuration \u00b6 The following parameters can be configured: Name : Must be unique. Energy rate : Selling price of the power plant in cents/kWh. Maximum available power : Maximum power that the power plant can supply in kW (in the backend this parameter can also be set based on an uploaded profile). The configuration interface is shown below: Backend Configuration \u00b6 To implement the power plant in a backend simulation one option is available: Finite Power Plant profile_kW = { 0: 0.1, 8: 0.15, 12: 0.2, 19: 0.15, 22: 0.1 } Market (\"Power Plant', strategy=FinitePowerPlant(energy_rate=31.3, max_available_power_kW=profile_kW))","title":"Model power plant"},{"location":"model-power-plant/#user-interface-configuration","text":"The following parameters can be configured: Name : Must be unique. Energy rate : Selling price of the power plant in cents/kWh. Maximum available power : Maximum power that the power plant can supply in kW (in the backend this parameter can also be set based on an uploaded profile). The configuration interface is shown below:","title":"User Interface Configuration"},{"location":"model-power-plant/#backend-configuration","text":"To implement the power plant in a backend simulation one option is available: Finite Power Plant profile_kW = { 0: 0.1, 8: 0.15, 12: 0.2, 19: 0.15, 22: 0.1 } Market (\"Power Plant', strategy=FinitePowerPlant(energy_rate=31.3, max_available_power_kW=profile_kW))","title":"Backend Configuration"},{"location":"model-pv/","text":"A photovoltaic (PV) is an energy asset that converts solar irradiation into electricity. In our software, each PV component can represent a single panel, array of panels or an entire PV park. User Interface Configuration \u00b6 The following parameters can be configured: Name : Must be unique Panel count : Number of PV panels, each with a power of 250W. Solar Profile : The user can choose among multiple template solar profiles (sunny, partially cloudy or cloudy). The usery can also create a custom Gaussian curve or upload their own generation profile. Initial selling rate : Initial (and maximum) energy rate that the PV offers at the beginning of each market slot in cents/kWh. Final selling rate : Final energy rate that the PV offers at the end of each market slot in cents/kWh. Rate decrease : Explicit rate decrease increment in cents/kWh. Fit to limits : Derive bidding behavior from a linear fitted curve of a selling rate ranging from initial_selling_rate to final_selling_rate within the bidding interval. If activated, energy_rate_decrease_per_update = (initial_selling_rate - final_selling_rate) / max(int((slot_length / update_interval) -1), 1) Update interval : The frequency at which the rate is updated. The PV configuration interface is shown in the figure below: Backend Configuration \u00b6 There are two options to implement a PV in a backend: Solar Profile (for template generation profile) Market ('H2 PV', strategy=PVStrategy(panel_count=4, initial_selling_rate=30, final_selling_rate=5, fit_to_limit=True, update_interval=duration(minutes=5))) User Profile (for uploaded generation profile) user_profile_path = os.path.join(d3a_path, \"assets/Solar_Curve_W_sunny.csv\") Market ('H1 PV', strategy=PVUserProfileStrategy(power_profile=user_profile_path, panel_count=))","title":"Model pv"},{"location":"model-pv/#user-interface-configuration","text":"The following parameters can be configured: Name : Must be unique Panel count : Number of PV panels, each with a power of 250W. Solar Profile : The user can choose among multiple template solar profiles (sunny, partially cloudy or cloudy). The usery can also create a custom Gaussian curve or upload their own generation profile. Initial selling rate : Initial (and maximum) energy rate that the PV offers at the beginning of each market slot in cents/kWh. Final selling rate : Final energy rate that the PV offers at the end of each market slot in cents/kWh. Rate decrease : Explicit rate decrease increment in cents/kWh. Fit to limits : Derive bidding behavior from a linear fitted curve of a selling rate ranging from initial_selling_rate to final_selling_rate within the bidding interval. If activated, energy_rate_decrease_per_update = (initial_selling_rate - final_selling_rate) / max(int((slot_length / update_interval) -1), 1) Update interval : The frequency at which the rate is updated. The PV configuration interface is shown in the figure below:","title":"User Interface Configuration"},{"location":"model-pv/#backend-configuration","text":"There are two options to implement a PV in a backend: Solar Profile (for template generation profile) Market ('H2 PV', strategy=PVStrategy(panel_count=4, initial_selling_rate=30, final_selling_rate=5, fit_to_limit=True, update_interval=duration(minutes=5))) User Profile (for uploaded generation profile) user_profile_path = os.path.join(d3a_path, \"assets/Solar_Curve_W_sunny.csv\") Market ('H1 PV', strategy=PVUserProfileStrategy(power_profile=user_profile_path, panel_count=))","title":"Backend Configuration"},{"location":"model-storage/","text":"The storage simulates energy assets capable of storing or discharging energy (e.g. Lithium batteries, compressed air energy storage). User Interface Configuration \u00b6 The following parameters can be configured: Name : Must be unique Battery capacity : Total energy capacity. Initial capacity : Can be set in two ways: Initial State of Charge - SOC (in %) Initial Energy (in kWh) Minimum SOC : Minimum energy to leave in the storage. Max power rating for battery : Power limit for each market slot for sold and bought energy. Initial selling rate : Initial energy rate for selling energy at the beginning of each market slot in cents/kWh. Final selling rate : Final energy rate for selling energy at the end of each market slot in cents/kWh. Rate decrease : Explicit rate decrease increment in cents/kWh. Initial buying rate : Initial energy rate for buying energy at the beginning of each market slot in cents/kWh. Final buying rate : Final energy rate for buying energy at the end of each market slot in cents/kWh. Rate increase : Explicit rate increase increment in cents/kWh. Fit to limits : Derive bidding behavior from a linear fitted curve of a buying rate between initial_buying_rate and final_buying_rate and a selling rate between initial_selling_rate and final_selling_rate within the bidding interval. If activated: energy_rate_increase = (final_buying_rate - initial_buying_rate) / max(int((slot_length / update_interval) -1), 1) energy_rate_decrease_per_update = (initial_selling_rate - final_selling_rate) / max(int((slot_length / update_interval) -1), 1) Update interval : The frequency at which the rate is updated. Capacity based method : The storage can trade energy based on a capacity dependent sell price (see addendum). Note: For the time being, the storage component has a 100% electric-to-electric efficiency by default. Changing this characteristic is not possible at the moment but it will be possible in the near future. Users are welcome to add additional features to our open source code base on GitHub. The storage configuration interface is shown below: Backend Configuration \u00b6 To implement the storage in a backend simulation one option is available: Energy Storage System Market('Storage', strategy=StorageStrategy(initial_soc=50, energy_rate_decrease_per_update=3, battery_capacity_kWh=1.2, max_abs_battery_power_kW=5, final_buying_rate=16.99, final_selling_rate= 17.01))) Addendum: Storage Capacity Based Method \u00b6 This method was created to sell energy at lower prices during high state of charge - SOC (when the battery has more energy stored) and at higher prices during low SOC (when the battery can afford to sell its stored energy for less). If the cap_price_strategy is True , the offer price for the storage is calculated according to: offer_rate = initial_selling_rate - ((initial_selling_rate - final_selling_rate)\\*soc/100) As an example, considering an initial_selling_rate of 30 cents/kWh and a final_selling_rate of 20 cents/kWh, a storage with an SOC of 1% would sell its energy at 29.9 cents/kWh, and a battery at 100% SOC would sell its energy at 20 cents/kWh. Storage Behaviour in Local Energy Markets \u00b6 In general all bids and offers follow the physical constraint of the set max_abs_battery_power_kW value. The accumulated energy per market slot cannot exceed this power value times the length of the market slot. Energy sold and bought cancel each other out, meaning that if 2kWh are both sold and bought in the same market slot, the relative power remains 0kW. For the buying rate increase and selling rate decrease behaviour, please see the Trading Strategies page . Buying Energy in One-Sided Market : \u00b6 On each tick, the storage scans the connected market for affordable offers* if there is storage space to be filled (if the current SOC is lower than 100%). Once an offer is found, it is either fully or partially accepted, depending on the demand. The storage always seeks 100% SOC when buying energy. = affordable offers are offers that have a price lower or equal to the current acceptable energy rate. The acceptable energy rate changes during a market slot depending on the initial_buying_rate , final_buying_rate , energy_rate_decrease_per_update and update_interval setting. Buying Energy in Two-Sided Market : \u00b6 On each tick, the storage either places a bid for the quantity of energy it needs to reach 100% SOC or updates the price of an existing bid in the market where the bid rate depends on the initial_buying_rate , final_buying_rate , energy_rate_decrease_per_update and update_interval setting. Selling Energy \u00b6 At the beginning of each market slot, the storage places an offer for all the energy it has stored (not including the energy that is needed to keep the storage at least at min_allowed_soc). This offer is updated at each update_interval pursuant to the rate decrease settings. This mechanism applies in both one and two-sided market types. Consequently, it is possible for the storage to have both an offer and a bid placed in the same market.","title":"Model storage"},{"location":"model-storage/#user-interface-configuration","text":"The following parameters can be configured: Name : Must be unique Battery capacity : Total energy capacity. Initial capacity : Can be set in two ways: Initial State of Charge - SOC (in %) Initial Energy (in kWh) Minimum SOC : Minimum energy to leave in the storage. Max power rating for battery : Power limit for each market slot for sold and bought energy. Initial selling rate : Initial energy rate for selling energy at the beginning of each market slot in cents/kWh. Final selling rate : Final energy rate for selling energy at the end of each market slot in cents/kWh. Rate decrease : Explicit rate decrease increment in cents/kWh. Initial buying rate : Initial energy rate for buying energy at the beginning of each market slot in cents/kWh. Final buying rate : Final energy rate for buying energy at the end of each market slot in cents/kWh. Rate increase : Explicit rate increase increment in cents/kWh. Fit to limits : Derive bidding behavior from a linear fitted curve of a buying rate between initial_buying_rate and final_buying_rate and a selling rate between initial_selling_rate and final_selling_rate within the bidding interval. If activated: energy_rate_increase = (final_buying_rate - initial_buying_rate) / max(int((slot_length / update_interval) -1), 1) energy_rate_decrease_per_update = (initial_selling_rate - final_selling_rate) / max(int((slot_length / update_interval) -1), 1) Update interval : The frequency at which the rate is updated. Capacity based method : The storage can trade energy based on a capacity dependent sell price (see addendum). Note: For the time being, the storage component has a 100% electric-to-electric efficiency by default. Changing this characteristic is not possible at the moment but it will be possible in the near future. Users are welcome to add additional features to our open source code base on GitHub. The storage configuration interface is shown below:","title":"User Interface Configuration"},{"location":"model-storage/#backend-configuration","text":"To implement the storage in a backend simulation one option is available: Energy Storage System Market('Storage', strategy=StorageStrategy(initial_soc=50, energy_rate_decrease_per_update=3, battery_capacity_kWh=1.2, max_abs_battery_power_kW=5, final_buying_rate=16.99, final_selling_rate= 17.01)))","title":"Backend Configuration"},{"location":"model-storage/#addendum-storage-capacity-based-method","text":"This method was created to sell energy at lower prices during high state of charge - SOC (when the battery has more energy stored) and at higher prices during low SOC (when the battery can afford to sell its stored energy for less). If the cap_price_strategy is True , the offer price for the storage is calculated according to: offer_rate = initial_selling_rate - ((initial_selling_rate - final_selling_rate)\\*soc/100) As an example, considering an initial_selling_rate of 30 cents/kWh and a final_selling_rate of 20 cents/kWh, a storage with an SOC of 1% would sell its energy at 29.9 cents/kWh, and a battery at 100% SOC would sell its energy at 20 cents/kWh.","title":"Addendum: Storage Capacity Based Method"},{"location":"model-storage/#storage-behaviour-in-local-energy-markets","text":"In general all bids and offers follow the physical constraint of the set max_abs_battery_power_kW value. The accumulated energy per market slot cannot exceed this power value times the length of the market slot. Energy sold and bought cancel each other out, meaning that if 2kWh are both sold and bought in the same market slot, the relative power remains 0kW. For the buying rate increase and selling rate decrease behaviour, please see the Trading Strategies page .","title":"Storage Behaviour in Local Energy Markets"},{"location":"model-storage/#buying-energy-in-one-sided-market","text":"On each tick, the storage scans the connected market for affordable offers* if there is storage space to be filled (if the current SOC is lower than 100%). Once an offer is found, it is either fully or partially accepted, depending on the demand. The storage always seeks 100% SOC when buying energy. = affordable offers are offers that have a price lower or equal to the current acceptable energy rate. The acceptable energy rate changes during a market slot depending on the initial_buying_rate , final_buying_rate , energy_rate_decrease_per_update and update_interval setting.","title":"Buying Energy in One-Sided Market:"},{"location":"model-storage/#buying-energy-in-two-sided-market","text":"On each tick, the storage either places a bid for the quantity of energy it needs to reach 100% SOC or updates the price of an existing bid in the market where the bid rate depends on the initial_buying_rate , final_buying_rate , energy_rate_decrease_per_update and update_interval setting.","title":"Buying Energy in Two-Sided Market:"},{"location":"model-storage/#selling-energy","text":"At the beginning of each market slot, the storage places an offer for all the energy it has stored (not including the energy that is needed to keep the storage at least at min_allowed_soc). This offer is updated at each update_interval pursuant to the rate decrease settings. This mechanism applies in both one and two-sided market types. Consequently, it is possible for the storage to have both an offer and a bid placed in the same market.","title":"Selling Energy"},{"location":"one-sided-pay-as-offer/","text":"In the One-Sided Pay-as-Offer market, agents representing energy producers, including prosumers ( sellers ) post offers in the market with an energy price determined by the assets' trading strategy . Agents representing consumers ( buyers ) can see the offers available in their local market, filter affordable offers and then select the most favorable offer. The energy rate on which the seller and buyer settle is the price of the offer (pay-as-offer). Consequently, the trade rate may differ for trades settled in the same slot. The auction is continuous , meaning that once an offer is posted, it can be accepted right away, even before the end of each market slot .","title":"One-Sided Pay-as-Offer Market"},{"location":"peak-percentage/","text":"The energy peak imports/exports is the maximum value of the aggregate imports/exports of each asset inside a market. The user has the possibility to set a baseline_peak_energy_import_kWh and a baseline_peak_energy_export_kWh that they may have gotten from another simulation in order to calculate the energy peak percentage, a tool used to measure how much the peak imports or exports have changed between a defined baseline and the current simulation. The user may be interested in the Energy Peak Percentage value to assess the impact of applied grid fees or different energy storage strategies on the peak imports and exports of a market. The Energy Peak Percentage can be calculated as follows : Import_peak_percentage = import_peak_energy_kWh / import_baseline_peak_energy_kWh * 100 Export_peak_percentage = export_peak_energy_kWh / export_baseline_peak_energy_kWh * 100 If the energy peak percentage is below 100% , the peak was reduced vs. the baseline. The energy peak was increased if the energy peak percentage value is above 100% .","title":"Peak percentage"},{"location":"percentage-fees/","text":"The percentage grid fee is a market based fee, defined as a ratio (%) of the clearing price that is added to each trade that is cleared, as shown in the figure below. Figure 3.18 . Percentage grid fee calculation in the Grid Singularity Exchange. The price of a bid or offer changes as it is propagated into different markets to account for market fees. This way, a trading agent posting an offer will never receive less than offered and an agent making a bid will never pay more than bid. Example Calculation in One-Sided Pay-as-Offer Market \u00b6 Figure 3.19 . Percentage Grid Fee Example Calculation in One-Sided Pay-as-Offer Market. In the One-Sided Pay-as-Offer market , there are no bids, only offers. The offers are propagated throughout the markets in the hierarchy. The grid fees are taken into account when an offer is forwarded to the higher market, by the higher market itself. Therefore the agent is not responsible for adapting the offer price to include the grid fees. The grid fees' unit is a ratio of the original offer price, therefore the formula to calculate the new offer price when placing an offer to a market is the following: offer_price_after_fees = offer_price + original_price * grid_fee_ratio If the offer is not purchased after two ticks, it is moved into the next market, where the price is increased by that market\u2019s grid fee. In the provided example, the PV offer of 0.10\u20ac is first placed in the House 2 Market where it gains zero fees. Then it propagates into the Neighborhood 2 Market, gaining the market\u2019s fee of 5% of the original offer price 0.10*0.05+0.10=0.105\u20ac . If unmatched, it propagates into the Grid Market, with an additional 10% fee of the original offer is applied: 0.10*0.10+0.105=0.115\u20ac . Continuing into the Neighborhood 1 Market, the offer gains another fee of 5% of the original price 0.10*0.05+0.115=0.12\u20ac . Continuing into the House 1 Market, the offer gains zero additional fees as there is no fee in that market. The Load buys the offer in the House 1 Market at the Clearing Price of 0.12\u20ac. Starting with the initial offer price, the total fees are calculated 0.10*(1+0.05+0.10+0.05)=0.02 to yield the Trade Price of 0.12\u20ac. The Load pays the Trade Price of 0.12\u20ac, which includes 0.10\u20ac revenue for the PV, 0.005\u20ac fees for the Neighborhood Market 1, 0.01\u20ac fees for the Grid Market, and 0.005\u20ac fees for the Neighborhood Market 2. Since the market type is pay-as-offer, the offer rates are used as Clearing Rates. The trade price is then calculated by multiplying the clearing rate with the energy volume. For each market trade, the market grid fee is calculated based on the original offer rate and it is subtracted from the trade_price, in order to calculate the trade price after fees (and thus the revenue for the seller). The following formula is used: market_fees = grid_fee_ratio * original_rate * energy_portion trade_price_after_fees = energy * trade_rate - market_fees trade_price = energy * trade_rate Example Calculation in Two-Sided Pay-as-Bid Market \u00b6 Figure 3.20 . Percentage Grid Fee Example Calculation in Two-Sided Pay-as-Bid Market. In the Two-Sided Pay-as-Bid market , both bids and offers are propagated through the markets in the hierarchy. If a bid or offer is not purchased after two ticks , it propagates into the next market. In order to prevent double accounting of a market's grid fee when a bid and an offer are matched in that market, market fees are added to offers when they enter that market (target market) and subtracted from bids when they leave that market and enter another (source market). The formula for propagating the offers is the same as for the one-sided market: offer_price_after_fees = offer_price + original_price * grid_fee_ratio The Market Agent (MA) subtracts the fees from the bid before propagating it to a higher market. The formula for an area to update the bid to include grid fees is the following: bid_price_after_fees = bid_price - original_price * grid_fee_ratio In the case of the Two-Sided Pay-as-Bid market, the offer has moved into the Grid Market by the same mechanism as for the One-Sided Pay-as-Offer market. The bid of 0.30\u20ac follows a similar mechanism and is placed into the House 1 Market where there are zero fees. If the bid is not purchased after two ticks, it is moved into the Neighborhood 1 Market. As explained above, only the fees from the source market are added, which are zero in this case. Hence the bid remains at 0.30\u20ac. Next, the bid is moved to the Grid Market, and incurs the fees of the source market, the Neighborhood 1 Market of 5% to 0.30-0.30*0.05=0.285\u20ac . In the example above, the bid and offer are matched in the Grid Market. When the offer entered the Grid Market, its price was immediately updated to account for the Grid Market's fees 0.10*0.10+0.105=0.115\u20ac . The bid, however, did not add the 10% fee as only the fees from the source markets are added. In the case that the bid was not matched in the Grid Market and moved into the Neighborhood 2 Market, the 10% fee from the Grid Market would be added to the bid. In this case, the bid would become 0.285-0.30*0.10=0.255\u20ac . In the Grid Market, the Load bid is listed as 0.285\u20ac and the PV offer is listed as 0.115\u20ac. As the bid rate is greater than the offer rate, a trade can be scheduled. The trade clears at the bid rate, resulting in a Clearing Price of 0.285\u20ac. The algorithm to calculate the final grid fees for each trade is decentralised, allowing the markets to act more independently without having to share information regarding their fees with other markets. In order to calculate the fee correctly based on the original price, the algorithm needs to be able to calculate the supply side and demand side fee. It is easily calculated using the most recent forwarded rate and the original bid or offer rate: demand_side_fee = 1 - (forwarded_bid_rate / original_bid_rate) supply_side_fee = (forwarded_offer_rate / original_offer_rate) - 1 The provided example has the following values: supply_side_fee=(0.115/0.1)-1=0.15 demand_side_fee=1-(0.285/0.3)=0.05 After calculating the supply and the demand side fee, the trade revenue can be determined. Note the original_trade_rate is the amount that the original buyer (in our case the Load) will need to pay, and therefore the original bid price in a Pay-as-Bid market. The formula is the following: total_fee_ratio = supply_side_fee + demand_side_fee revenue = original_trade_rate / (1 + total_fee_ratio) In the provided example, revenue = 0.30/(1+0.15+0.05)=0.25 The grid fees are then calculated based on the revenue and the individual market fees: fees = revenue * grid_fee_ratio For the Grid Market in the provided example, the fees are 0.25*0.1=0.025 , and for each Neighborhood market, the fees are 0.25*0.05=0.0125 . Finally, the trade rate is adapted according to include the supply side grid fee, in order to include the fees of the current market: trade_rate = revenue * (1 + supply_side_fee) trade_price = energy * trade_rate In the provided example, the trade price for each market is: Grid Market = 0.25 * (1 + 0.15) = 0.2875 Neighborhood 2 Market = 0.25 * (1 + 0.05) = 0.2625 Neighborhood 1 Market = 0.25 * (1 + 0.2) = 0.3 House 1 Market = 0.25 * (1 + 0.2) = 0.3 House 2 Market = 0.25 * (1 + 0) = 0.25 The Load pays the Trade Price of 0.30\u20ac, which includes 0.25\u20ac revenue for the PV, 0.0125\u20ac fees for the Neighborhood Market 1, 0.025\u20ac fees for the Grid Market, and 0.0125\u20ac fees for the Neighborhood Market 2.","title":"Percentage Grid Fee Calculation"},{"location":"percentage-fees/#example-calculation-in-one-sided-pay-as-offer-market","text":"Figure 3.19 . Percentage Grid Fee Example Calculation in One-Sided Pay-as-Offer Market. In the One-Sided Pay-as-Offer market , there are no bids, only offers. The offers are propagated throughout the markets in the hierarchy. The grid fees are taken into account when an offer is forwarded to the higher market, by the higher market itself. Therefore the agent is not responsible for adapting the offer price to include the grid fees. The grid fees' unit is a ratio of the original offer price, therefore the formula to calculate the new offer price when placing an offer to a market is the following: offer_price_after_fees = offer_price + original_price * grid_fee_ratio If the offer is not purchased after two ticks, it is moved into the next market, where the price is increased by that market\u2019s grid fee. In the provided example, the PV offer of 0.10\u20ac is first placed in the House 2 Market where it gains zero fees. Then it propagates into the Neighborhood 2 Market, gaining the market\u2019s fee of 5% of the original offer price 0.10*0.05+0.10=0.105\u20ac . If unmatched, it propagates into the Grid Market, with an additional 10% fee of the original offer is applied: 0.10*0.10+0.105=0.115\u20ac . Continuing into the Neighborhood 1 Market, the offer gains another fee of 5% of the original price 0.10*0.05+0.115=0.12\u20ac . Continuing into the House 1 Market, the offer gains zero additional fees as there is no fee in that market. The Load buys the offer in the House 1 Market at the Clearing Price of 0.12\u20ac. Starting with the initial offer price, the total fees are calculated 0.10*(1+0.05+0.10+0.05)=0.02 to yield the Trade Price of 0.12\u20ac. The Load pays the Trade Price of 0.12\u20ac, which includes 0.10\u20ac revenue for the PV, 0.005\u20ac fees for the Neighborhood Market 1, 0.01\u20ac fees for the Grid Market, and 0.005\u20ac fees for the Neighborhood Market 2. Since the market type is pay-as-offer, the offer rates are used as Clearing Rates. The trade price is then calculated by multiplying the clearing rate with the energy volume. For each market trade, the market grid fee is calculated based on the original offer rate and it is subtracted from the trade_price, in order to calculate the trade price after fees (and thus the revenue for the seller). The following formula is used: market_fees = grid_fee_ratio * original_rate * energy_portion trade_price_after_fees = energy * trade_rate - market_fees trade_price = energy * trade_rate","title":"Example Calculation in One-Sided Pay-as-Offer Market"},{"location":"percentage-fees/#example-calculation-in-two-sided-pay-as-bid-market","text":"Figure 3.20 . Percentage Grid Fee Example Calculation in Two-Sided Pay-as-Bid Market. In the Two-Sided Pay-as-Bid market , both bids and offers are propagated through the markets in the hierarchy. If a bid or offer is not purchased after two ticks , it propagates into the next market. In order to prevent double accounting of a market's grid fee when a bid and an offer are matched in that market, market fees are added to offers when they enter that market (target market) and subtracted from bids when they leave that market and enter another (source market). The formula for propagating the offers is the same as for the one-sided market: offer_price_after_fees = offer_price + original_price * grid_fee_ratio The Market Agent (MA) subtracts the fees from the bid before propagating it to a higher market. The formula for an area to update the bid to include grid fees is the following: bid_price_after_fees = bid_price - original_price * grid_fee_ratio In the case of the Two-Sided Pay-as-Bid market, the offer has moved into the Grid Market by the same mechanism as for the One-Sided Pay-as-Offer market. The bid of 0.30\u20ac follows a similar mechanism and is placed into the House 1 Market where there are zero fees. If the bid is not purchased after two ticks, it is moved into the Neighborhood 1 Market. As explained above, only the fees from the source market are added, which are zero in this case. Hence the bid remains at 0.30\u20ac. Next, the bid is moved to the Grid Market, and incurs the fees of the source market, the Neighborhood 1 Market of 5% to 0.30-0.30*0.05=0.285\u20ac . In the example above, the bid and offer are matched in the Grid Market. When the offer entered the Grid Market, its price was immediately updated to account for the Grid Market's fees 0.10*0.10+0.105=0.115\u20ac . The bid, however, did not add the 10% fee as only the fees from the source markets are added. In the case that the bid was not matched in the Grid Market and moved into the Neighborhood 2 Market, the 10% fee from the Grid Market would be added to the bid. In this case, the bid would become 0.285-0.30*0.10=0.255\u20ac . In the Grid Market, the Load bid is listed as 0.285\u20ac and the PV offer is listed as 0.115\u20ac. As the bid rate is greater than the offer rate, a trade can be scheduled. The trade clears at the bid rate, resulting in a Clearing Price of 0.285\u20ac. The algorithm to calculate the final grid fees for each trade is decentralised, allowing the markets to act more independently without having to share information regarding their fees with other markets. In order to calculate the fee correctly based on the original price, the algorithm needs to be able to calculate the supply side and demand side fee. It is easily calculated using the most recent forwarded rate and the original bid or offer rate: demand_side_fee = 1 - (forwarded_bid_rate / original_bid_rate) supply_side_fee = (forwarded_offer_rate / original_offer_rate) - 1 The provided example has the following values: supply_side_fee=(0.115/0.1)-1=0.15 demand_side_fee=1-(0.285/0.3)=0.05 After calculating the supply and the demand side fee, the trade revenue can be determined. Note the original_trade_rate is the amount that the original buyer (in our case the Load) will need to pay, and therefore the original bid price in a Pay-as-Bid market. The formula is the following: total_fee_ratio = supply_side_fee + demand_side_fee revenue = original_trade_rate / (1 + total_fee_ratio) In the provided example, revenue = 0.30/(1+0.15+0.05)=0.25 The grid fees are then calculated based on the revenue and the individual market fees: fees = revenue * grid_fee_ratio For the Grid Market in the provided example, the fees are 0.25*0.1=0.025 , and for each Neighborhood market, the fees are 0.25*0.05=0.0125 . Finally, the trade rate is adapted according to include the supply side grid fee, in order to include the fees of the current market: trade_rate = revenue * (1 + supply_side_fee) trade_price = energy * trade_rate In the provided example, the trade price for each market is: Grid Market = 0.25 * (1 + 0.15) = 0.2875 Neighborhood 2 Market = 0.25 * (1 + 0.05) = 0.2625 Neighborhood 1 Market = 0.25 * (1 + 0.2) = 0.3 House 1 Market = 0.25 * (1 + 0.2) = 0.3 House 2 Market = 0.25 * (1 + 0) = 0.25 The Load pays the Trade Price of 0.30\u20ac, which includes 0.25\u20ac revenue for the PV, 0.0125\u20ac fees for the Neighborhood Market 1, 0.025\u20ac fees for the Grid Market, and 0.0125\u20ac fees for the Neighborhood Market 2.","title":"Example Calculation in Two-Sided Pay-as-Bid Market"},{"location":"power-plant/","text":"This energy asset is not yet available on the Singularity Map, but it will be available in the near future. It is still available to users on our previous interface (d3a.io) and in our backend. A finite power plant is an energy supplier that offers a configurable amount of power per time slot at a set rate. Asset Configuration Options: \u00b6 Name - Must be unique. Energy rate - Selling price of the power plant in cents/kWh. Maximum available power - Maximum power that the power plant can supply in kW.","title":"Power Plant"},{"location":"power-plant/#asset-configuration-options","text":"Name - Must be unique. Energy rate - Selling price of the power plant in cents/kWh. Maximum available power - Maximum power that the power plant can supply in kW.","title":"Asset Configuration Options:"},{"location":"price/","text":"The price graph shows the min, max, and average price of energy in \u20ac/kWh for each 15 minute market slot in this market. The grid fee is also shown if applied. If no trade occurred during a certain market interval, no lines are plotted. If grid fees are set in that market as a constant value, a fourth line is plotted to reflect its price. Figure 2.28 . Graph showing the evolution of the prices during the simulation period.","title":"Price"},{"location":"references/","text":"Grid Singularity Medium articles \u00b6 Grid Singularity. (February 2, 2022). Medell\u00edn Colombia Local Energy Market Trial: Demonstrating Benefits of Enabling Peer-to-Peer Trading , https://gridsingularity.medium.com/medell%C3%ADn-colombia-local-energy-market-trial-demonstrating-benefits-of-enabling-peer-to-peer-e7db62f76d81 Grid Singularity. (November 10, 2021). Discussion Paper: Grid Singularity\u2019s Implementation of Symbiotic Energy Markets , https://gridsingularity.medium.com/discussion-paper-grid-singularitys-implementation-of-symbiotic-energy-markets-bd3954af43c8 Grid Singularity. (October 28, 2021). You are energy. , https://gridsingularity.medium.com/you-are-energy-db950f94fca9 Grid Singularity. (May 3, 2021). Grid Singularity and Rebase Energy Awarded 2021 AI4Cities Grant , https://gridsingularity.medium.com/grid-singularity-and-rebase-energy-awarded-2021-ai4cities-grant-4e0aa1cf3240 Grid Singularity. (December 10, 2020). Energy Singularity Challenge 2020: Testing Novel Grid Fee Models and Intelligent Peer-to-Peer Trading Strategies , https://gridsingularity.medium.com/energy-singularity-challenge-2020-testing-novel-grid-fee-models-and-intelligent-peer-to-peer-6a0d715a9063 Grid Singularity. (November 25, 2020). Energy Singularity Challenge 2020: Social Energy Networks , https://gridsingularity.medium.com/energy-singularity-challenge-2020-social-energy-networks-157b390e5f39 Grid Singularity. (September 10, 2020). En Route to Energy Singularity Odyssey Momentum: Learnings from the 2020 Chaos Experiment , https://gridsingularity.medium.com/en-route-to-energy-singularity-odyssey-momentum-learnings-from-the-2020-chaos-experiment-8dc38ff26869 Grid Singularity. (August 27, 2020). Modelling study to assess the potential benefits of trading in and between local energy communities in Germany , https://gridsingularity.medium.com/modelling-study-to-assess-the-potential-benefits-of-trading-in-and-between-local-energy-d721395ddd4b Grid Singularity. (June 18, 2020). Analysis of Local Electricity Markets as a Platform to Modernise Consumer and Grid Interaction , https://gridsingularity.medium.com/analysis-of-local-electricity-markets-as-a-platform-to-modernise-consumer-and-grid-interaction-3fff63ef74e7 Grid Singularity. (April 14, 2020). Deploying Local Electricity Markets to Optimise PV Integration; A Study of Three LEM Scenarios in Germany , https://gridsingularity.medium.com/deploying-local-electricity-markets-to-optimise-pv-integration-a-study-of-three-lem-scenarios-in-cf125b26f4dc Grid Singularity. (April 1, 2020). Energy Communities: a Game Changer for the European Electricity Grid , https://gridsingularity.medium.com/energy-communities-a-game-changer-for-the-european-electricity-grid-fd588a3063b0 Grid Singularity. (February 21, 2020). A Case for Flexibility Markets Enabled by Local Peer-to-Peer Exchanges , https://gridsingularity.medium.com/a-case-for-flexibility-markets-enabled-by-local-peer-to-peer-exchanges-43300b625cb5 Grid Singularity. (February 17, 2020). Stakeholders\u2019 Interest in Energy Market Design Innovation; Key Takeaways from the Odyssey Connect Energy Singularity Panel , https://gridsingularity.medium.com/stakeholders-interest-in-energy-market-design-innovation-key-takeaways-from-the-odyssey-connect-a6d18056ab34 Grid Singularity. (September 23, 2019). An Energy Exchange Engine for Local Energy Marketplaces , https://gridsingularity.medium.com/an-energy-exchange-engine-for-local-energy-marketplaces-28d5be23705e Books on Grid Singularity Energy Exchange (formerly D3A) \u00b6 Ana Trbovich, Sarah Hambridge, Dirk van den Biggelaar, Ewald Hesse, Fereidoon Sioshansi, Chapter 13 - D3A energy exchange for a transactive grid , Editor(s): Fereidoon Sioshansi, Behind and Beyond the Meter, Academic Press, 2020, Pages 267-284, ISBN 9780128199510, https://doi.org/10.1016/B978-0-12-819951-0.00013-X . (http://www.sciencedirect.com/science/article/pii/B978012819951000013X) Scientific articles and studies referencing Grid Singularity (formerly D3A) \u00b6 Karystinos, C.; Vasilakis, A.; Kotsampopoulos, P.; Hatziargyriou, N. Local Energy Exchange Market for Community Off-Grid Microgrids: Case Study Los Molinos del Rio Aguas. Energies 2022, 15, 703. https://doi.org/10.3390/en15030703 Okwuibe, Godwin C., Amin S. Gazafroudi, Sarah Hambridge, Christopher Dietrich, Ana Trbovich, Miadreza Shafie-khah, Peter Tzscheutschler, and Thomas Hamacher, Evaluation of Hierarchical, Multi-Agent, Community-Based, Local Energy Markets Based on Key Performance Indicators , Energies 15, no. 10: 3575, 2022. https://doi.org/10.3390/en15103575 Fatuma Ali, Juan Pablo C\u00e1rdenas \u00c1lvarez, Ana Trbovich, Andrea Bertolini, Juan Manuel Espa\u00f1a, and Santigo Ortega, Advancing From Community to Peer-To-Peer Energy Trading in the Medell\u00edn-Colombia Local Energy Market Trial , IEEE Smart Cities Newsletter, January 2022, https://smartcities.ieee.org/newsletter/january-2022/advancing-from-community-to-peer-to-peer-energy-trading-in-the-medellin-colombia-local-energy-market-trial A. S. Gazafroudi et al., Mathematical Model for Agent-based Local Energy Exchange Engine (D3A) , 2021 International Conference on Smart Energy Systems and Technologies (SEST), 2021. https://ieeexplore.ieee.org/abstract/document/9543262 G. C. Okwuibe, M. Wadhwa, T. Brenner, P. Tzscheutschler and T. Hamacher, Analysis of Key Performance Indicators for Local Electricity Markets' Design Analyse des indicateurs cl\u00e9s de performance pour la conception des march\u00e9s locaux de l'\u00e9lectricit\u00e9 , in IEEE Canadian Journal of Electrical and Computer Engineering, 2021. https://ieeexplore.ieee.org/abstract/document/9501942?casa_token=RetCo9BilxsAAAAA:Roi3KX5rUbYYveEnE8MFlIrRsX7RKjsv7DHOTaUNg7E3v0weSWAM_M04ebYC4bDsp6MJH2GKfw Kartikey Garg Tumul Vyas, Integration Of Smart Grid And Blockchain , 2021. https://scholar.archive.org/work/h4qouafhnrfifcqzppsrwilgwa/access/wayback/https://s3-eu-west-1.amazonaws.com/pstorage-techrxiv-6044451694/28501059/IntegrationOfSmartGridAndBlockchain.pdf M. Wadhwa, G. C. Okwuibe, T. Brenner, P. Tzscheutschler and T. Hamacher, Key Performance Indicator Based Design Guidelines for Local Electricity Markets , IEEE Electric Power and Energy Conference (EPEC), 2020. https://ieeexplore.ieee.org/abstract/document/9320047 BBEn, 100 prozent erneuerbar stiftung, Grid Singularity, Neue Kraft mit der Nachbarschaft , October 2020, https://www.buendnis-buergerenergie.de/fileadmin/nkmdn_Lokale_Strommaerkte.pdf Trbovich, Ana S. In Pursuit of Good Governance for the Energy Industry Blockchain . Journal of Energy Markets, May 2019, https://www.risk.net/node/6637136 . Danzi, P. Hambridge,S. Stefanovi\u0107, \u010c. Popovski,P. Blockchain-Based and Multi-Layered Electricity Imbalance Settlement Architecture . IEEE, December 27,2018. https://ieeexplore.ieee.org/abstract/document/8587577/references#references Graduate theses referencing Grid Singularity (formerly D3A) \u00b6 Sridharan, Srinidhi. Development of deterministic trading strategy for Peer-to-Peer (P2P) trading based on user-preferences , 11 January 2022, Master thesis, Technical University Chemnitz, Germany. Kement, Sanem. Designing a local electricity market using blockchain technology , 2020 https://www.researchgate.net/publication/344567774_Designing_a_local_electricity_market_using_blockchain_technology Wadhwa, Mukund. Analysis of local electricity markets in Germany using simulation , 2020 https://www.researchgate.net/publication/344567698_Analysis_of_local_electricity_markets_in_Germany_using_simulation Kalny, Laurin. Blockchain & Energy: How the technology behind Bitcoin can reinvent the way of doing business for utility providers , 2018. https://www.researchgate.net/publication/332471608_Blockchain_Energy_How_the_technology_behind_Bitcoin_can_reinvent_the_way_of_doing_business_for_utility_providers","title":"References"},{"location":"references/#grid-singularity-medium-articles","text":"Grid Singularity. (February 2, 2022). Medell\u00edn Colombia Local Energy Market Trial: Demonstrating Benefits of Enabling Peer-to-Peer Trading , https://gridsingularity.medium.com/medell%C3%ADn-colombia-local-energy-market-trial-demonstrating-benefits-of-enabling-peer-to-peer-e7db62f76d81 Grid Singularity. (November 10, 2021). Discussion Paper: Grid Singularity\u2019s Implementation of Symbiotic Energy Markets , https://gridsingularity.medium.com/discussion-paper-grid-singularitys-implementation-of-symbiotic-energy-markets-bd3954af43c8 Grid Singularity. (October 28, 2021). You are energy. , https://gridsingularity.medium.com/you-are-energy-db950f94fca9 Grid Singularity. (May 3, 2021). Grid Singularity and Rebase Energy Awarded 2021 AI4Cities Grant , https://gridsingularity.medium.com/grid-singularity-and-rebase-energy-awarded-2021-ai4cities-grant-4e0aa1cf3240 Grid Singularity. (December 10, 2020). Energy Singularity Challenge 2020: Testing Novel Grid Fee Models and Intelligent Peer-to-Peer Trading Strategies , https://gridsingularity.medium.com/energy-singularity-challenge-2020-testing-novel-grid-fee-models-and-intelligent-peer-to-peer-6a0d715a9063 Grid Singularity. (November 25, 2020). Energy Singularity Challenge 2020: Social Energy Networks , https://gridsingularity.medium.com/energy-singularity-challenge-2020-social-energy-networks-157b390e5f39 Grid Singularity. (September 10, 2020). En Route to Energy Singularity Odyssey Momentum: Learnings from the 2020 Chaos Experiment , https://gridsingularity.medium.com/en-route-to-energy-singularity-odyssey-momentum-learnings-from-the-2020-chaos-experiment-8dc38ff26869 Grid Singularity. (August 27, 2020). Modelling study to assess the potential benefits of trading in and between local energy communities in Germany , https://gridsingularity.medium.com/modelling-study-to-assess-the-potential-benefits-of-trading-in-and-between-local-energy-d721395ddd4b Grid Singularity. (June 18, 2020). Analysis of Local Electricity Markets as a Platform to Modernise Consumer and Grid Interaction , https://gridsingularity.medium.com/analysis-of-local-electricity-markets-as-a-platform-to-modernise-consumer-and-grid-interaction-3fff63ef74e7 Grid Singularity. (April 14, 2020). Deploying Local Electricity Markets to Optimise PV Integration; A Study of Three LEM Scenarios in Germany , https://gridsingularity.medium.com/deploying-local-electricity-markets-to-optimise-pv-integration-a-study-of-three-lem-scenarios-in-cf125b26f4dc Grid Singularity. (April 1, 2020). Energy Communities: a Game Changer for the European Electricity Grid , https://gridsingularity.medium.com/energy-communities-a-game-changer-for-the-european-electricity-grid-fd588a3063b0 Grid Singularity. (February 21, 2020). A Case for Flexibility Markets Enabled by Local Peer-to-Peer Exchanges , https://gridsingularity.medium.com/a-case-for-flexibility-markets-enabled-by-local-peer-to-peer-exchanges-43300b625cb5 Grid Singularity. (February 17, 2020). Stakeholders\u2019 Interest in Energy Market Design Innovation; Key Takeaways from the Odyssey Connect Energy Singularity Panel , https://gridsingularity.medium.com/stakeholders-interest-in-energy-market-design-innovation-key-takeaways-from-the-odyssey-connect-a6d18056ab34 Grid Singularity. (September 23, 2019). An Energy Exchange Engine for Local Energy Marketplaces , https://gridsingularity.medium.com/an-energy-exchange-engine-for-local-energy-marketplaces-28d5be23705e","title":"Grid Singularity Medium articles"},{"location":"references/#books-on-grid-singularity-energy-exchange-formerly-d3a","text":"Ana Trbovich, Sarah Hambridge, Dirk van den Biggelaar, Ewald Hesse, Fereidoon Sioshansi, Chapter 13 - D3A energy exchange for a transactive grid , Editor(s): Fereidoon Sioshansi, Behind and Beyond the Meter, Academic Press, 2020, Pages 267-284, ISBN 9780128199510, https://doi.org/10.1016/B978-0-12-819951-0.00013-X . (http://www.sciencedirect.com/science/article/pii/B978012819951000013X)","title":"Books on Grid Singularity Energy Exchange (formerly D3A)"},{"location":"references/#scientific-articles-and-studies-referencing-grid-singularity-formerly-d3a","text":"Karystinos, C.; Vasilakis, A.; Kotsampopoulos, P.; Hatziargyriou, N. Local Energy Exchange Market for Community Off-Grid Microgrids: Case Study Los Molinos del Rio Aguas. Energies 2022, 15, 703. https://doi.org/10.3390/en15030703 Okwuibe, Godwin C., Amin S. Gazafroudi, Sarah Hambridge, Christopher Dietrich, Ana Trbovich, Miadreza Shafie-khah, Peter Tzscheutschler, and Thomas Hamacher, Evaluation of Hierarchical, Multi-Agent, Community-Based, Local Energy Markets Based on Key Performance Indicators , Energies 15, no. 10: 3575, 2022. https://doi.org/10.3390/en15103575 Fatuma Ali, Juan Pablo C\u00e1rdenas \u00c1lvarez, Ana Trbovich, Andrea Bertolini, Juan Manuel Espa\u00f1a, and Santigo Ortega, Advancing From Community to Peer-To-Peer Energy Trading in the Medell\u00edn-Colombia Local Energy Market Trial , IEEE Smart Cities Newsletter, January 2022, https://smartcities.ieee.org/newsletter/january-2022/advancing-from-community-to-peer-to-peer-energy-trading-in-the-medellin-colombia-local-energy-market-trial A. S. Gazafroudi et al., Mathematical Model for Agent-based Local Energy Exchange Engine (D3A) , 2021 International Conference on Smart Energy Systems and Technologies (SEST), 2021. https://ieeexplore.ieee.org/abstract/document/9543262 G. C. Okwuibe, M. Wadhwa, T. Brenner, P. Tzscheutschler and T. Hamacher, Analysis of Key Performance Indicators for Local Electricity Markets' Design Analyse des indicateurs cl\u00e9s de performance pour la conception des march\u00e9s locaux de l'\u00e9lectricit\u00e9 , in IEEE Canadian Journal of Electrical and Computer Engineering, 2021. https://ieeexplore.ieee.org/abstract/document/9501942?casa_token=RetCo9BilxsAAAAA:Roi3KX5rUbYYveEnE8MFlIrRsX7RKjsv7DHOTaUNg7E3v0weSWAM_M04ebYC4bDsp6MJH2GKfw Kartikey Garg Tumul Vyas, Integration Of Smart Grid And Blockchain , 2021. https://scholar.archive.org/work/h4qouafhnrfifcqzppsrwilgwa/access/wayback/https://s3-eu-west-1.amazonaws.com/pstorage-techrxiv-6044451694/28501059/IntegrationOfSmartGridAndBlockchain.pdf M. Wadhwa, G. C. Okwuibe, T. Brenner, P. Tzscheutschler and T. Hamacher, Key Performance Indicator Based Design Guidelines for Local Electricity Markets , IEEE Electric Power and Energy Conference (EPEC), 2020. https://ieeexplore.ieee.org/abstract/document/9320047 BBEn, 100 prozent erneuerbar stiftung, Grid Singularity, Neue Kraft mit der Nachbarschaft , October 2020, https://www.buendnis-buergerenergie.de/fileadmin/nkmdn_Lokale_Strommaerkte.pdf Trbovich, Ana S. In Pursuit of Good Governance for the Energy Industry Blockchain . Journal of Energy Markets, May 2019, https://www.risk.net/node/6637136 . Danzi, P. Hambridge,S. Stefanovi\u0107, \u010c. Popovski,P. Blockchain-Based and Multi-Layered Electricity Imbalance Settlement Architecture . IEEE, December 27,2018. https://ieeexplore.ieee.org/abstract/document/8587577/references#references","title":"Scientific articles and studies referencing Grid Singularity (formerly D3A)"},{"location":"references/#graduate-theses-referencing-grid-singularity-formerly-d3a","text":"Sridharan, Srinidhi. Development of deterministic trading strategy for Peer-to-Peer (P2P) trading based on user-preferences , 11 January 2022, Master thesis, Technical University Chemnitz, Germany. Kement, Sanem. Designing a local electricity market using blockchain technology , 2020 https://www.researchgate.net/publication/344567774_Designing_a_local_electricity_market_using_blockchain_technology Wadhwa, Mukund. Analysis of local electricity markets in Germany using simulation , 2020 https://www.researchgate.net/publication/344567698_Analysis_of_local_electricity_markets_in_Germany_using_simulation Kalny, Laurin. Blockchain & Energy: How the technology behind Bitcoin can reinvent the way of doing business for utility providers , 2018. https://www.researchgate.net/publication/332471608_Blockchain_Energy_How_the_technology_behind_Bitcoin_can_reinvent_the_way_of_doing_business_for_utility_providers","title":"Graduate theses referencing Grid Singularity (formerly D3A)"},{"location":"registration-asset-api-backend/","text":"Note: If you are running the Grid Singularity exchange (currently via prior interface, D3A) using a virtual machine and vagrant , the latest GSy-e SDK is already installed on your computer and you can skip to the Launch Simulation section below. If you are running the exchange software locally, please follow the following instructions. Start Redis server \u00b6 To use the API locally, your script interacts with the simulation using a local Redis instance. To start the redis instance, open a new terminal and run the following command : redis-server /usr/local/etc/redis.conf To install redis in Ubuntu follow the instructions in this link . Open external connection to API for Assets \u00b6 In the setup file (template available here ), an asset must be designated as open to external connection via the API. This is controlled when setting up the simulation in the setup file by designating the ExternalStrategy for each relevant energy assets : Market('Family 3 children+PV+Batt', [ Asset('Load 3 L17', strategy=LoadProfileExternalStrategy( daily_load_profile=os.path.join(current_dir, \"resources/CHR41 Family with 3 children, both at work HH1.csv\"), initial_buying_rate=Load_initial_buying_rate, final_buying_rate=Load_final_buying_rate), ), Asset('PV 3 (5kW)', strategy=PVUserProfileExternalStrategy( power_profile=os.path.join(current_dir, \"resources/Berlin_pv.csv\"), panel_count=5, initial_selling_rate=30, final_selling_rate=11), ), Asset('Tesla Powerwall 3', strategy=StorageExternalStrategy(initial_soc=10, 54min_allowed_soc=10, battery_capacity_kWh=14, max_abs_battery_power_kW=5, initial_buying_rate=0, final_buying_rate=25, initial_selling_rate=30, final_selling_rate=25.1), ), ]), By default, trading strategies do not allow API connections unless the ExternalStrategy is used. Please also ensure that the appropriate libraries are imported to use the API. Launch simulation \u00b6 This requires you to have the backend codebase installed on your machine to run simulations (see Installation Instructions ). First, navigate to the Grid Singularity folder (currently still D3A) in a new terminal, then activate the Grid Singularity (currently still D3A) environment with the command: workon gsy-env An template setup is already available in github and ready to be run here (data available for the July 2021). To run this simulation and wait for the API template script to execute: gsy-env -l INFO run -t 15s -s 15m --setup api_setup.default_community --slot-length-realtime 5 --start-date 2021-07-01 --enable-external-connection --paused After few seconds, the simulation should begin, waiting for the API template as mentioned in the figure below: Here you can find more information on launching a simulation on the backend. Initialise and start the API : \u00b6 Before launching the SDK Script, users need to adapt the following information in their script: Oracle name \u00b6 This parameter is only relevant when using the API on the User-Interface. This defines the name of the aggregator / API name that manages the markets and energy assets. Once the name is set it cannot be changed within the same running collaboration. oracle_name = 'oracle' Assets list \u00b6 The list of assets needs to be updated to include the assets registered to user through the registration process, in arrays as follows : load_names = ['Load 1 L13', 'Load 2 L21', 'Load 3 L17'] pv_names = ['PV 1 (4kW)', 'PV 3 (5kW)'] storage_names = ['Tesla Powerwall 3'] market_names = [\"Grid\", \"Community\"] The SDK Script has an \u201cautomatic\u201d connection process to manage energy assets. If the function automatic is True, the Exchange SDK will automatically connect to all energy assets that it is registered to. This option is only available for simulations running on the User-Interface. Interact with local simulations \u00b6 To interact with a locally running simulation (backend simulation), username, passwords, domain and websocket names and simulation_id are not necessary. There is only an additional flag required in the CLI command : --run-on-redis. gsy-e-sdk --log-level INFO run --setup asset_api_template --run-on-redis Log levels: \u00b6 The API CLI command can receive a --log-level argument. Adjusting this parameter will increase or reduce the level of information displayed in the terminal, while the agent is running. There are 4 levels (classed from low detailed to high: ERROR \u00b6 Display only critical errors from the Exchange SDK or the Grid Singularity Exchange (for instance, if Grid Singularity Exchange responds with an error in a command that the Exchange SDK is sending, the error log should include it) WARNING \u00b6 Display non-critical error messages (for instance if the API agent is over bidding its energy requirement) INFO \u00b6 Display critical and non-critical errors messages and general information such as market progression and trades DEBUG \u00b6 Display full information on the agent (for instance all command and response, such as placing bids and offers on the market) For a video tutorial on the Asset API, please follow this link . We recommend that the users experiment with trading strategies, verify their data and familiarize themselves with the Grid Singularity user interface and APIs in a Collaboration environment before initiating a Canary Test Network.","title":"Registration - Simulations run on the Backend"},{"location":"registration-asset-api-backend/#start-redis-server","text":"To use the API locally, your script interacts with the simulation using a local Redis instance. To start the redis instance, open a new terminal and run the following command : redis-server /usr/local/etc/redis.conf To install redis in Ubuntu follow the instructions in this link .","title":"Start Redis server"},{"location":"registration-asset-api-backend/#open-external-connection-to-api-for-assets","text":"In the setup file (template available here ), an asset must be designated as open to external connection via the API. This is controlled when setting up the simulation in the setup file by designating the ExternalStrategy for each relevant energy assets : Market('Family 3 children+PV+Batt', [ Asset('Load 3 L17', strategy=LoadProfileExternalStrategy( daily_load_profile=os.path.join(current_dir, \"resources/CHR41 Family with 3 children, both at work HH1.csv\"), initial_buying_rate=Load_initial_buying_rate, final_buying_rate=Load_final_buying_rate), ), Asset('PV 3 (5kW)', strategy=PVUserProfileExternalStrategy( power_profile=os.path.join(current_dir, \"resources/Berlin_pv.csv\"), panel_count=5, initial_selling_rate=30, final_selling_rate=11), ), Asset('Tesla Powerwall 3', strategy=StorageExternalStrategy(initial_soc=10, 54min_allowed_soc=10, battery_capacity_kWh=14, max_abs_battery_power_kW=5, initial_buying_rate=0, final_buying_rate=25, initial_selling_rate=30, final_selling_rate=25.1), ), ]), By default, trading strategies do not allow API connections unless the ExternalStrategy is used. Please also ensure that the appropriate libraries are imported to use the API.","title":"Open external connection to API for Assets"},{"location":"registration-asset-api-backend/#launch-simulation","text":"This requires you to have the backend codebase installed on your machine to run simulations (see Installation Instructions ). First, navigate to the Grid Singularity folder (currently still D3A) in a new terminal, then activate the Grid Singularity (currently still D3A) environment with the command: workon gsy-env An template setup is already available in github and ready to be run here (data available for the July 2021). To run this simulation and wait for the API template script to execute: gsy-env -l INFO run -t 15s -s 15m --setup api_setup.default_community --slot-length-realtime 5 --start-date 2021-07-01 --enable-external-connection --paused After few seconds, the simulation should begin, waiting for the API template as mentioned in the figure below: Here you can find more information on launching a simulation on the backend.","title":"Launch simulation"},{"location":"registration-asset-api-backend/#initialise-and-start-the-api","text":"Before launching the SDK Script, users need to adapt the following information in their script:","title":"Initialise and start the API :"},{"location":"registration-asset-api-backend/#oracle-name","text":"This parameter is only relevant when using the API on the User-Interface. This defines the name of the aggregator / API name that manages the markets and energy assets. Once the name is set it cannot be changed within the same running collaboration. oracle_name = 'oracle'","title":"Oracle name"},{"location":"registration-asset-api-backend/#assets-list","text":"The list of assets needs to be updated to include the assets registered to user through the registration process, in arrays as follows : load_names = ['Load 1 L13', 'Load 2 L21', 'Load 3 L17'] pv_names = ['PV 1 (4kW)', 'PV 3 (5kW)'] storage_names = ['Tesla Powerwall 3'] market_names = [\"Grid\", \"Community\"] The SDK Script has an \u201cautomatic\u201d connection process to manage energy assets. If the function automatic is True, the Exchange SDK will automatically connect to all energy assets that it is registered to. This option is only available for simulations running on the User-Interface.","title":"Assets list"},{"location":"registration-asset-api-backend/#interact-with-local-simulations","text":"To interact with a locally running simulation (backend simulation), username, passwords, domain and websocket names and simulation_id are not necessary. There is only an additional flag required in the CLI command : --run-on-redis. gsy-e-sdk --log-level INFO run --setup asset_api_template --run-on-redis","title":"Interact with local simulations"},{"location":"registration-asset-api-backend/#log-levels","text":"The API CLI command can receive a --log-level argument. Adjusting this parameter will increase or reduce the level of information displayed in the terminal, while the agent is running. There are 4 levels (classed from low detailed to high:","title":"Log levels:"},{"location":"registration-asset-api-backend/#error","text":"Display only critical errors from the Exchange SDK or the Grid Singularity Exchange (for instance, if Grid Singularity Exchange responds with an error in a command that the Exchange SDK is sending, the error log should include it)","title":"ERROR"},{"location":"registration-asset-api-backend/#warning","text":"Display non-critical error messages (for instance if the API agent is over bidding its energy requirement)","title":"WARNING"},{"location":"registration-asset-api-backend/#info","text":"Display critical and non-critical errors messages and general information such as market progression and trades","title":"INFO"},{"location":"registration-asset-api-backend/#debug","text":"Display full information on the agent (for instance all command and response, such as placing bids and offers on the market) For a video tutorial on the Asset API, please follow this link . We recommend that the users experiment with trading strategies, verify their data and familiarize themselves with the Grid Singularity user interface and APIs in a Collaboration environment before initiating a Canary Test Network.","title":"DEBUG"},{"location":"registration-asset-api-user-interface/","text":"Note: The following instructions serve as a guide to launch the Grid Operator API as well. The Asset API is launched with a cli command. To launch the Asset API, the user needs to open a new terminal and activate the gsy-e-sdk environment (Grid Singularity Exchange SDK). workon gsy-e-sdk And go to the GSy Exchange SDK repository cd path_to_repository/gsy-e-sdk The API launch CLI command takes several arguments that can be listed with: gsy-e-sdk run --help The arguments are : base-setup-path --> Set the base path where user's client script resides, otherwise gsy-e-sdk/setups is taken as default for user's client scripts. Users can provide either an absolute or a relative file path. setup --> Name of user's SDK module/script. username --> Username of agent authorized to communicate with respective collaboration/CN. password --> Password of respective agent domain-name --> D3A domain name web-socket --> D3A websocket URI simulation-id --> UUID of the collaboration or Canary Network (CN) simulation-config-path --> Path to the JSON file that contains the user's collaboration/CN information. This file can be downloaded from the \"Registry\" page, currently still at d3a.io. run-on-redis --> This flag targets the local testing of the SDK, where no user authentication is required. A locally running redis server and Grid Singularity (d3a.io) simulation are needed here. The API agent can interface with a local simulation ( backend ) or a collaboration / Canary Network ( User-Interface ). There are 3 methods to parse the required information when launching the API to connect to the UI, as thoroughly explained in the text below: Simulation configuration file CLI command Environment variables Simulation configuration file: \u00b6 The simulation configuration file is a JSON format file downloadable on the User-Interface . It contains all the information about the simulation setup (username, simulation name and UUID, domain name, websocket domain name, global settings of the simulation and the registry, consisting of all the grid hierarchy including markets and assets and whether or not the user is connected to those). To download this file the user needs to go to the Registry page of the relevant collaboration/Canary Test Network and click on the top right edit icon and Download Exchange SDK Summary. To run the Asset API, you can run the following command by adapting the arguments to your case: gsy-e-sdk --log-level INFO run --setup asset_api_template -u username -p password -i absolute_path/my_simulation_config.json CLI command: \u00b6 Instead of passing the JSON file, the user can directly pass the relevant variables as arguments in the CLI commands. For that to work, the user needs to pass the domain name and websocket name (both are optional parameters and only relevant when connecting to specific domains) and the simulation_id. The simulation_id corresponds to the Universally Unique Identifier. This token can be found in the URL of a collaboration or a Canary Test Network in the User Interface. To run the Asset API, users can run the following command by adapting the arguments to their case: gsy-e-sdk --log-level INFO run --setup asset_api_template -u username -p password --simulation-id UUID Environnement variables: \u00b6 The last method to launch the API is send the set the required variable in the environment. To do that users can simply define those parameters at the top of their script as follows: os.environ[\"API_CLIENT_USERNAME\"] = \"username\" os.environ[\"API_CLIENT_PASSWORD\"] = \"password\" os.environ[\"API_CLIENT_SIMULATION_ID\"] = \"simulation_uuid\" To run the Asset API, you can run the following command by adapting the arguments to your case: gsy-e-sdk --log-level INFO run --setup asset_api_template Local simulation: \u00b6 To interact with a locally running simulation (backend simulation), username, passwords, domain and websocket names and simulation_id are not necessary. There is only an additional flag required in the CLI command : --run-on-redis . d3a-api-client --log-level INFO run --setup asset_api_template --run-on-redis Once the Asset SDK Script has been launched, you can click on \u201cRun\u201d in the Results page of your Collaboration in the User-Interface.","title":"Registration - Simulations run on the User-Interface"},{"location":"registration-asset-api-user-interface/#simulation-configuration-file","text":"The simulation configuration file is a JSON format file downloadable on the User-Interface . It contains all the information about the simulation setup (username, simulation name and UUID, domain name, websocket domain name, global settings of the simulation and the registry, consisting of all the grid hierarchy including markets and assets and whether or not the user is connected to those). To download this file the user needs to go to the Registry page of the relevant collaboration/Canary Test Network and click on the top right edit icon and Download Exchange SDK Summary. To run the Asset API, you can run the following command by adapting the arguments to your case: gsy-e-sdk --log-level INFO run --setup asset_api_template -u username -p password -i absolute_path/my_simulation_config.json","title":"Simulation configuration file:"},{"location":"registration-asset-api-user-interface/#cli-command","text":"Instead of passing the JSON file, the user can directly pass the relevant variables as arguments in the CLI commands. For that to work, the user needs to pass the domain name and websocket name (both are optional parameters and only relevant when connecting to specific domains) and the simulation_id. The simulation_id corresponds to the Universally Unique Identifier. This token can be found in the URL of a collaboration or a Canary Test Network in the User Interface. To run the Asset API, users can run the following command by adapting the arguments to their case: gsy-e-sdk --log-level INFO run --setup asset_api_template -u username -p password --simulation-id UUID","title":"CLI command:"},{"location":"registration-asset-api-user-interface/#environnement-variables","text":"The last method to launch the API is send the set the required variable in the environment. To do that users can simply define those parameters at the top of their script as follows: os.environ[\"API_CLIENT_USERNAME\"] = \"username\" os.environ[\"API_CLIENT_PASSWORD\"] = \"password\" os.environ[\"API_CLIENT_SIMULATION_ID\"] = \"simulation_uuid\" To run the Asset API, you can run the following command by adapting the arguments to your case: gsy-e-sdk --log-level INFO run --setup asset_api_template","title":"Environnement variables:"},{"location":"registration-asset-api-user-interface/#local-simulation","text":"To interact with a locally running simulation (backend simulation), username, passwords, domain and websocket names and simulation_id are not necessary. There is only an additional flag required in the CLI command : --run-on-redis . d3a-api-client --log-level INFO run --setup asset_api_template --run-on-redis Once the Asset SDK Script has been launched, you can click on \u201cRun\u201d in the Results page of your Collaboration in the User-Interface.","title":"Local simulation:"},{"location":"registration-grid-operator-api-backend/","text":"Start Redis server \u00b6 To use the API locally, your script interacts with the simulation using a local Redis instance. To start the redis instance, open a new terminal and run the following command : redis-server /usr/local/etc/redis.conf To install redis in Ubuntu follow the instructions in this link . Open Markets for external cnnection \u00b6 The API supports multiple markets managed with the Grid Operator API. Access is controlled when setting up the simulation, using the Market and Asset classes\u2019 boolean argument called external_connection_available: Market( 'Community', [ ... ], grid_fee_constant=4, external_connection_available=True), If set to True , the market allows all the Grid Operator API to connect to that market, receive statistics and change grid fees. By default, this external_connection_available is set to False . Launch simulation \u00b6 This requires you to have the backend codebase installed on your machine to run simulations (see Installation Instructions ). First, navigate to the Grid Singularity folder (currently still D3A) in a new terminal, then activate the Grid Singularity (currently still D3A) environment with the command: workon gsy-env Then, launch the simulation by running the following command and adapting the arguments to your case and wait for the SDK Script to execute: gsy-env -l INFO run -t 15s -s 15m --setup api_setup.default_community --slot-length-realtime 5 --start-date 2021-07-01 --enable-external-connection --paused After few seconds, the simulation should begin, waiting for the API template as mentioned in the figure below: Here you can find more information on launching a simulation on the backend . Initialise and start the API : \u00b6 Before launching the SDK Script, users need to adapt the following information in their script: Oracle name \u00b6 This parameter is only relevant when using the API on the User-Interface. This defines the name of the aggregator / API name that manages the markets and energy assets. Once the name is set it cannot be changed within the same running collaboration. oracle_name = 'dso' Markets list \u00b6 The list of markets needs to be updated to include the assets registered to user through the registration process, in arrays as follows : market_names = [\"Grid\", \"Community\"] market_names = [\"Grid\", \"Community\"] The SDK Script has an \u201cautomatic\u201d connection process to manage energy assets. If the function automatic is True, the Exchange SDK will automatically connect to all energy assets that it is registered to. This option is only available for simulations running on the User-Interface. Interact with local simulations \u00b6 To interact with a locally running simulation (backend simulation), username, passwords, domain and websocket names and simulation_id are not necessary. There is only an additional flag required in the CLI command : --run-on-redis. gsy-e-sdk --log-level INFO run --setup gird_operator_api_template --run-on-redis Log levels: \u00b6 The API CLI command can receive a --log-level argument. Adjusting this parameter will increase or reduce the level of information displayed in the terminal, while the agent is running. There are 4 levels (classed from low detailed to high: ERROR \u00b6 Display only critical errors from the Exchange SDK or the Grid Singularity Exchange (for instance, if Grid Singularity Exchange responds with an error in a command that the Exchange SDK is sending, the error log should include it) WARNING \u00b6 Display non-critical error messages (for instance if the API agent is over bidding its energy requirement) INFO \u00b6 Display critical and non-critical errors messages and general information such as market progression and trades DEBUG \u00b6 Display full information on the agent (for instance all command and response, such as placing bids and offers on the market) For a video tutorial on the Asset API, please follow this link . We recommend that the users experiment with trading strategies, verify their data and familiarize themselves with the Grid Singularity user interface and APIs in a Collaboration environment before initiating a Canary Test Network.","title":"Registration - Simulations run on the Backend"},{"location":"registration-grid-operator-api-backend/#start-redis-server","text":"To use the API locally, your script interacts with the simulation using a local Redis instance. To start the redis instance, open a new terminal and run the following command : redis-server /usr/local/etc/redis.conf To install redis in Ubuntu follow the instructions in this link .","title":"Start Redis server"},{"location":"registration-grid-operator-api-backend/#open-markets-for-external-cnnection","text":"The API supports multiple markets managed with the Grid Operator API. Access is controlled when setting up the simulation, using the Market and Asset classes\u2019 boolean argument called external_connection_available: Market( 'Community', [ ... ], grid_fee_constant=4, external_connection_available=True), If set to True , the market allows all the Grid Operator API to connect to that market, receive statistics and change grid fees. By default, this external_connection_available is set to False .","title":"Open Markets for external cnnection"},{"location":"registration-grid-operator-api-backend/#launch-simulation","text":"This requires you to have the backend codebase installed on your machine to run simulations (see Installation Instructions ). First, navigate to the Grid Singularity folder (currently still D3A) in a new terminal, then activate the Grid Singularity (currently still D3A) environment with the command: workon gsy-env Then, launch the simulation by running the following command and adapting the arguments to your case and wait for the SDK Script to execute: gsy-env -l INFO run -t 15s -s 15m --setup api_setup.default_community --slot-length-realtime 5 --start-date 2021-07-01 --enable-external-connection --paused After few seconds, the simulation should begin, waiting for the API template as mentioned in the figure below: Here you can find more information on launching a simulation on the backend .","title":"Launch simulation"},{"location":"registration-grid-operator-api-backend/#initialise-and-start-the-api","text":"Before launching the SDK Script, users need to adapt the following information in their script:","title":"Initialise and start the API :"},{"location":"registration-grid-operator-api-backend/#oracle-name","text":"This parameter is only relevant when using the API on the User-Interface. This defines the name of the aggregator / API name that manages the markets and energy assets. Once the name is set it cannot be changed within the same running collaboration. oracle_name = 'dso'","title":"Oracle name"},{"location":"registration-grid-operator-api-backend/#markets-list","text":"The list of markets needs to be updated to include the assets registered to user through the registration process, in arrays as follows : market_names = [\"Grid\", \"Community\"] market_names = [\"Grid\", \"Community\"] The SDK Script has an \u201cautomatic\u201d connection process to manage energy assets. If the function automatic is True, the Exchange SDK will automatically connect to all energy assets that it is registered to. This option is only available for simulations running on the User-Interface.","title":"Markets list"},{"location":"registration-grid-operator-api-backend/#interact-with-local-simulations","text":"To interact with a locally running simulation (backend simulation), username, passwords, domain and websocket names and simulation_id are not necessary. There is only an additional flag required in the CLI command : --run-on-redis. gsy-e-sdk --log-level INFO run --setup gird_operator_api_template --run-on-redis","title":"Interact with local simulations"},{"location":"registration-grid-operator-api-backend/#log-levels","text":"The API CLI command can receive a --log-level argument. Adjusting this parameter will increase or reduce the level of information displayed in the terminal, while the agent is running. There are 4 levels (classed from low detailed to high:","title":"Log levels:"},{"location":"registration-grid-operator-api-backend/#error","text":"Display only critical errors from the Exchange SDK or the Grid Singularity Exchange (for instance, if Grid Singularity Exchange responds with an error in a command that the Exchange SDK is sending, the error log should include it)","title":"ERROR"},{"location":"registration-grid-operator-api-backend/#warning","text":"Display non-critical error messages (for instance if the API agent is over bidding its energy requirement)","title":"WARNING"},{"location":"registration-grid-operator-api-backend/#info","text":"Display critical and non-critical errors messages and general information such as market progression and trades","title":"INFO"},{"location":"registration-grid-operator-api-backend/#debug","text":"Display full information on the agent (for instance all command and response, such as placing bids and offers on the market) For a video tutorial on the Asset API, please follow this link . We recommend that the users experiment with trading strategies, verify their data and familiarize themselves with the Grid Singularity user interface and APIs in a Collaboration environment before initiating a Canary Test Network.","title":"DEBUG"},{"location":"registration-grid-operator-api-user-interface/","text":"To Launch the Grid Operator API from the User-Interface, please follow the same instructions given for the Asset API here .","title":"Registration - Simulations run on the User-Interface"},{"location":"registration-matching-api-backend/","text":"For local test runs of Grid Singularity Exchange (backend simulation), redis is used as a communication protocol. Install Redis server \u00b6 To install the Redis server, open a new terminal window and type: brew install redis To install redis in Ubuntu follow the instructions in this link . To start the redis instance, open a new terminal and run the following command: redis-server /usr/local/etc/redis.conf The path for the Redis server would be the location where the Redis is installed in your system. Install the myco-api-client \u00b6 Make a new virtual environment for the Matching API client: mkvirtualenv gsy-myco-sdk Clone the GitHub directory of the Myco client: pip clone git+https://github.com/gridsingularity/gsy-myco-sdk.git Install the requirements: pip install - e. Enabling external connection for clearing the market \u00b6 To register an asset through API and to use an external matching algorithm it is required to specify the following line in the exchange setup file: ConstSettings.MASettings.MARKET_TYPE = 2 ConstSettings.MASettings.BID_OFFER_MATCH_TYPE = (BidOfferMatchAlgoEnum.EXTERNAL.value) An example simulation setup can be found here. For more information on how to build this setup and add more markets and assets please visit this page. Launch Simulation \u00b6 Once the entire grid architecture is modeled, including energy assets, the user can launch the simulation by running a command-line including desired setup features: gsy-e -l INFO run -t 10s -s 15m --setup myco_setup.external_myco --enable-external-connection --paused --slot-length-realtime 12 After a few seconds, the simulation should begin, waiting for the API template as mentioned in the figure below: Initialise and start the API: \u00b6 The Matching API is launched with a cli command. To launch the Matching API, the user needs to open a new terminal and activate the Myco-SDK environment: workon gsy-myco-sdk Now, go to the Myco-SDK directory: cd path_to_directory/gsy-myco-sdk The api launch CLI command takes several arguments that can be listed with: gsy-myco-sdk run --help The arguments are: base-setup-path --> Set the base path where the user's client script resides, otherwise, gsy_myco_sdk/setups are taken as default for the user's client scripts. Users can provide either an absolute or a relative file path. setup --> Name of user's Matching API module/script. username --> Username of the agent authorized to communicate with respective collaboration/CN. password --> Password of the respective agent domain-name --> GSy-e domain name web-socket --> GSy-e WebSocket URI simulation-id --> UUID of the collaboration or Canary Network (CN) run-on-redis --> This flag targets the local testing of the Myco SDK, where no user authentication is required. A locally running redis server and gsy-e simulation are needed here. Interact with local simulations \u00b6 To interact with a locally running simulation (backend simulation), username, passwords, domain and websocket names and simulation_id are not necessary. There is only an additional flag required in the CLI command : --run-on-redis. gsy-myco-sdk --log-level INFO run --setup matching_api_template --run-on-redis Log levels: \u00b6 The API CLI command can receive a --log-level argument. Adjusting this parameter will increase or reduce the level of information displayed in the terminal, while the agent is running. There are 4 levels (classed from low detailed to high: ERROR \u00b6 Display only critical errors from the Exchange SDK or the Grid Singularity Exchange (for instance, if Grid Singularity Exchange responds with an error in a command that the Exchange SDK is sending, the error log should include it) WARNING \u00b6 Display non-critical error messages (for instance if the API agent is over bidding its energy requirement) INFO \u00b6 Display critical and non-critical errors messages and general information such as market progression and trades DEBUG \u00b6 Display full information on the agent (for instance all command and response, such as placing bids and offers on the market)","title":"Registration - Simulations run on the Backend"},{"location":"registration-matching-api-backend/#install-redis-server","text":"To install the Redis server, open a new terminal window and type: brew install redis To install redis in Ubuntu follow the instructions in this link . To start the redis instance, open a new terminal and run the following command: redis-server /usr/local/etc/redis.conf The path for the Redis server would be the location where the Redis is installed in your system.","title":"Install Redis server"},{"location":"registration-matching-api-backend/#install-the-myco-api-client","text":"Make a new virtual environment for the Matching API client: mkvirtualenv gsy-myco-sdk Clone the GitHub directory of the Myco client: pip clone git+https://github.com/gridsingularity/gsy-myco-sdk.git Install the requirements: pip install - e.","title":"Install the myco-api-client"},{"location":"registration-matching-api-backend/#enabling-external-connection-for-clearing-the-market","text":"To register an asset through API and to use an external matching algorithm it is required to specify the following line in the exchange setup file: ConstSettings.MASettings.MARKET_TYPE = 2 ConstSettings.MASettings.BID_OFFER_MATCH_TYPE = (BidOfferMatchAlgoEnum.EXTERNAL.value) An example simulation setup can be found here. For more information on how to build this setup and add more markets and assets please visit this page.","title":"Enabling external connection for clearing the market"},{"location":"registration-matching-api-backend/#launch-simulation","text":"Once the entire grid architecture is modeled, including energy assets, the user can launch the simulation by running a command-line including desired setup features: gsy-e -l INFO run -t 10s -s 15m --setup myco_setup.external_myco --enable-external-connection --paused --slot-length-realtime 12 After a few seconds, the simulation should begin, waiting for the API template as mentioned in the figure below:","title":"Launch Simulation"},{"location":"registration-matching-api-backend/#initialise-and-start-the-api","text":"The Matching API is launched with a cli command. To launch the Matching API, the user needs to open a new terminal and activate the Myco-SDK environment: workon gsy-myco-sdk Now, go to the Myco-SDK directory: cd path_to_directory/gsy-myco-sdk The api launch CLI command takes several arguments that can be listed with: gsy-myco-sdk run --help The arguments are: base-setup-path --> Set the base path where the user's client script resides, otherwise, gsy_myco_sdk/setups are taken as default for the user's client scripts. Users can provide either an absolute or a relative file path. setup --> Name of user's Matching API module/script. username --> Username of the agent authorized to communicate with respective collaboration/CN. password --> Password of the respective agent domain-name --> GSy-e domain name web-socket --> GSy-e WebSocket URI simulation-id --> UUID of the collaboration or Canary Network (CN) run-on-redis --> This flag targets the local testing of the Myco SDK, where no user authentication is required. A locally running redis server and gsy-e simulation are needed here.","title":"Initialise and start the API:"},{"location":"registration-matching-api-backend/#interact-with-local-simulations","text":"To interact with a locally running simulation (backend simulation), username, passwords, domain and websocket names and simulation_id are not necessary. There is only an additional flag required in the CLI command : --run-on-redis. gsy-myco-sdk --log-level INFO run --setup matching_api_template --run-on-redis","title":"Interact with local simulations"},{"location":"registration-matching-api-backend/#log-levels","text":"The API CLI command can receive a --log-level argument. Adjusting this parameter will increase or reduce the level of information displayed in the terminal, while the agent is running. There are 4 levels (classed from low detailed to high:","title":"Log levels:"},{"location":"registration-matching-api-backend/#error","text":"Display only critical errors from the Exchange SDK or the Grid Singularity Exchange (for instance, if Grid Singularity Exchange responds with an error in a command that the Exchange SDK is sending, the error log should include it)","title":"ERROR"},{"location":"registration-matching-api-backend/#warning","text":"Display non-critical error messages (for instance if the API agent is over bidding its energy requirement)","title":"WARNING"},{"location":"registration-matching-api-backend/#info","text":"Display critical and non-critical errors messages and general information such as market progression and trades","title":"INFO"},{"location":"registration-matching-api-backend/#debug","text":"Display full information on the agent (for instance all command and response, such as placing bids and offers on the market)","title":"DEBUG"},{"location":"registration-matching-api-user-interface/","text":"Currently, it is not possible to connect to the Matching API through the User-Interface .","title":"Registration - Simulations run on the User-Interface"},{"location":"releases/","text":"Version 1.5 \u00b6 The following features were implemented: An updated energy bills table shows the amount of energy communities or homes are buying and selling in the market Simulation results can be filtered by week to view the results for individual weeks Users can request a Grid Singularity Canary Test Network , a real-time test network version of a local energy market that uses real asset data when available. Requesting a Canary Network will give information about the process and requirements to set up a local energy community in your region, within regulation. A first step to setting up a Canary Network is connecting asset data sources to the simulation. Individual users can apply to participate in Canary Networks through a registry , where the exchange operator grants or denies access. Users can be invited to register through an invitation tool, and can see a list of Canary Networks to which they have been invited. Aggregators can apply through the registry to manage (i.e. run trading algorithms on behalf of) assets through the Asset API Assets can be configured to read live or uploaded data that has been sent through a live data API . The details of setting up live asset data through the API can be found here. Template scripts are available for aggregators or advanced users to trade energy through the Asset trading API. The scripts, documentation and additional information can be found here. Grid operators can also run scripts that set and change grid fees for the exchange. Both template scripts include readable text outputs from the trading or grid fee strategy Canary network results are viewable real-time, with data and trading results populated in 15 minute intervals. Results for previous weeks are available by selecting the week at the top of results. Users can view and duplicate public simulations on the map, allowing experimentation and rapid prototyping. Grid Singularity v1.5 Tutorial Version 1.4 \u00b6 The following features were implemented: A map legend has been added to clarify how colors on the map represent the exporting or importing of energy Users can add a profile picture to personalize their account by clicking on their name Custom assets can be added to a home with configurable production / consumption quantity or storage capacity through the advanced menu. Custom PVs can be added which use the energydatamap.com API, allowing a production forecast to be used for the simulation\u2019s geographical location. Advanced custom PV settings allow users to set the orientation of the PV (e.g. flat, tilted, facade) and azimuth and tilt. A list view navigation shows all assets in a home and community. Clicking on an asset allows further configuration. Key results have been simplified for easier reference, including community self-sufficiency and self-consumption with information about what the metrics mean. A Savings KPI has been introduced for each home in the community, showing if and how much a home has been saving compared to buying from the local utility. The total bill including amount owed or earned is shown, along with a graph of the daily savings. Asset result highlights the total amount spent or earnt by each asset, including an average price per kWh of energy. Batteries also show their current state of charge and average buying and selling price. Grid Singularity v1.4 Tutorial Version 1.0.0 \u00b6 The following features were implemented : Our new user interface (UI), found at Grid Singularity map will replace the old one at d3a.io . This new UI is intended to make creating and running simulations much easier for users who might be new to thinking about their energy use and simulating their own energy community. Additional features in the map include a search bar , which facilitates searching for an address or town on the map. After running the simulation, highlighted results displayed directly above each home and community in the map. There are standard (template) homes and profiles that can be used by users who do not have information about actual energy consumption and/or production, generated from loadprofilegenerator.de and energydatamap.com . We provide additional information on the Canary Test Network for live data simulations, which is the next step in building an energy community Animated color visuals in the map view assist analysis, with a color assigned to each home and community on the map when the simulation is running: green for net exports, blue for neutral, and red for net imports We also provide Map 3D view, where users can view their simulations and homes in 3-Dimensions Side navigation bar summarizes the contents of a users\u2019 energy community to additionally aid optimal energy community configuration Smart meter asset, a new asset type which can be configured directly in the codebase simulation file to allow users to upload smart meter net consumption and production profiles Version 0.12.0 \u00b6 The following features were implemented : Market slot length realtime: This can be set to simulations and collaborations. It slows down the running pace with a constant value (speed can go from the fasted as possible up until real-time. Public library is updated: New loads and PVs profiles were added to the public library. A total of 24 loads, representing various types of households was generated using loadprofilegenerator.de . PV production profiles were taken from energydatamap.com for different cities. These new loads and PVs have profiles of a full year (2021). Users can now download the registry page as a JSON file, to facilitate the connection with the API to a collaboration/Canary Network. Version 0.11.0 \u00b6 The following features were implemented : Time Resolution setting for graphs: Users can choose to view data in the graphs in 2 hour, 1 hour, or 15 minutes time resolution. This allows for faster loading of the graphs as the simulation run time is extended. Users can change the time resolution for the Energy Trade Profile, Energy Pricing, and Asset Profile graphs. Add a Library as an Event : Users can add grid components from the Library into their simulation while it is running. Canary Network Enhancements: Canary Networks are automatically restarted in the event of a software deploy or other system disruption. Users can view previous weeks of Canary Network data and download the results . Canary Network simulations can run for weeks at a time and store all data for future analysis and research. Users can trade through the Grid Singularity Asset and Grid Operator APIs through a cloud web service. This feature allows users to automate their trading algorithms and connect to the API from the cloud instead of hosting and monitoring on a local computer. Version 0.10.0 \u00b6 The following features were implemented : Canary Networks : An admin user can create a Canary Network simulation, which duplicates a collaboration simulation and allows the admin to connect each energy asset in the grid to its live data stream in order to simulate trading on the asset's live metered data readings. The Canary Network runs in real-time , with incoming data collected during each 15 minute market slot. Researcher users can trade on behalf of energy assets using the registry to connect to the live data stream which broadcasts the energy required for each asset through the Asset API . Grid Operator users can change the grid fees and grid parameters of each grid market using the registry which connects them to their markets through the Grid Operator API . Therefore, the Canary Network realizes the digital twin model of an energy asset and enables Researcher users to trade in real-time on behalf of their assets as a proof of concept. Once a Canary Network is established, it continues to run and agents can trade over weeks and months of time, for long term study of energy asset data and agent and market behavior. Previous weeks of data and results are saved in the results page weekly history. Island or Grid-connect a Market Maker as an event: Users can now change the role and mode of the Market Maker as an event, allowing users to simulate blackouts by changing the Market Maker to an islanding role, or simulating other impacts resulting from a change in the Market Maker parameters, such as showing the effect of connecting an islanded Market Maker to the grid. Version 0.9.0 \u00b6 The following features were implemented : Market API , which allows grid operators and researchers to monitor metrics and set grid fees in the select local energy market simulation collaboration Easier registration for researchers and grid operators to manage multiple assets and use market API through the Registry page. Bids and offers are prioritised in their first market by setting a wait time of 2 ticks before allowing them to propagate to higher markets in the grid hierarchy. This wait time is set in the backend as the minimum bid or offer age parameter. Grid fees integrated in the Results page - Energy Pricing graph for each market Total grid fees reported in the Scoreboard page that demonstrates market performance metrics for each collaboration simulation. Net Energy calculation added to Results page - Energy Trade Profile graph in order to calculate the peak energy at a market node in the simulation. The current peak imports and exports were previously calculated based on the cumulative trades, but are now calculated from the net energy consumption, which can be a net import or export. Updated load final selling rate and PV initial buying rate in the template strategies now take the total grid fees into account in addition to the market maker (usually utility) rate. Users can now run three simulations and/or collaborations at once (previous limit was two) Version 0.8.0 \u00b6 The following features were implemented : Simulation Location Map. Users can geo-tag all energy resources and markets in their simulation to make a map view of the simulation and results. A summary of all simulations can be viewed in a global map, to see where Grid Singularity is running simulations all over the world! Version 0.7.0 \u00b6 The following features were implemented : Detailed energy trade profile graph . Zoom in to each 15 minute market slot to view the scheduled trades with 1 minute resolution. Grid Operator user can change grid parameters inside a collaboration and while it is running, like grid fees or the transformer capacity. Allow collaboration participants to register for events while the simulation is running. Allows users to simulate a growing community. Information Aggregator to compile and send average market measurements to assist data scientists in building smart strategies to trade through the API . Version 0.6.0 \u00b6 The following features were implemented : Bid and Offer matching graph Analyze all bids, offers, and trades in a market and see why they match based on their strategies. Simulation events Add, delete, or update areas or energy resources in a simulation while it is running. This allows users to grow their simulations in real-time and analyze the impacts of energy resources coming online and changes to grid parameters such as grid fees. Timeline to view events and zoom in View all events in a timeline and click on each event to view its relevant grid configuration and results. Zoom in to view results for a specific day. Pause or stop a simulation Pause a simulation to freeze it while adding an event. Stop a simulation pre-maturely in order to run another version sooner. Configure an infinite bus as part of the Market Maker Configure an Infinite Bus in order to add a feed-in-tariff to the simulation. Version 0.5.0 \u00b6 The following features were implemented : Constant based Grid Fees Self Sufficiency, Self Consumption , and Energy Peak Percentage KPIs Simulation runtime status indicator Increased node limit to 1000 nodes Collaborations Scoreboard Select visible charts on Results page Colors for Energy Bills Bought and Sold Version 0.4.0 \u00b6 The following features were implemented : Grid fees configuration User roles, including 'Collaborations' feature for multi user testing and Grid Singularity-hosted challenges API connection to energy devices allowing bids and offers to be submitted by external algorithms Version 0.3.0 \u00b6 The following features were implemented : Run simulations with up to 250 nodes Compare results of two simulations side by side New navigation side bar with Home, Projects, and Library easily accessible Version 0.2.0 \u00b6 The following features were implemented : Run simulations for one week Choose your market type: additional access to two-sided pay as bid and two-sided pay as clear market types New user friendly device strategies Configure your market maker Scrollable graphs on the results page optimized for longer simulations Download simulation results","title":"Releases Archive"},{"location":"releases/#version-15","text":"The following features were implemented: An updated energy bills table shows the amount of energy communities or homes are buying and selling in the market Simulation results can be filtered by week to view the results for individual weeks Users can request a Grid Singularity Canary Test Network , a real-time test network version of a local energy market that uses real asset data when available. Requesting a Canary Network will give information about the process and requirements to set up a local energy community in your region, within regulation. A first step to setting up a Canary Network is connecting asset data sources to the simulation. Individual users can apply to participate in Canary Networks through a registry , where the exchange operator grants or denies access. Users can be invited to register through an invitation tool, and can see a list of Canary Networks to which they have been invited. Aggregators can apply through the registry to manage (i.e. run trading algorithms on behalf of) assets through the Asset API Assets can be configured to read live or uploaded data that has been sent through a live data API . The details of setting up live asset data through the API can be found here. Template scripts are available for aggregators or advanced users to trade energy through the Asset trading API. The scripts, documentation and additional information can be found here. Grid operators can also run scripts that set and change grid fees for the exchange. Both template scripts include readable text outputs from the trading or grid fee strategy Canary network results are viewable real-time, with data and trading results populated in 15 minute intervals. Results for previous weeks are available by selecting the week at the top of results. Users can view and duplicate public simulations on the map, allowing experimentation and rapid prototyping. Grid Singularity v1.5 Tutorial","title":"Version 1.5"},{"location":"releases/#version-14","text":"The following features were implemented: A map legend has been added to clarify how colors on the map represent the exporting or importing of energy Users can add a profile picture to personalize their account by clicking on their name Custom assets can be added to a home with configurable production / consumption quantity or storage capacity through the advanced menu. Custom PVs can be added which use the energydatamap.com API, allowing a production forecast to be used for the simulation\u2019s geographical location. Advanced custom PV settings allow users to set the orientation of the PV (e.g. flat, tilted, facade) and azimuth and tilt. A list view navigation shows all assets in a home and community. Clicking on an asset allows further configuration. Key results have been simplified for easier reference, including community self-sufficiency and self-consumption with information about what the metrics mean. A Savings KPI has been introduced for each home in the community, showing if and how much a home has been saving compared to buying from the local utility. The total bill including amount owed or earned is shown, along with a graph of the daily savings. Asset result highlights the total amount spent or earnt by each asset, including an average price per kWh of energy. Batteries also show their current state of charge and average buying and selling price. Grid Singularity v1.4 Tutorial","title":"Version 1.4"},{"location":"releases/#version-100","text":"The following features were implemented : Our new user interface (UI), found at Grid Singularity map will replace the old one at d3a.io . This new UI is intended to make creating and running simulations much easier for users who might be new to thinking about their energy use and simulating their own energy community. Additional features in the map include a search bar , which facilitates searching for an address or town on the map. After running the simulation, highlighted results displayed directly above each home and community in the map. There are standard (template) homes and profiles that can be used by users who do not have information about actual energy consumption and/or production, generated from loadprofilegenerator.de and energydatamap.com . We provide additional information on the Canary Test Network for live data simulations, which is the next step in building an energy community Animated color visuals in the map view assist analysis, with a color assigned to each home and community on the map when the simulation is running: green for net exports, blue for neutral, and red for net imports We also provide Map 3D view, where users can view their simulations and homes in 3-Dimensions Side navigation bar summarizes the contents of a users\u2019 energy community to additionally aid optimal energy community configuration Smart meter asset, a new asset type which can be configured directly in the codebase simulation file to allow users to upload smart meter net consumption and production profiles","title":"Version 1.0.0"},{"location":"releases/#version-0120","text":"The following features were implemented : Market slot length realtime: This can be set to simulations and collaborations. It slows down the running pace with a constant value (speed can go from the fasted as possible up until real-time. Public library is updated: New loads and PVs profiles were added to the public library. A total of 24 loads, representing various types of households was generated using loadprofilegenerator.de . PV production profiles were taken from energydatamap.com for different cities. These new loads and PVs have profiles of a full year (2021). Users can now download the registry page as a JSON file, to facilitate the connection with the API to a collaboration/Canary Network.","title":"Version 0.12.0"},{"location":"releases/#version-0110","text":"The following features were implemented : Time Resolution setting for graphs: Users can choose to view data in the graphs in 2 hour, 1 hour, or 15 minutes time resolution. This allows for faster loading of the graphs as the simulation run time is extended. Users can change the time resolution for the Energy Trade Profile, Energy Pricing, and Asset Profile graphs. Add a Library as an Event : Users can add grid components from the Library into their simulation while it is running. Canary Network Enhancements: Canary Networks are automatically restarted in the event of a software deploy or other system disruption. Users can view previous weeks of Canary Network data and download the results . Canary Network simulations can run for weeks at a time and store all data for future analysis and research. Users can trade through the Grid Singularity Asset and Grid Operator APIs through a cloud web service. This feature allows users to automate their trading algorithms and connect to the API from the cloud instead of hosting and monitoring on a local computer.","title":"Version 0.11.0"},{"location":"releases/#version-0100","text":"The following features were implemented : Canary Networks : An admin user can create a Canary Network simulation, which duplicates a collaboration simulation and allows the admin to connect each energy asset in the grid to its live data stream in order to simulate trading on the asset's live metered data readings. The Canary Network runs in real-time , with incoming data collected during each 15 minute market slot. Researcher users can trade on behalf of energy assets using the registry to connect to the live data stream which broadcasts the energy required for each asset through the Asset API . Grid Operator users can change the grid fees and grid parameters of each grid market using the registry which connects them to their markets through the Grid Operator API . Therefore, the Canary Network realizes the digital twin model of an energy asset and enables Researcher users to trade in real-time on behalf of their assets as a proof of concept. Once a Canary Network is established, it continues to run and agents can trade over weeks and months of time, for long term study of energy asset data and agent and market behavior. Previous weeks of data and results are saved in the results page weekly history. Island or Grid-connect a Market Maker as an event: Users can now change the role and mode of the Market Maker as an event, allowing users to simulate blackouts by changing the Market Maker to an islanding role, or simulating other impacts resulting from a change in the Market Maker parameters, such as showing the effect of connecting an islanded Market Maker to the grid.","title":"Version 0.10.0"},{"location":"releases/#version-090","text":"The following features were implemented : Market API , which allows grid operators and researchers to monitor metrics and set grid fees in the select local energy market simulation collaboration Easier registration for researchers and grid operators to manage multiple assets and use market API through the Registry page. Bids and offers are prioritised in their first market by setting a wait time of 2 ticks before allowing them to propagate to higher markets in the grid hierarchy. This wait time is set in the backend as the minimum bid or offer age parameter. Grid fees integrated in the Results page - Energy Pricing graph for each market Total grid fees reported in the Scoreboard page that demonstrates market performance metrics for each collaboration simulation. Net Energy calculation added to Results page - Energy Trade Profile graph in order to calculate the peak energy at a market node in the simulation. The current peak imports and exports were previously calculated based on the cumulative trades, but are now calculated from the net energy consumption, which can be a net import or export. Updated load final selling rate and PV initial buying rate in the template strategies now take the total grid fees into account in addition to the market maker (usually utility) rate. Users can now run three simulations and/or collaborations at once (previous limit was two)","title":"Version 0.9.0"},{"location":"releases/#version-080","text":"The following features were implemented : Simulation Location Map. Users can geo-tag all energy resources and markets in their simulation to make a map view of the simulation and results. A summary of all simulations can be viewed in a global map, to see where Grid Singularity is running simulations all over the world!","title":"Version 0.8.0"},{"location":"releases/#version-070","text":"The following features were implemented : Detailed energy trade profile graph . Zoom in to each 15 minute market slot to view the scheduled trades with 1 minute resolution. Grid Operator user can change grid parameters inside a collaboration and while it is running, like grid fees or the transformer capacity. Allow collaboration participants to register for events while the simulation is running. Allows users to simulate a growing community. Information Aggregator to compile and send average market measurements to assist data scientists in building smart strategies to trade through the API .","title":"Version 0.7.0"},{"location":"releases/#version-060","text":"The following features were implemented : Bid and Offer matching graph Analyze all bids, offers, and trades in a market and see why they match based on their strategies. Simulation events Add, delete, or update areas or energy resources in a simulation while it is running. This allows users to grow their simulations in real-time and analyze the impacts of energy resources coming online and changes to grid parameters such as grid fees. Timeline to view events and zoom in View all events in a timeline and click on each event to view its relevant grid configuration and results. Zoom in to view results for a specific day. Pause or stop a simulation Pause a simulation to freeze it while adding an event. Stop a simulation pre-maturely in order to run another version sooner. Configure an infinite bus as part of the Market Maker Configure an Infinite Bus in order to add a feed-in-tariff to the simulation.","title":"Version 0.6.0"},{"location":"releases/#version-050","text":"The following features were implemented : Constant based Grid Fees Self Sufficiency, Self Consumption , and Energy Peak Percentage KPIs Simulation runtime status indicator Increased node limit to 1000 nodes Collaborations Scoreboard Select visible charts on Results page Colors for Energy Bills Bought and Sold","title":"Version 0.5.0"},{"location":"releases/#version-040","text":"The following features were implemented : Grid fees configuration User roles, including 'Collaborations' feature for multi user testing and Grid Singularity-hosted challenges API connection to energy devices allowing bids and offers to be submitted by external algorithms","title":"Version 0.4.0"},{"location":"releases/#version-030","text":"The following features were implemented : Run simulations with up to 250 nodes Compare results of two simulations side by side New navigation side bar with Home, Projects, and Library easily accessible","title":"Version 0.3.0"},{"location":"releases/#version-020","text":"The following features were implemented : Run simulations for one week Choose your market type: additional access to two-sided pay as bid and two-sided pay as clear market types New user friendly device strategies Configure your market maker Scrollable graphs on the results page optimized for longer simulations Download simulation results","title":"Version 0.2.0"},{"location":"results-community/","text":"Key Results for the community are shown, detailing self-sufficiency and self-consumption. Figure 2.17 . Key results The next results show the total number of energy assets contained within the energy community, categorised according to asset type. Figure 2.18 . Community Assets list. The first graphic in bills and traded energy is the Savings KPI, showing how much money has been saved by trading in the local energy community vs. how much would have been paid buying solely from the local utility. Figure 2.19 . Savings KPI for a home with 2 assets Each asset also has a key results page, showing a summary of the amount of energy bought or sold and the price of energy. Figure 2.20 . Asset key results for a solar panel","title":"Results community"},{"location":"results-dashboard/","text":"The Results Dashboard illustrates the results of a simulated energy community. It updates while the simulation is running and stored indefinitely until the user decides to delete or to rerun the simulation. The user is able to view Results for each market or asset in the grid configuration. The results automatically load for the community as a whole, however users can see home-specific results by clicking on a home on the map.","title":"Results dashboard"},{"location":"results-download/","text":"After successfully running a simulation in Grid Singularity\u2019s User Interface, the user can download the results file for a deeper analysis. The downloaded folder is organised into two subfolders with relevant files, as follows: Aggregated_results : area_throughput.json : Imported/exported energy for each market slot : Bills.json : Energy bills of all markets and energy assets (more details here ) Cumulative_bills.json : Total energy bills (spent & earned) Cumulative_grid_trades.json : Total energy traded for each market and energy asset and their penalty (for not trading their required energy) asset_statistics.json : asset profiles, energy traded, energy rates (min and max) for each asset each market slot Energy_trade_profile.json : Energy traded in each market Kpi.json : Self-consumption and self-sufficiency (in %), total energy demanded, generated and self-consumed Price_energy_day.json : Min, avg, max and grid fee rates for each market each market slot Progress_info.json : time remaining, simulation duration and percentage completed (if the simulation is complete eta_seconds should report 0 and percentage_completed should report 100) Random_seed.json : Random seed number used in the randomization process for specific events. This can mean the same simulation run multiple times may have slightly different results, as the posting order of bids and offers and matching trades can differ in certain situations (such as when two bids for the same price are randomly selected to be matched with one offer), causing some trades and bills to be different. Simulation_id.json : UUID of the simulation (can also be found in the simulation URL) Status.json : Status of the simulation Unmatched_loads.json : Number of unmatched load per markets reported each market slot bids_offers_trades : The folder structure follows the same logic as the simulation\u2019s grid hierarchy. There are three different csv files : *_bids.csv : Lists every bid posted on the relevant market including their volume, rate and buyer\u2019s name *_offers.csv : Lists every offer posted on the relevant market including their volume, rate and seller\u2019s name *_trades.csv : Lists each traded including their volume, rate, buyer\u2019s and seller\u2019s name","title":"Results Download"},{"location":"results/","text":"User Interface Results \u00b6 Grid Singularity\u2019s UI offers visual representations of simulation results. These are updated while the simulation is running and stored indefinitely until the user decides to delete or to rerun the simulation. The user is able to view Results for each area or asset in the grid configuration. Navigating the grid configuration in the UI \u00b6 As shown in the image above, the user can select a market or an energy asset from a drop down to view specific results for that market or an asset while on the Results page. In the figure above, the Community market is selected. The Results page then displays relevant plots and tables for the selected market or asset. There is also the possibility to select which charts / tables you want to view / hide, as shown in the image above. This section discusses the information available in each chart / table. Energy availability \u00b6 This plot shows whether each consuming energy asset (i.e. load) inside the selected market had access to the energy it needed for each market slot. On the x-axis, the time is given. If the participating asset agent was able to purchase the energy it required for that time slot, the block will be colored green . If not, it will be colored purple . The granularity of the plot is one hour , so if there was a trade interval within the hour in which the agent was not able to buy the demanded energy, the entire block will be colored purple. The user can hover the cursor over a purple block to view a list of the energy assets that were not able to buy energy in that time slot. Self-sufficiency and self-consumption \u00b6 These two pie charts display Self-Sufficiency and Self-Consumption level of the selected area. Please see this page for more information. When the user hovers the cursor over these plots, the following quantitative energy metrics are shown: Self-consumed energy [kWh] Total demanded energy [kWh] Total produced energy [kWh] Cumulative trading \u00b6 This plot shows the total cumulative trade volumes traded among market participants (agents representing assets or markets) in the selected market in the course of the simulation. Each market participant is displayed as a uniquely colored bar that represents the energy sold (shown as negative) or bought (shown as positive). In the example below, the energy sold by House 1 is colored purple, and the House 1 bar is positive, meaning that it bought some of the energy it produced for its own use (self-consumption). The rest of the energy it sold is shown as a thin purple layer appearing in the bars of the other market participants that acted as buyers. This color coding allows the user to visually track the energy trade flows in the selected market. External Trades represent the import/export from/to a higher level market by the Inter-area agent of the selected market, and hence the difference between energy traded amongst the selected market participants and the total accumulated trades. The external trades bar represents energy produced in this market, but sold to an outside market, as well as the energy bought from an external source and sold to a participant in this market. The energy bought externally is teal in this example and the bar is negative for external trades. The energy that was sold to other market participants is indicated by a positive teal colored bar. A negative external trades bar means that the participants within the select market purchased energy externally and a positive external trades bar means that participants sold energy to an external market. Energy bills and net energy \u00b6 In the Community market shown in the figure below, the participating agents are the inter-area agents of the houses that lie within that market. The energy bill table provides information on the cumulative trade volumes of all market participants and the costs associated with trades. For each market and energy asset, the energy bought and sold during the simulation is listed, along with a total net energy consumption. The Totals column can be considered as the net energy consumption and final bill for the listed agent, which may represent an energy asset or a market (e.g. a house). The Totals row represents the total of trades that are made by all participants inside the selected market. Energy trade profile \u00b6 The energy profile shows the supply and demand of trades made inside the selected market for each market slot of the simulation. The negative side of the y-axis represents the energy sold, and the positive y-axis shows the energy bought. The different colors represent the different market participants (energy assets and markets). As all buyers and sellers of each trade are accounted for in a select market, the supply and demand sides are exact mirrors of each other in terms of volume. If peak analysis is switched on, the internal trades are hidden and only the trades including external participants are displayed. This shows how much energy required the use of transmission lines outside of the selected market. On the peak analysis plot, two lines are shown: the current peak imports and the current peak exports , representing the maximum energy imported and exported for the selected market. Another feature of this graph is viewing the Net energy , shown below. When peak analysis is activated, only net external trades of each participant are displayed. The net displays the difference between the total import and export for each market slot, useful in understanding the impact to transmission capacity . Detailed energy trade profile \u00b6 This graph is a market slot level breakdown of the energy trade profile. With this graph, the user can select a specific market slot to see when each trade was cleared during that slot, with a resolution of 30 simulated seconds. The graph's length is the market slot length (15 minutes by default). The market slot can be selected with the drop down (days) and the slider (hours and minutes). Energy pricing \u00b6 In this plot, energy pricing is shown. Depending on market design and grid configuration, there could be different price settlements in the same market slot. In this case, a minimum , maximum , and average of the trade price is shown. If no trade occurred during a certain market interval, no lines are plotted. If grid fees are set in that market as a constant value, a fourth line is plotted to reflect its price. Bids, Offers, and Trades per Market Slot \u00b6 In this plot, each bid, offer and trade posted/cleared in the selected market is shown according to its posting/clearing times, allowing the user to analyse how specific offers/bids were or were not matched and validate or further investigate their trading strategy. The x-axis of this graph is the market slot length (15 minutes by default), and the y-axis shows the bid and offer price. Each market slot of the simulation can be selected and viewed with the drop down (days) and the slider (hours & minutes). Compare results \u00b6 The user has the possibility to compare the results of two separate simulations. The user can also duplicate the simulation setup, download results or delete the configuration by using the appropriate buttons shown below: Backend Results \u00b6 After running a simulation in the backend, the user can export simulation results. This functionality is enabled by default. If you want to disable the export of simulation results, use the --no-export flag for the simulation run. Another useful parameter is: --export-path , used to change the output path of the simulation results. The default path is $HOME/d3a-simulation/ . The simulation results include analytical information about the bids, offers and trades that took place in the course of the simulation. Information about energy characteristics of each asset and market are also included (eg. battery state of charge, energy traded/requested/deficit). A detailed description of these files is available on the data download page. In addition to text files, some graphs that display aggregated market information during the course of the simulation are also exposed. These can be found under the plot directory and are very similar to the ones available in the UI : unmatched_loads_*.html : Plots the volume of energy that loads have not been able to purchase (power outage) energy_profile_*.html : Similar plot to energy trade profile average_trade_price_*.html : Similar plot to energy pricing asset_profile_*.html : each energy asset within the simulation has its own plot showing its profile (consumption, generation, State of Charge), the actual energy traded and energy rates.","title":"Results"},{"location":"results/#user-interface-results","text":"Grid Singularity\u2019s UI offers visual representations of simulation results. These are updated while the simulation is running and stored indefinitely until the user decides to delete or to rerun the simulation. The user is able to view Results for each area or asset in the grid configuration.","title":"User Interface Results"},{"location":"results/#navigating-the-grid-configuration-in-the-ui","text":"As shown in the image above, the user can select a market or an energy asset from a drop down to view specific results for that market or an asset while on the Results page. In the figure above, the Community market is selected. The Results page then displays relevant plots and tables for the selected market or asset. There is also the possibility to select which charts / tables you want to view / hide, as shown in the image above. This section discusses the information available in each chart / table.","title":"Navigating the grid configuration in the UI"},{"location":"results/#energy-availability","text":"This plot shows whether each consuming energy asset (i.e. load) inside the selected market had access to the energy it needed for each market slot. On the x-axis, the time is given. If the participating asset agent was able to purchase the energy it required for that time slot, the block will be colored green . If not, it will be colored purple . The granularity of the plot is one hour , so if there was a trade interval within the hour in which the agent was not able to buy the demanded energy, the entire block will be colored purple. The user can hover the cursor over a purple block to view a list of the energy assets that were not able to buy energy in that time slot.","title":"Energy availability"},{"location":"results/#self-sufficiency-and-self-consumption","text":"These two pie charts display Self-Sufficiency and Self-Consumption level of the selected area. Please see this page for more information. When the user hovers the cursor over these plots, the following quantitative energy metrics are shown: Self-consumed energy [kWh] Total demanded energy [kWh] Total produced energy [kWh]","title":"Self-sufficiency and self-consumption"},{"location":"results/#cumulative-trading","text":"This plot shows the total cumulative trade volumes traded among market participants (agents representing assets or markets) in the selected market in the course of the simulation. Each market participant is displayed as a uniquely colored bar that represents the energy sold (shown as negative) or bought (shown as positive). In the example below, the energy sold by House 1 is colored purple, and the House 1 bar is positive, meaning that it bought some of the energy it produced for its own use (self-consumption). The rest of the energy it sold is shown as a thin purple layer appearing in the bars of the other market participants that acted as buyers. This color coding allows the user to visually track the energy trade flows in the selected market. External Trades represent the import/export from/to a higher level market by the Inter-area agent of the selected market, and hence the difference between energy traded amongst the selected market participants and the total accumulated trades. The external trades bar represents energy produced in this market, but sold to an outside market, as well as the energy bought from an external source and sold to a participant in this market. The energy bought externally is teal in this example and the bar is negative for external trades. The energy that was sold to other market participants is indicated by a positive teal colored bar. A negative external trades bar means that the participants within the select market purchased energy externally and a positive external trades bar means that participants sold energy to an external market.","title":"Cumulative trading"},{"location":"results/#energy-bills-and-net-energy","text":"In the Community market shown in the figure below, the participating agents are the inter-area agents of the houses that lie within that market. The energy bill table provides information on the cumulative trade volumes of all market participants and the costs associated with trades. For each market and energy asset, the energy bought and sold during the simulation is listed, along with a total net energy consumption. The Totals column can be considered as the net energy consumption and final bill for the listed agent, which may represent an energy asset or a market (e.g. a house). The Totals row represents the total of trades that are made by all participants inside the selected market.","title":"Energy bills and net energy"},{"location":"results/#energy-trade-profile","text":"The energy profile shows the supply and demand of trades made inside the selected market for each market slot of the simulation. The negative side of the y-axis represents the energy sold, and the positive y-axis shows the energy bought. The different colors represent the different market participants (energy assets and markets). As all buyers and sellers of each trade are accounted for in a select market, the supply and demand sides are exact mirrors of each other in terms of volume. If peak analysis is switched on, the internal trades are hidden and only the trades including external participants are displayed. This shows how much energy required the use of transmission lines outside of the selected market. On the peak analysis plot, two lines are shown: the current peak imports and the current peak exports , representing the maximum energy imported and exported for the selected market. Another feature of this graph is viewing the Net energy , shown below. When peak analysis is activated, only net external trades of each participant are displayed. The net displays the difference between the total import and export for each market slot, useful in understanding the impact to transmission capacity .","title":"Energy trade profile"},{"location":"results/#detailed-energy-trade-profile","text":"This graph is a market slot level breakdown of the energy trade profile. With this graph, the user can select a specific market slot to see when each trade was cleared during that slot, with a resolution of 30 simulated seconds. The graph's length is the market slot length (15 minutes by default). The market slot can be selected with the drop down (days) and the slider (hours and minutes).","title":"Detailed energy trade profile"},{"location":"results/#energy-pricing","text":"In this plot, energy pricing is shown. Depending on market design and grid configuration, there could be different price settlements in the same market slot. In this case, a minimum , maximum , and average of the trade price is shown. If no trade occurred during a certain market interval, no lines are plotted. If grid fees are set in that market as a constant value, a fourth line is plotted to reflect its price.","title":"Energy pricing"},{"location":"results/#bids-offers-and-trades-per-market-slot","text":"In this plot, each bid, offer and trade posted/cleared in the selected market is shown according to its posting/clearing times, allowing the user to analyse how specific offers/bids were or were not matched and validate or further investigate their trading strategy. The x-axis of this graph is the market slot length (15 minutes by default), and the y-axis shows the bid and offer price. Each market slot of the simulation can be selected and viewed with the drop down (days) and the slider (hours & minutes).","title":"Bids, Offers, and Trades per Market Slot"},{"location":"results/#compare-results","text":"The user has the possibility to compare the results of two separate simulations. The user can also duplicate the simulation setup, download results or delete the configuration by using the appropriate buttons shown below:","title":"Compare results"},{"location":"results/#backend-results","text":"After running a simulation in the backend, the user can export simulation results. This functionality is enabled by default. If you want to disable the export of simulation results, use the --no-export flag for the simulation run. Another useful parameter is: --export-path , used to change the output path of the simulation results. The default path is $HOME/d3a-simulation/ . The simulation results include analytical information about the bids, offers and trades that took place in the course of the simulation. Information about energy characteristics of each asset and market are also included (eg. battery state of charge, energy traded/requested/deficit). A detailed description of these files is available on the data download page. In addition to text files, some graphs that display aggregated market information during the course of the simulation are also exposed. These can be found under the plot directory and are very similar to the ones available in the UI : unmatched_loads_*.html : Plots the volume of energy that loads have not been able to purchase (power outage) energy_profile_*.html : Similar plot to energy trade profile average_trade_price_*.html : Similar plot to energy pricing asset_profile_*.html : each energy asset within the simulation has its own plot showing its profile (consumption, generation, State of Charge), the actual energy traded and energy rates.","title":"Backend Results"},{"location":"self-sufficiency-consumption/","text":"Self-sufficiency : % of energy needs covered by local generation Self-consumption : % of local energy generation consumed locally self_sufficiency(market) = self_consumed_energy / total_energy_demanded self_consumption(market) = self_consumed_energy / total_energy_produced The example provided in the figure below has the following grid architecture: total_house1_pv_production = 10kWh house1_pv \u2192 house1_load = 1kWh house1_pv \u2192 house1_storage = 5kWh house1_pv \u2192 house2_load = 4kWh house1_storage \u2192 house1_load = 2kWh house1_storage \u2192 house2_load = 3kWh house1_self_consumer_energy = ( house1_pv \u2192 house1_load ) + ( house1_pv \u2192 house1_storage \u2192 house1_load ) = 1 + 2 = 3kWh house1_total_energy_demanded (only includes the demanded energy from house1\u2019s load asset) = 3kWh In this example, self-sufficiency of the house 1 is self_sufficiency(house1) = house1_self_consumer_energy / house1_total_energy_demanded self_sufficiency(house1) = 3 / 3 = 1 \u2192 100% Self-consumption of the house 1 is self_consumption(house1) = house1_self_consumer_energy / house1_total_energy_produced self_consumption(house1) = 3 / 10 = 0.3 \u2192 30% In the Grid , the highest level of the hierarchy : self_sufficiency = 10 / 10 = 1 \u2192 100% self_consumption = 10 / 10 = 1 \u2192 100%","title":"Self sufficiency consumption"},{"location":"self-sufficiency-self-consumption/","text":"This category shows the self-sufficiency and self-consumption percentage of the community. Self-Sufficiency refers to the amount of a community\u2019s energy demand that is produced locally. It is calculated as follow: self_sufficiency(market) = self_consumed_energy / total_energy_demanded Self-Consumption refers to the % of energy in kWh that the community consumed from its own production. It is calculated as follow: self_consumption(market) = self_consumed_energy / total_energy_produced Figure 2.22 . Self-Sufficiency and Self-Consumption Results. Here is an example of the self-sufficiency and self-consumption calculation: Figure 2.23 . Example grid setup showing an energy community consisting of two homes. total_house1_pv_production = 10kWh house1_pv \u2192 house1_load = 1kWh house1_pv \u2192 house1_storage = 5kWh house1_pv \u2192 house2_load = 4kWh house1_storage \u2192 house1_load = 2kWh house1_storage \u2192 house2_load = 3kWh house1_self_consumer_energy = ( house1_pv \u2192 house1_load ) + ( house1_pv \u2192 house1_storage \u2192 house1_load ) = 1 + 2 = 3kWh house1_total_energy_demanded (only includes the demanded energy from house1\u2019s load asset) = 3kWh In this example, self-sufficiency of the house 1 is self_sufficiency(house1) = house1_self_consumer_energy / house1_total_energy_demanded self_sufficiency(house1) = 3 / 3 = 1 \u2192 100% Self-consumption of the house 1 is self_consumption(house1) = house1_self_consumer_energy / house1_total_energy_produced self_consumption(house1) = 3 / 10 = 0.3 \u2192 30% In the Grid , the highest level of the hierarchy : self_sufficiency = 10 / 10 = 1 \u2192 100% self_consumption = 10 / 10 = 1 \u2192 100%","title":"Self-Sufficiency and Self-Consumption"},{"location":"send-data-exchange-sdk/","text":"To send live data streams through the Exchange SDK, please follow these steps: Install the SDK Client by following the steps described here . Since the client is written in Python, the data stream pipeline needs to be written in Python as well. Add the following command in the Grid Singularity Asset SDK Script to set the energy consumption and generation for Load and PV assets for the next market slot: asset_client.set_energy_forecast(<energy_forecast_Wh>) An example of how sending forecasts through the SDK Client could be added into the Asset API script can be found here .","title":"Send live data streams via the Exchange SDK"},{"location":"send-data-rest-api/","text":"To send asset data without using the SDK Client or to set up a data pipeline in another programming language than the SDK Client, the raw REST API can be used instead. An additional authentication step has to be performed first. Authentication with JSON Web Token \u00b6 Authentication is done via JSON Web Token (JWT). In order to retrieve the JWT, the following POST request has to be performed: POST https://d3aweb-dev.gridsingularity.com/api-token-auth/ The body of the request needs to contain the following information (JSON string): {\"username\": \"<your_username>\", \"password\": \"<your_password>\"} The returned JWT needs to be sent via the Authorization HTTP header when sending the forecast data. For that the user needs to add the following key value pair to the header of every POST command: Authorization: JWT . Note: d3aweb will soon be changed to reflect Grid Singularity\u2019s new user interface. Send energy forecast \u00b6 The POST to send the energy value is (please fill in and ): POST https://d3aweb-dev.gridsingularity.com/external-connection/api/<Canary Network UUID>/<Asset UUID>/set_energy_forecast/ The body of the request needs to contain the following information (JSON string): {\"energy_Wh\": <energy_value_for_asset>} Once the connection with the Grid Singularity Canary Test Network is complete, we recommend to verify that the data are sent successfully to the Grid Singularity exchange, by comparing the data visualized on the Grid Singularity user interface with the data in your local database to identify incoherences or mistakes during the connection. Iterate this process until each asset is successfully connected to send the correct data. Warning: Ensure your Internet connection/server is stable and the script persists. Any connection issue/loss on your side will result in inaccurate data reporting and representation in the Grid Singularity Exchange.","title":"Send live data streams via the REST API"},{"location":"send-data-rest-api/#authentication-with-json-web-token","text":"Authentication is done via JSON Web Token (JWT). In order to retrieve the JWT, the following POST request has to be performed: POST https://d3aweb-dev.gridsingularity.com/api-token-auth/ The body of the request needs to contain the following information (JSON string): {\"username\": \"<your_username>\", \"password\": \"<your_password>\"} The returned JWT needs to be sent via the Authorization HTTP header when sending the forecast data. For that the user needs to add the following key value pair to the header of every POST command: Authorization: JWT . Note: d3aweb will soon be changed to reflect Grid Singularity\u2019s new user interface.","title":"Authentication with JSON Web Token"},{"location":"send-data-rest-api/#send-energy-forecast","text":"The POST to send the energy value is (please fill in and ): POST https://d3aweb-dev.gridsingularity.com/external-connection/api/<Canary Network UUID>/<Asset UUID>/set_energy_forecast/ The body of the request needs to contain the following information (JSON string): {\"energy_Wh\": <energy_value_for_asset>} Once the connection with the Grid Singularity Canary Test Network is complete, we recommend to verify that the data are sent successfully to the Grid Singularity exchange, by comparing the data visualized on the Grid Singularity user interface with the data in your local database to identify incoherences or mistakes during the connection. Iterate this process until each asset is successfully connected to send the correct data. Warning: Ensure your Internet connection/server is stable and the script persists. Any connection issue/loss on your side will result in inaccurate data reporting and representation in the Grid Singularity Exchange.","title":"Send energy forecast"},{"location":"setting-configuration-parameters/","text":"The following parameters are part of Simulation Config and are initialised before updating any ConstSettings : sim_duration slot_length tick_length cloud_coverage* market_maker_rate* grid_fee_pct* grid_fee_const* pv_user_profile* max_panel_power_W In order to update some of these parameters (starred in list above), please use update_config_parameters method to update the general configuration parameters in the setup file: def get_setup(config): config.update_config_parameters(grid_fee_pct=5, grid_fee_const=35, cloud_coverage=2, pv_user_profile=\"<path>/<profile_name>\", market_maker_rate=30) market = Market( 'Grid', [ Asset('General Load', strategy=LoadHoursStrategy(avg_power_W=200, hrs_per_day=4, hrs_of_day=list(range(12, 16)), final_buying_rate=35) ), Asset('PV', strategy=PVStrategy(4, 80) ), ], config=config ) return market Simulation launch \u00b6 Once the entire market architecture is modelled, including energy assets, the user can launch the trading simulation by running a command line including desired setup features: -d, --duration: simulated duration of simulation [default: 1d] -t, --tick-length: simulated duration of a tick [default: 1s] -s, --slot-length: simulated duration of a market slot [default: 15m] -c, --cloud-coverage: Cloud coverage, 0 for sunny, 1 for partial coverage, 2 for clouds. [default: 0] --slot-length-realtime: Desired duration of slot in realtime [default: 0s] Example simulation call: gsy-e -l ERROR run --duration=1d --tick-length=1s --slot-length=15m --cloud-coverage=0 --setup default_2a Getting help in the command line: gsy-e --help returns: Usage: gsy-e [OPTIONS] COMMAND [ARGS]... Options: -l, --log-level [CRITICAL|FATAL|ERROR|WARN|WARNING|INFO|DEBUG|NOTSET|TRACE] Log level [default: INFO] --help Show this message and exit. Commands: run* resume gsy-e run --help returns: Usage: gsy-e run [OPTIONS] Options: -d, --duration INTERVAL Duration of simulation [default: 1d] -t, --tick-length INTERVAL Length of a tick [default: 1s] -s, --slot-length INTERVAL Length of a market slot [default: 15m] --slot-length-realtime INTERVAL Desired duration of slot in realtime [default: 0s] -c, --cloud-coverage INTEGER Cloud coverage, 0 for sunny, 1 for partial coverage, 2 for clouds. [default: 0] --setup TEXT Simulation setup module use. Available modules: [1000_houses, market_events.cloud_coverage_event, market_events.disable_interval_event, market_events.disconnect_interval_event, market_events.isolated_connect_event, market_events.isolated_disable_event, market_events.isolated_disconnect_event, market_events.isolated_enable_event, market_events.load_event, market_events.pv_event, market_events.storage_event, balancing_market.default_2a, balancing_market.one_load_one_pv, balancing_market.one_load_one_storage, balancing_market.one_storage_one_pv, balancing_market.test_asset_registry, balancing_market.two_sided_one_load_one_pv, config_parameter_test, default_2, default_2a, default_2b, default_3, default_3_pv_only, default_3a, default_3b, default_4, default_5, default_addcurve, default_addcurve2, default_csv, graphs_testing, jira.d3asim_1024, jira.d3asim_1139, jira.d3asim_638_custom_load, jira.d3asim_639_custom_storage, jira.d3asim_640_custom_pv, jira.d3asim_778, jira.d3asim_780, jira.d3asim_869, jira.d3asim_871, jira.d3asim_895, jira.d3asim_895_pr1, jira.d3asim_895_pr2, jira.d3asim_895_pr3, jira.d3asim_962, jira.default_2off_d3asim_1475, jira.default_595, jira.default_611, jira.default_613, jira.default_623, jira.default_645, jira.default_737, jira.test_strategy_custom_load, jira.test_strategy_custom_pv, jira.test_strategy_custom_storage, json_arg, json_file, non_compounded_grid_fees, redis_communication_default_2a, sam_config, sam_config_const_load, sam_config_small, strategy_tests.commercial_producer_market_maker_rate, strategy_tests.ess_capacity_based_sell_offer, strategy_tests.ess_sell_offer_decrease_based_on_risk_or_rate, strategy_tests.finite_power_plant, strategy_tests.finite_power_plant_profile, strategy_tests.home_cp_ess_load, strategy_tests.home_hybrid_pv_ess_load, strategy_tests.infinite_bus, strategy_tests.predefined_pv_test, strategy_tests.pv_const_price_decrease, strategy_tests.pv_final_selling_rate, strategy_tests.pv_initial_pv_rate_option, strategy_tests.pv_max_panel_output, strategy_tests.pv_max_panel_power_global, strategy_tests.pv_risk_based_price_decrease, strategy_tests.storage_buys_and_offers, strategy_tests.storage_strategy_break_even_hourly, strategy_tests.user_profile_load_csv, strategy_tests.user_profile_load_csv_multiday, strategy_tests.user_profile_load_dict, strategy_tests.user_profile_pv_csv, strategy_tests.user_profile_pv_dict, strategy_tests.user_profile_wind_csv, strategy_tests.user_rate_profile_load_dict, tobalaba.one_producer_load, two_sided_market.default_2a, two_sided_market.infinite_bus, two_sided_market.offer_reposted_at_old_offer_rate, two_sided_market.one_cep_one_load, two_sided_market.one_load_5_pv_partial, two_sided_market.one_load_one_storage, two_sided_market.one_pv_one_load, two_sided_market.one_pv_one_storage, two_sided_market.one_storage_5_pv_partial, two_sided_market.user_min_rate_profile_load_dict, two_sided_market.with_balancing_market, two_sided_pay_as_clear.default_2a, two_sided_pay_as_clear.test_clearing_energy] -g, --settings-file TEXT Settings file path --seed TEXT Manually specify random seed --paused Start simulation in paused state [default: False] --pause-at TEXT Automatically pause at a certain time. Accepted Input formats: (YYYY-MM-DD, HH:mm) [default: disabled] --repl / --no-repl Start REPL after simulation run. [default: False] --no-export Skip export of simulation data --export-path TEXT Specify a path for the csv export files (default: ~/d3a-simulation) --enable-bc Run simulation on Blockchain --start-date DATE Start date of the Simulation (YYYY-MM-DD) [default: 2019-09-27] --help Show this message and exit.","title":"Setting General Configuration Parameters"},{"location":"setting-configuration-parameters/#simulation-launch","text":"Once the entire market architecture is modelled, including energy assets, the user can launch the trading simulation by running a command line including desired setup features: -d, --duration: simulated duration of simulation [default: 1d] -t, --tick-length: simulated duration of a tick [default: 1s] -s, --slot-length: simulated duration of a market slot [default: 15m] -c, --cloud-coverage: Cloud coverage, 0 for sunny, 1 for partial coverage, 2 for clouds. [default: 0] --slot-length-realtime: Desired duration of slot in realtime [default: 0s] Example simulation call: gsy-e -l ERROR run --duration=1d --tick-length=1s --slot-length=15m --cloud-coverage=0 --setup default_2a Getting help in the command line: gsy-e --help returns: Usage: gsy-e [OPTIONS] COMMAND [ARGS]... Options: -l, --log-level [CRITICAL|FATAL|ERROR|WARN|WARNING|INFO|DEBUG|NOTSET|TRACE] Log level [default: INFO] --help Show this message and exit. Commands: run* resume gsy-e run --help returns: Usage: gsy-e run [OPTIONS] Options: -d, --duration INTERVAL Duration of simulation [default: 1d] -t, --tick-length INTERVAL Length of a tick [default: 1s] -s, --slot-length INTERVAL Length of a market slot [default: 15m] --slot-length-realtime INTERVAL Desired duration of slot in realtime [default: 0s] -c, --cloud-coverage INTEGER Cloud coverage, 0 for sunny, 1 for partial coverage, 2 for clouds. [default: 0] --setup TEXT Simulation setup module use. Available modules: [1000_houses, market_events.cloud_coverage_event, market_events.disable_interval_event, market_events.disconnect_interval_event, market_events.isolated_connect_event, market_events.isolated_disable_event, market_events.isolated_disconnect_event, market_events.isolated_enable_event, market_events.load_event, market_events.pv_event, market_events.storage_event, balancing_market.default_2a, balancing_market.one_load_one_pv, balancing_market.one_load_one_storage, balancing_market.one_storage_one_pv, balancing_market.test_asset_registry, balancing_market.two_sided_one_load_one_pv, config_parameter_test, default_2, default_2a, default_2b, default_3, default_3_pv_only, default_3a, default_3b, default_4, default_5, default_addcurve, default_addcurve2, default_csv, graphs_testing, jira.d3asim_1024, jira.d3asim_1139, jira.d3asim_638_custom_load, jira.d3asim_639_custom_storage, jira.d3asim_640_custom_pv, jira.d3asim_778, jira.d3asim_780, jira.d3asim_869, jira.d3asim_871, jira.d3asim_895, jira.d3asim_895_pr1, jira.d3asim_895_pr2, jira.d3asim_895_pr3, jira.d3asim_962, jira.default_2off_d3asim_1475, jira.default_595, jira.default_611, jira.default_613, jira.default_623, jira.default_645, jira.default_737, jira.test_strategy_custom_load, jira.test_strategy_custom_pv, jira.test_strategy_custom_storage, json_arg, json_file, non_compounded_grid_fees, redis_communication_default_2a, sam_config, sam_config_const_load, sam_config_small, strategy_tests.commercial_producer_market_maker_rate, strategy_tests.ess_capacity_based_sell_offer, strategy_tests.ess_sell_offer_decrease_based_on_risk_or_rate, strategy_tests.finite_power_plant, strategy_tests.finite_power_plant_profile, strategy_tests.home_cp_ess_load, strategy_tests.home_hybrid_pv_ess_load, strategy_tests.infinite_bus, strategy_tests.predefined_pv_test, strategy_tests.pv_const_price_decrease, strategy_tests.pv_final_selling_rate, strategy_tests.pv_initial_pv_rate_option, strategy_tests.pv_max_panel_output, strategy_tests.pv_max_panel_power_global, strategy_tests.pv_risk_based_price_decrease, strategy_tests.storage_buys_and_offers, strategy_tests.storage_strategy_break_even_hourly, strategy_tests.user_profile_load_csv, strategy_tests.user_profile_load_csv_multiday, strategy_tests.user_profile_load_dict, strategy_tests.user_profile_pv_csv, strategy_tests.user_profile_pv_dict, strategy_tests.user_profile_wind_csv, strategy_tests.user_rate_profile_load_dict, tobalaba.one_producer_load, two_sided_market.default_2a, two_sided_market.infinite_bus, two_sided_market.offer_reposted_at_old_offer_rate, two_sided_market.one_cep_one_load, two_sided_market.one_load_5_pv_partial, two_sided_market.one_load_one_storage, two_sided_market.one_pv_one_load, two_sided_market.one_pv_one_storage, two_sided_market.one_storage_5_pv_partial, two_sided_market.user_min_rate_profile_load_dict, two_sided_market.with_balancing_market, two_sided_pay_as_clear.default_2a, two_sided_pay_as_clear.test_clearing_energy] -g, --settings-file TEXT Settings file path --seed TEXT Manually specify random seed --paused Start simulation in paused state [default: False] --pause-at TEXT Automatically pause at a certain time. Accepted Input formats: (YYYY-MM-DD, HH:mm) [default: disabled] --repl / --no-repl Start REPL after simulation run. [default: False] --no-export Skip export of simulation data --export-path TEXT Specify a path for the csv export files (default: ~/d3a-simulation) --enable-bc Run simulation on Blockchain --start-date DATE Start date of the Simulation (YYYY-MM-DD) [default: 2019-09-27] --help Show this message and exit.","title":"Simulation launch"},{"location":"settlement-market-structure/","text":"Spot and futures trading requires predictions of energy use at both the asset and network level, which are often associated with high prediction errors. Thus, although a balancing mechanism should deal with the energy imbalances on the physical level, financial exchanges might still not be settled, causing a mismatch between physical energy delivery and market accounting. Some market approaches create orders and matches based on the last 15 minute slot\u2019s energy use (post-delivery, read by smart meters) to solve this problem. Others allow the grid operator to set prices or enforce penalties for any deviance. The Netherlands has implemented a final gate closure time one day after delivery, allowing ex-post trading for balance responsible parties to trade imbalances in real-time. Symbiotic Energy Markets concept allows similar post-delivery trading by all market participants. Deviations between energy physically produced/consumed and energy purchased in the spot or futures market can be traded post-delivery by submitting a time slot in the past as a requirement attached to a bid or offer, creating a settlement market (figure 3.8). Bids and offers can be matched with a matching algorithm. This allows local deviations to balance without penalty (e.g. a local solar panel that overproduces matches their deviation to a local load that over-consumed), with the remainder filled at a market rate (likely a premium) by individual assets, balancing groups, or grid operators that provided balancing services during delivery. A specific limit may be introduced to represent the time interval in which post-delivery trading can be conducted. Figure 3.8 . Energy deviations (difference between purchased and delivered energy) can be traded in the settlement market instead of paying a penalty to the grid operator, reducing inefficient accounting. Any remaining deviance can still be penalized by the grid operator.","title":"Settlement Market Structure"},{"location":"setup-configuration/","text":"Backend Simulation Configuration \u00b6 In the backend, the simulation process is slightly different. There is no need to login to set up a simulation. The user first needs to download the code from our Github Repository (Installation Instructions for Linux , Mac and Windows ). In the setup-file (in Python programming language), general and trading strategy settings can be defined. Examples can be found in the relevant Grid Singularity GitHub folder. This is the most basic skeleton for a setup-file: ```python from gsy_e.models.area import Market def get_setup(config): area = Market(\"Grid\", []) return Market The user can add more nested submarkets recursively by adding more instances of Market to the second parameter (list) of the Market class. To define the strategy of an asset, please use the Asset class and its strategy parameter. The following grid architecture is given: Grid House 1 H1 General Load H1 Storage 1 H1 Storage 2 House 2 H2 General Load Bold instances in the outline above are markets. For each of these markets, a market-agent is created in the background to execute offer/bid forwarding and matching. In the following, the corresponding setup-file is shown. ```python from gsy_e.models.area import Area from gsy_e.models.strategy.storage import StorageStrategy from gsy_e.models.strategy.load_hours import LoadHoursStrategy from gsy_e.models.strategy.pv import PVStrategy def get_setup(config): market = Market( 'Grid', [ Market( 'House 1', [ Asset('H1 General Load', strategy=LoadHoursStrategy(avg_power_W=200, hrs_per_day=6, hrs_of_day=list( range(12, 18)), final_buying_rate=35) ), Asset('H1 Storage1', strategy=StorageStrategy(initial_soc=50) ), Asset('H1 Storage2', strategy=StorageStrategy(initial_soc=50) ), ], grid_fee_pct=0, grid_fee_const=0, ), Market( 'House 2', [ Asset('H2 General Load', strategy=LoadHoursStrategy(avg_power_W=200, hrs_per_day=4, hrs_of_day=list( range(12, 16)), final_buying_rate=35) ), Asset('H2 PV', strategy=PVStrategy(panel_count=4, initial_selling_rate=30, final_selling_rate=5) ), ], grid_fee_pct=0, grid_fee_const=0, ), ], config=config ) return market Additionally, the user has the possibility to change the default general settings in two different ways: Setup file (best option) gsy-e-setting.json Setup file (best option): \u00b6 For a description of each grid component please see the Modelling section. The user can overwrite the configuration settings by changing variables of the ConstSettings class in the setup-file. This class defines the default values for various parameters (general simulation settings, market settings and energy asset configuration). For instance, the user can define multiple configuration parameters in the get_setup function by overwriting the ConstSettings default values. For example, the following parameters can be set : Market_type (if equal to 1: One-Sided Pay-as-Offer , if equal to 2 : Two-Sided Pay-as-Bid , if equal to 3 : Two-Sided Pay-as-Clear ) Grid_fee_type (if equal to 1: Constant grid fee , if equal to 2 : Percentage grid fee ) Here is an example to setup a simulation with the Two-Sided Pay-as-Bid market type, constant grid fee and default min (0cts/kWh) and max to (35cts/kWh) energy rate for all loads : from gsy_framework.constants_limits import ConstSettings def get_setup(config): ConstSettings.IAASettings.MARKET_TYPE = 2 ConstSettings.LoadSettings.MIN_ENERGY_RATE = 0 ConstSettings.LoadSettings.MAX_ENERGY_RATE = 35 ConstSettings.IAASettings.GRID_FEE_TYPE = 1 gsy-e-settings.json \u00b6 These general settings can also be parsed via a settings file in JSON format, which contains all constants in the advanced_settings branch. An example can be found here: src/gsy-e/setup/gsy-e-settings.json. The settings JSON file can be parsed via the --settings-file keyword","title":"Setup Configuration"},{"location":"setup-configuration/#backend-simulation-configuration","text":"In the backend, the simulation process is slightly different. There is no need to login to set up a simulation. The user first needs to download the code from our Github Repository (Installation Instructions for Linux , Mac and Windows ). In the setup-file (in Python programming language), general and trading strategy settings can be defined. Examples can be found in the relevant Grid Singularity GitHub folder. This is the most basic skeleton for a setup-file: ```python from gsy_e.models.area import Market def get_setup(config): area = Market(\"Grid\", []) return Market The user can add more nested submarkets recursively by adding more instances of Market to the second parameter (list) of the Market class. To define the strategy of an asset, please use the Asset class and its strategy parameter. The following grid architecture is given: Grid House 1 H1 General Load H1 Storage 1 H1 Storage 2 House 2 H2 General Load Bold instances in the outline above are markets. For each of these markets, a market-agent is created in the background to execute offer/bid forwarding and matching. In the following, the corresponding setup-file is shown. ```python from gsy_e.models.area import Area from gsy_e.models.strategy.storage import StorageStrategy from gsy_e.models.strategy.load_hours import LoadHoursStrategy from gsy_e.models.strategy.pv import PVStrategy def get_setup(config): market = Market( 'Grid', [ Market( 'House 1', [ Asset('H1 General Load', strategy=LoadHoursStrategy(avg_power_W=200, hrs_per_day=6, hrs_of_day=list( range(12, 18)), final_buying_rate=35) ), Asset('H1 Storage1', strategy=StorageStrategy(initial_soc=50) ), Asset('H1 Storage2', strategy=StorageStrategy(initial_soc=50) ), ], grid_fee_pct=0, grid_fee_const=0, ), Market( 'House 2', [ Asset('H2 General Load', strategy=LoadHoursStrategy(avg_power_W=200, hrs_per_day=4, hrs_of_day=list( range(12, 16)), final_buying_rate=35) ), Asset('H2 PV', strategy=PVStrategy(panel_count=4, initial_selling_rate=30, final_selling_rate=5) ), ], grid_fee_pct=0, grid_fee_const=0, ), ], config=config ) return market Additionally, the user has the possibility to change the default general settings in two different ways: Setup file (best option) gsy-e-setting.json","title":"Backend Simulation Configuration"},{"location":"setup-configuration/#setup-file-best-option","text":"For a description of each grid component please see the Modelling section. The user can overwrite the configuration settings by changing variables of the ConstSettings class in the setup-file. This class defines the default values for various parameters (general simulation settings, market settings and energy asset configuration). For instance, the user can define multiple configuration parameters in the get_setup function by overwriting the ConstSettings default values. For example, the following parameters can be set : Market_type (if equal to 1: One-Sided Pay-as-Offer , if equal to 2 : Two-Sided Pay-as-Bid , if equal to 3 : Two-Sided Pay-as-Clear ) Grid_fee_type (if equal to 1: Constant grid fee , if equal to 2 : Percentage grid fee ) Here is an example to setup a simulation with the Two-Sided Pay-as-Bid market type, constant grid fee and default min (0cts/kWh) and max to (35cts/kWh) energy rate for all loads : from gsy_framework.constants_limits import ConstSettings def get_setup(config): ConstSettings.IAASettings.MARKET_TYPE = 2 ConstSettings.LoadSettings.MIN_ENERGY_RATE = 0 ConstSettings.LoadSettings.MAX_ENERGY_RATE = 35 ConstSettings.IAASettings.GRID_FEE_TYPE = 1","title":"Setup file (best option):"},{"location":"setup-configuration/#gsy-e-settingsjson","text":"These general settings can also be parsed via a settings file in JSON format, which contains all constants in the advanced_settings branch. An example can be found here: src/gsy-e/setup/gsy-e-settings.json. The settings JSON file can be parsed via the --settings-file keyword","title":"gsy-e-settings.json"},{"location":"solar-panels/","text":"A photovoltaic (PV) module is an energy asset that converts solar irradiation into electricity. In our software, each PV component already includes the DC to AC conversion, and can represent a single module, array of modules or an entire solar park (users can select the total capacity in the advanced PV settings). They can be added to homes or a community. PVs produce electricity to be self-consumed by the asset owners, sold to another member of the community, sold back to the grid, or stored in a battery for use at a later time, depending on what options are available to the owner. In the Singularity Map, the \u201cCustom PV\u201d tool allows users to quickly simulate a PV generation at a specific location and orientation. This tool uses the backend code of the Energy Data Map provided by rebase.energy . Additionally template PV generation profiles from different cities are available to users (also generated using data from the Energy Data Map based on the selected geographical location and weather profile). Users can either add template PV profiles to their homes or communities or they can upload their own PV data by using the \u2018override profile\u2019 section in the PV advanced settings, after initially selecting a template PV. Figure 2.8 . Express Mode PV Options Asset Configuration Options \u00b6 Express Mode Name - Must be unique Geo-tag - This automatically uploads the location a user selects Advanced Mode Capacity and Profile Capacity - Total kW capacity of the PV system Solar Profile - Users can choose one of the following options: Local generation profile - This is the default setting and represents the PV production based on asset location, derived by connecting to the Energy Data Map API provided by rebase.energy . Sunny, partially cloudy, cloudy - Template profile representing one of the 3 different weather types (1 day profile). Gaussian - PV profile where the maximum generation value is the defined PV capacity. Upload their own custom generation profile by providing a csv file . Trading Strategy Initial selling rate - Users can choose the initial (and maximum) rate that the PV offers at the beginning of each market slot in cents/kWh. Select the Market Maker rate or create your own custom rate by selecting \u2018user input\u2019. Final selling rate - Users can choose the final rate that the PV offers at the end of each market slot in cents/kWh. Rate decrease - Users can enter a value for the explicit rate decrease increment in cents/kWh. Fit to limits - If activated, a rate decrease per time is calculated, starting at Initial Selling Rate and ending at final Selling Rate, while updating the rate at each Update Interval. Users can derive bidding behaviour from a linear fitted curve of a selling rate ranging from initial_selling_rate to final_selling_rate within the bidding interval. If activated, energy_rate_decrease_per_update = (initial_selling_rate - final_selling_rate) / max(int((slot_length / update_interval) -1), 1) Update interval - Choose the frequency at which the rate is updated. Orientation - If the Local Generation Profile is selected as a Solar Profile, the parameters describing the orientation of the solar panels can be set. There are 2 options: Basic: User select one of the 3 options (Flat, Tilted or Facade) Advanced: User sets the tilt and azimuth in degrees Figure 2.9 . Selection of PV orientation Figure 2.10 . PV Advanced Configuration Options The integration of the Energy Data Map API with the Grid Singularity Exchange (Custom PV tool feature) was designed and developed in the scope of the EU-supported AI4Cities project.","title":"Solar Panels (PVs)"},{"location":"solar-panels/#asset-configuration-options","text":"Express Mode Name - Must be unique Geo-tag - This automatically uploads the location a user selects Advanced Mode Capacity and Profile Capacity - Total kW capacity of the PV system Solar Profile - Users can choose one of the following options: Local generation profile - This is the default setting and represents the PV production based on asset location, derived by connecting to the Energy Data Map API provided by rebase.energy . Sunny, partially cloudy, cloudy - Template profile representing one of the 3 different weather types (1 day profile). Gaussian - PV profile where the maximum generation value is the defined PV capacity. Upload their own custom generation profile by providing a csv file . Trading Strategy Initial selling rate - Users can choose the initial (and maximum) rate that the PV offers at the beginning of each market slot in cents/kWh. Select the Market Maker rate or create your own custom rate by selecting \u2018user input\u2019. Final selling rate - Users can choose the final rate that the PV offers at the end of each market slot in cents/kWh. Rate decrease - Users can enter a value for the explicit rate decrease increment in cents/kWh. Fit to limits - If activated, a rate decrease per time is calculated, starting at Initial Selling Rate and ending at final Selling Rate, while updating the rate at each Update Interval. Users can derive bidding behaviour from a linear fitted curve of a selling rate ranging from initial_selling_rate to final_selling_rate within the bidding interval. If activated, energy_rate_decrease_per_update = (initial_selling_rate - final_selling_rate) / max(int((slot_length / update_interval) -1), 1) Update interval - Choose the frequency at which the rate is updated. Orientation - If the Local Generation Profile is selected as a Solar Profile, the parameters describing the orientation of the solar panels can be set. There are 2 options: Basic: User select one of the 3 options (Flat, Tilted or Facade) Advanced: User sets the tilt and azimuth in degrees Figure 2.9 . Selection of PV orientation Figure 2.10 . PV Advanced Configuration Options The integration of the Energy Data Map API with the Grid Singularity Exchange (Custom PV tool feature) was designed and developed in the scope of the EU-supported AI4Cities project.","title":"Asset Configuration Options"},{"location":"spot-market-types/","text":"In a local energy market (LEM), bids and offers are matched according to the selected clearing mechanism. Studies show that different clearing mechanisms offer diverse benefits and limitations relating to market efficiency , fairness , and user choices . Grid Singularity\u2019s exchange (previously D3A), three spot market types are implemented: One-Sided Pay-as-Offer Market Two-Sided Pay-as-Bid Market Two-Sided Pay-as-Clear Market","title":"Spot Maket Types"},{"location":"technical-approach/","text":"Grid Singularity Exchange provides the software tools, enabling prosumers and consumers organized in energy communities (also known as energy cooperatives, community choice aggregations or microgrids in different regions of the world), with the support of local aggregators, to simulate and implement peer-to-peer and community energy trading through the creation of active local energy markets (LEMs). Importantly, our open source and modular platform optimises the use of local resources and enables individuals with equitable access to energy trading, at par with large energy suppliers. The first step towards deploying a local energy market is to configure and optimise its structure using Grid Singularity\u2019s free, web-based simulation ( user interface ). The user can build a \u201cdigital twin\u201d representation of physical energy systems and energy markets (using template or real-world data) and run simulations in order to assess the financial and social benefits of local trading and the impact of different actions or assets in the system . This wiki provides a detailed guide for prosumers and energy communities to set up a simulation , as well as additional guidelines for aggregators and grid operators . Please note that our backend code is open source under GPLv3 and offers the full functionality of the active version of the Grid Singularity Exchange, while the web-based user interface offers eased access to the majority of features found in the backend. Figure 1 . Grid Aware Markets: Trading agents place bids and offers on behalf of assets via the Asset API. Agents trade based on user preferences such as energy source and preferred trading partner. Grid Operators implement dynamic grid tariffs in energy markets through the Grid Operator API. Grid Singularity facilitates an individual or energy asset centered, bottom-up, hierarchical market design by connecting aggregators and grid operators, through an application interface ( Asset API and Grid Operator API , respectively). More specifically, aggregators connect distributed energy assets of a community (including households, businesses and other energy users), while grid operators account for grid costs and access local flexibility for advanced grid management. Connected energy assets are digitally represented by trading agents pursuing trading strategies based on user preferences, such as consuming only renewable energy or trading with a preferred partner, achieving diverse degrees of freedom. Assets are typically grouped inside homes based on the owner and trade in a community market. Multiple communities can be connected inside higher markets depending on the geographical reach of the peer-to-peer system and voltage architecture of the grid. Grid Singularity\u2019s technical approach includes a blockchain implementation which will incorporate the energy asset identity authentication from Energy Web Switchboard , and ensure transparency and settlement automation, by operating a parachain on a Polkadot based network. Notably, these networks just like the Energy Web Chain do not rely on a proof-of-work mechanism of validation and therefore do not overuse electricity . Our path to decentralisation and the implementation of Symbiotic Energy Markets is described in the following discussion paper . Figure 2 . Grid Singularity Exchange: data flows from energy assets over aggregators and trading agents via APIs for matching. Energy Web Switchboard is to be used as a decentralized asset registry and decentralized data access management tool. When the Grid Singularity Exchange is deployed as a distributed local energy exchange, the traditional role of the grid operator, which manages the connection to the power grid, and the utility, as a provider of energy, would still continue to be required to integrate the local energy market with the wider grid network. This ensures the reliability of supply in case of a deficit within a community but also export possibilities in case of a surplus. The primary difference is that a utility would no longer be the only market actor with which a household exchanges energy, but one of multiple. Grid Singularity fosters interoperability and open-source development, collaborating with other market actors that provide grid management and asset aggregation services and supporting complementary services such as data and smart trading algorithm that further enhance the efficiency of local energy markets (LEM), optimising the use of local renewable resources and other individual and community benefits. Grid Singularity\u2019s Exchange is a highly innovative and effective grid modernization solution. First, it empowers customer engagement and provides utmost degrees of freedom in energy markets enhancing individual and community choices (e.g., type of energy consumed or preferred trading partner), lowering barriers and creating incentives for all participants. Second, it creates a resilient market by ensuring equal access, transparent pricing, and trading at optimal market levels (i.e., between assets and buildings or facility and grid). Third, it incentivizes and facilitates the integration of clean distributed energy resources (DERs) onto the grid closer to load centers. Fourth, grid operators can use it to implement flexible grid tariffs to benefit from the local market flexibility to alleviate congestion. Fifth, the Grid Singularity API provides instantaneous granular data to the grid operator\u2013which historically has relied upon changes in detected load and alterations from the forecast\u2013enabling the operator to improve management, flexibility, and grid performance. Sixth, peer-to-peer trading is market-driven , not based upon predetermined pricing, which optimizes local consumption and thus the use of (cheaper) local renewables, increasing affordability, reducing reliance and overall/peak load on the grid, supporting efficient asset utilization, and reducing system losses. Seventh, it increases community self-sufficiency and energy savings , providing emergency power backup, and mitigating the need for new transmission infrastructure. Finally, the peer-to-peer trading system incentivizes private investment in electric system infrastructure by increasing revenue from renewable DERs and providing decision-making tools.","title":"Grid Singularity Technical Approach"},{"location":"trade-profile/","text":"The trade profile shows the energy traded in kWh in this market (community or homes) per 15 minute market slot for the duration of the simulation. The negative side of the y-axis represents the energy sold, and the positive y-axis shows the energy bought. The different colors represent the different market participants (energy assets and markets). Users can show/hide the trade profile of any of the individual homes or grid market in this chart by clicking on it\u2019s profile beneath it, including the net energy flow. As all buyers and sellers of each trade are accounted for in a select market, the supply and demand sides are exact mirrors of each other in terms of volume. Figure 2.24 . Trade Profile Results Chart showing results for all homes in this community and the grid market. The peak analysis is an advanced tool that compares the current energy peak to a baseline configured in the market settings. It can be switched on/off by selecting the \ud83c\udd87 or \u2705 buttons to the top-right of the chart. Figure 2.25 . Peak Analysis applied to the Trade Profile Results Chart. When activated, only the net external trades of each participant are displayed. The net energy displays the difference between the total import and export for each market slot, useful in understanding the impact to transmission capacity. The energy peak imports/exports is the maximum value of the aggregate imports/exports of each asset inside a market. The user is able to set a baseline peak energy import in kWh and a baseline peak energy export in kWh that they may have gotten from another simulation in order to calculate the energy peak percentage, which is a measure of how much the peak imports or exports have changed between a baseline defined in market settings and the simulation. The purpose of the Energy Peak Percentage value is to assess the impact of applied grid fees or different energy storage strategies on the peak imports and exports of a market. Figure 2.26 . Peak imports and exports of a market. It is calculated as follows: Import_peak_percentage = import_peak_energy_kWh / import_baseline_peak_energy_kWh * 100 Export_peak_percentage = export_peak_energy_kWh / export_baseline_peak_energy_kWh * 100 If the energy peak percentage is below 100% , the peak was reduced vs. the baseline. The energy peak was increased if the energy peak percentage value was above 100% . On the peak analysis plot, two lines are shown: the current peak imports (at top) and the current peak exports (at bottom), representing the maximum energy imported and exported for the selected market.","title":"Trade profile"},{"location":"trades/","text":"The chart on the left in the figure below shows the amount of energy which was traded between each of the homes and the grid market in kWh participating in this market. The trades can be filtered by cumulative or per market slot or by clicking to view an individual home in the chart. In the graph on the right, each bid, offer and trade posted/cleared in the selected market is shown according to its posting/clearing times, allowing the user to analyse how specific offers/bids were or were not matched and validate or further investigate their trading strategy. The x-axis of this graph is the market slot length (15 minutes by default), and the y-axis shows the bid and offer price. Each market slot of the simulation can be selected and viewed with the drop down (days) and the slider (hours & minutes). Figure 2.29 . Trades shown in cumulative form (left) and in Market Slots (right).","title":"Trades"},{"location":"two-sided-pay-as-bid/","text":"In the Two-Sided Pay-as-Bid market, buyers are able to place bids in the market, alongside the offers placed by sellers. Each market collects and matches bids and offers issued by trading agents, and dispatches bids and offers to other markets via a MarketAgent, which is created and operated by each market (area). Its role is to forward offers and bids to the connected markets. The auction is continuous , meaning that once an offer or bid is posted, it can be matched right away, even before the end of the market slot. Bids and offers can also be annulled by the trading agent. The market constantly triggers the matching between bids and offers according to the matching algorithm as illustrated in the figure below. Figure 3.2 . Two-Sided Pay-as-Bid Market mechanism.","title":"Two-Sided Pay-as-Bid Market"},{"location":"two-sided-pay-as-clear/","text":"In the Two-Sided Pay-as-Clear market, buyers are able to place bids in the market alongside the offers placed by sellers. The market collects and matches bids and offers issued by trading agents, and dispatches bids and offers to other markets via the MarketAgent (MA). Bids and offers can also be annulled by the trading agent. Market Agents are created and operated by each market (area) to forward bids and offers to the connected markets . Currently, there is a merit-order-effect mechanism implemented for bid and offer matching where bids and offers are aggregated and cleared in a specified clearing interval. At the end of each interval, bids are arranged in a descending order, offers in an ascending order and the equilibrium quantity of energy and price is calculated. The clearing point (the quantity of energy that is accepted trade volume for a specific energy rate clearing price ) is determined by the point where the arranged bid curve for the buyers drops below the offer curve for the sellers. Figure 3.3 . Two-Sided Pay-as-Clear Market mechanism. The highest bids are matched with the lowest offers. The matching rate is the clearing price (cents/kWh). The remaining bids and offers (right of the clearing point in the plot above) are not cleared at this clearing point and remain in the market for later matching.","title":"Two-Sided Pay-as-Clear Market"},{"location":"ui-initialisation/","text":"To start using the Grid Singularity Energy Exchange ), you need to register your account by selecting a user email and password. You will then receive an email with a link to confirm your account. You can design your own project by clicking on \u201cnew project\u201d and then create a new simulation. The first step in setting up a simulation is to define the simulation general and market settings, described in more detail below. The next step is to design your grid. Once you arrive in the grid setup, the first thing that you will have to do is to define the market maker. Subsequently, you can start building the digital twin of your grid including submarkets and relevant energy assets that can all be individually configured. The setup is intended to represent the physical architecture of the real energy market (country, region, neighbourhood, house, etc.). After your grid setup is complete, you can run your simulation. When it is finished you can view multiple scrollable plots and tables on the Results page. For a step-by-step explanation on how to set up your simulation, please watch our tutorial . You can also contact us at contact@gridsingularity.com or on slack Slack Note: For smoother simulations and smaller queues, we have set some boundaries. First, the simulations are limited in their duration. You can currently set the duration from 1 to 7 days . Furthermore, the number of agents per simulation is limited. Each market and asset is represented by an agent and you can define up to 1000 agents . Please see instructions on Backend simulation configuration here .","title":"Ui initialisation"},{"location":"upload-file-formats/","text":"Files can be uploaded to generate custom energy supply or load profiles. The following file formats are supported: Comma Separated Values (.csv) \u00b6 The separation can be done by comma , or semicolon ; . Two time formats are supported, see below. Power set-points are given in Watts . The software handles any conversions to energy (in kWh). All entered csv data values need to be positive hh:mm \u00b6 Example: INTERVAL;POWER(W): 00:00;10 00:15;10 00:30;10 00:45;10 01:00;10 YYYY-MM-DDThh:mm \u00b6 Example: INTERVAL,POWER(W) 2019-01-01T00:00,10.0 2019-01-01T00:15,10.0 2019-01-01T00:30,10.0 2019-01-01T00:45,10.0 2019-01-01T01:00,10.0 Note: If you upload csv files with date information, the start-date of the simulation should be identical in the csv files and simulation settings .","title":"Upload file formats"},{"location":"upload-file-formats/#comma-separated-values-csv","text":"The separation can be done by comma , or semicolon ; . Two time formats are supported, see below. Power set-points are given in Watts . The software handles any conversions to energy (in kWh). All entered csv data values need to be positive","title":"Comma Separated Values (.csv)"},{"location":"upload-file-formats/#hhmm","text":"Example: INTERVAL;POWER(W): 00:00;10 00:15;10 00:30;10 00:45;10 01:00;10","title":"hh:mm"},{"location":"upload-file-formats/#yyyy-mm-ddthhmm","text":"Example: INTERVAL,POWER(W) 2019-01-01T00:00,10.0 2019-01-01T00:15,10.0 2019-01-01T00:30,10.0 2019-01-01T00:45,10.0 2019-01-01T01:00,10.0 Note: If you upload csv files with date information, the start-date of the simulation should be identical in the csv files and simulation settings .","title":"YYYY-MM-DDThh:mm"},{"location":"version-update/","text":"Grid Singularity Exchange Update \u00b6 Please start by opening a terminal and activating the Grid Singularity D3A virtual environment as described in the Installation Instructions. Then type: git pull origin/master fab sync If fab sync does not work on your machine, please try: pip install -e . Grid Singularity Exchange SDK Update \u00b6 Please start by opening a terminal and activating the Exchange SDK virtual environment as described in the API Installation Instructions. Then type: pip uninstall gsy-e-sdk Press y when prompted. Once the uninstall is complete, type: pip install git+https://github.com/gridsingularity/gsy-e-sdk.git","title":"Version Updates"},{"location":"version-update/#grid-singularity-exchange-update","text":"Please start by opening a terminal and activating the Grid Singularity D3A virtual environment as described in the Installation Instructions. Then type: git pull origin/master fab sync If fab sync does not work on your machine, please try: pip install -e .","title":"Grid Singularity Exchange Update"},{"location":"version-update/#grid-singularity-exchange-sdk-update","text":"Please start by opening a terminal and activating the Exchange SDK virtual environment as described in the API Installation Instructions. Then type: pip uninstall gsy-e-sdk Press y when prompted. Once the uninstall is complete, type: pip install git+https://github.com/gridsingularity/gsy-e-sdk.git","title":"Grid Singularity Exchange SDK Update"},{"location":"vm-installation-instructions/","text":"If the Grid Singularity Exchange is already installed and updated on your virtual machine you can skip to step 4. Step 1: Windows environment settings (not always required, please try starting with Step 2) \u00b6 Enable Intel Virtualization on your computer in BIOS. Go to your Windows Features setting and disable Windows Hypervisor Platform (or Hyper-V) and enable Virtual Machine Platform. Step 2: Install Virtualbox and Vagrant \u00b6 It is recommended to use Chocolatey as a package management tool for Windows. Open your terminal (cmd.exe) as administrator and install chocolatey by running the following command : @\"%SystemRoot%\\System32\\WindowsPowerShell\\v1.0\\powershell.exe\" -NoProfile -InputFormat None -ExecutionPolicy Bypass -Command \"[System.Net.ServicePointManager]::SecurityProtocol = 3072; iex ((New-Object System.Net.WebClient).DownloadString('https://chocolatey.org/install.ps1'))\" && SET \"PATH=%PATH%;%ALLUSERSPROFILE%\\chocolatey\\bin\" Install Virtualbox from a Windows console choco install virtualbox Install Vagrant (this is a software wrapper around virtualbox and other supervisors, that allows easy creation, download, and installation of virtual machines. choco install vagrant vagrant plugin install vagrant-disksize Step 3: Install Grid Singularity Exchange while sharing a folder between guest and host machine via vagrant \u00b6 Create a new-folder that you want to share across guest and host machines. Add the Vagrantfile from Grid Singularity Exchange repository into your newly created folder. Open a terminal and go into your newly-created folder with: cd <path-to-your-folder> If it is your first time do: vagrant up If vagrant was already running, please delete re-initialize with the following steps first : Delete old vagrant images via : vagrant destroy --force Remove residues of old vagrant boxes via : vagrant box remove ubuntu/<your-box-name> --all --force Step 4: Reload your virtual machine: \u00b6 vagrant reload Step 5: Access your virtual machine terminal to run Grid Singularity Exchange: \u00b6 vagrant ssh Step 6: Share folder to Windows host by running these three commands: \u00b6 cp -r /home/vagrant/gsy-e/vagrant/ Share gsy-e-sdk: cp -r /home/vagrant/gsy-e-sdk/vagrant/ If you have results you want to export to Windows : cd /home/vagrant/gsy-e-simulation/ zip -r <your-zip-filename>.zip ./<folder-to-be-zipped>/ cp -r <your-zip-filename>.zip /vagrant/ Step 7: Run a gsy-e simulation \u00b6 Activate the gsy-e environment: source /home/vagrant/envs/gsy-e/bin/activate Run simulation with: cd /vagrant/gsy-e gsy-e run Step 8: Run the Grid Singularity Exchange SDK in Vagrant \u00b6 Activate the Exchange SDK environment: source /home/vagrant/envs/exchange-sdk/bin/activate To run your SDK script, run the following command (template here): python your_sdk_script.py","title":"Windows Installation Instructions"},{"location":"vm-installation-instructions/#step-1-windows-environment-settings-not-always-required-please-try-starting-with-step-2","text":"Enable Intel Virtualization on your computer in BIOS. Go to your Windows Features setting and disable Windows Hypervisor Platform (or Hyper-V) and enable Virtual Machine Platform.","title":"Step 1: Windows environment settings (not always required, please try starting with Step 2)"},{"location":"vm-installation-instructions/#step-2-install-virtualbox-and-vagrant","text":"It is recommended to use Chocolatey as a package management tool for Windows. Open your terminal (cmd.exe) as administrator and install chocolatey by running the following command : @\"%SystemRoot%\\System32\\WindowsPowerShell\\v1.0\\powershell.exe\" -NoProfile -InputFormat None -ExecutionPolicy Bypass -Command \"[System.Net.ServicePointManager]::SecurityProtocol = 3072; iex ((New-Object System.Net.WebClient).DownloadString('https://chocolatey.org/install.ps1'))\" && SET \"PATH=%PATH%;%ALLUSERSPROFILE%\\chocolatey\\bin\" Install Virtualbox from a Windows console choco install virtualbox Install Vagrant (this is a software wrapper around virtualbox and other supervisors, that allows easy creation, download, and installation of virtual machines. choco install vagrant vagrant plugin install vagrant-disksize","title":"Step 2: Install Virtualbox and Vagrant"},{"location":"vm-installation-instructions/#step-3-install-grid-singularity-exchange-while-sharing-a-folder-between-guest-and-host-machine-via-vagrant","text":"Create a new-folder that you want to share across guest and host machines. Add the Vagrantfile from Grid Singularity Exchange repository into your newly created folder. Open a terminal and go into your newly-created folder with: cd <path-to-your-folder> If it is your first time do: vagrant up If vagrant was already running, please delete re-initialize with the following steps first : Delete old vagrant images via : vagrant destroy --force Remove residues of old vagrant boxes via : vagrant box remove ubuntu/<your-box-name> --all --force","title":"Step 3: Install Grid Singularity Exchange while sharing a folder between guest and host machine via vagrant"},{"location":"vm-installation-instructions/#step-4-reload-your-virtual-machine","text":"vagrant reload","title":"Step 4: Reload your virtual machine:"},{"location":"vm-installation-instructions/#step-5-access-your-virtual-machine-terminal-to-run-grid-singularity-exchange","text":"vagrant ssh","title":"Step 5: Access your virtual machine terminal to run Grid Singularity Exchange:"},{"location":"vm-installation-instructions/#step-6-share-folder-to-windows-host-by-running-these-three-commands","text":"cp -r /home/vagrant/gsy-e/vagrant/ Share gsy-e-sdk: cp -r /home/vagrant/gsy-e-sdk/vagrant/ If you have results you want to export to Windows : cd /home/vagrant/gsy-e-simulation/ zip -r <your-zip-filename>.zip ./<folder-to-be-zipped>/ cp -r <your-zip-filename>.zip /vagrant/","title":"Step 6: Share folder to Windows host by running these three commands:"},{"location":"vm-installation-instructions/#step-7-run-a-gsy-e-simulation","text":"Activate the gsy-e environment: source /home/vagrant/envs/gsy-e/bin/activate Run simulation with: cd /vagrant/gsy-e gsy-e run","title":"Step 7: Run a gsy-e simulation"},{"location":"vm-installation-instructions/#step-8-run-the-grid-singularity-exchange-sdk-in-vagrant","text":"Activate the Exchange SDK environment: source /home/vagrant/envs/exchange-sdk/bin/activate To run your SDK script, run the following command (template here): python your_sdk_script.py","title":"Step 8: Run the Grid Singularity Exchange SDK in Vagrant"},{"location":"img/power-plant/","text":"This energy asset is not yet available on the Singularity Map, but it will be available in the near future. It is still available to users on our previous interface (d3a.io) and in our backend. A finite power plant is an energy supplier that offers a configurable amount of power per time slot at a set rate. Asset Configuration Options Name - Must be unique. Energy rate - Selling price of the power plant in cents/kWh. Maximum available power - Maximum power that the power plant can supply in kW","title":"Power plant"}]}
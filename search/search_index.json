{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"APIs-introduction/","text":"To enable users to run a collaboration, Grid Singularity has developed a Software Development Kit - SDK ( gsy-e-sdk ), that allows users to perform the following functions; Asset Trading : The Asset API allows aggregators who manage individual and community energy assets to connect to the Grid Singularity Exchange and actively place bids and offers on their behalf. Aggregators can create custom strategies with the goal of optimizing trading for managed assets (Learn more about default trading strategies here); Grid Management : The Grid Operator API allows grid operators (DSO, DNO and TSO) to oversee multiple (sub)markets\u2019 statistics and results in real-time and influence trading behavior by implementing custom (dynamic) grid fee strategies. Examples of template agent scripts (flexible Python scripts) to connect to the Grid Singularity Exchange through the Software Development Kit are available in the Grid Singularity\u2019s GitHub repository for the Asset API and Grid Operator API and are explained in sections below (respectively here and here ). Figure 5.1 : Asset API and Grid Operator API interfacing with energy assets and markets in the Grid Singularity Exchange.","title":"Introduction"},{"location":"aggregate-market-summary/","text":"This market summary shows the net energy and volume in kWh for each 15 minute market slot. The average energy price and grid fees, if applied to this market are also shown in \u20ac/kWh. Figure 3.12 : Summary of volume traded, net energy, average price and grid fee in the Grid Singularity\u2019s simulation interface (Singularity Map)","title":"Aggregate Market Summary"},{"location":"asset-api-commands/","text":"An Oracle (see above ) is able to request information and post bids and offers for multiple assets at the same time by aggregating multiple commands in a single batch to be executed at the same time. The following are the different commands available for the Asset API: bid_energy() \u00b6 It sends an energy bid to the exchange. This command receives 4 arguments : asset_uuid : Universal Unique Identifier of the selected asset energy : energy in kWh price : price in Euro cents replace_existing : if set to TRUE replace all existing bids with a new one attributes (optional) : a dictionary of attributes that describes the bid (not supported at the moment) requirements (optional) : a list of dictionaries containing requirements for the bid. At least one of the provided dictionaries needs to be satisfied in the matching process. Currently supported requirements for bids are: energy_type: energy type (e.g., \u201cPV\u201d) that the bid prefers to consume trading_partners: IDs of the market or asset owner with which the bid prefers to be matched energy: energy quantity (expressed in kWh) that the bid prefers to consume price: trade price (expressed in Euro cents) that the bid prefers to accept time_slot (optional) : the time slot where the bid is going to be posted (to be used to trade post-delivery in the Settlement Market ) Here is an example: self.add_to_batch_commands.bid_energy(asset_uuid = \"2e7866d8-34c6-49ad-a388-fd5876a3e679\", energy = 2, price = 60, replace_existing = True, attributes = None, requirements = [{\u201cenergy_type\u201d: \u201cPV\u201d, \u201ctrading_partners\u201d = [], \u201cenergy\u201d = 5, \u201cprice\u201d: 28}], \u201ctime_slot\u201d = None) If the bid is placed successfully, it returns the detailed information about the bid. If not, it returns the reason for the error. bid_energy_rate() \u00b6 It sends an energy bid to the exchange. This batch command receives 4 arguments : asset_uuid : Universal Unique Identifier of the selected asset energy : energy in kWh rate : price per volume in Euro cents/kWh replace_existing : if set to TRUE replace all existing bids with a new one attributes (optional) : a dictionary of attributes that describes the bid (not supported at the moment) requirements (optional) : a list of dictionaries containing requirements for the bid. At least one of the provided dictionaries needs to be satisfied in the matching process. Currently supported requirements for bids are: energy_type: energy type (e.g., \u201cPV\u201d) that the bid prefers to consume trading_partners: IDs of the market or asset owner with which the bid prefers to be matched energy: energy quantity (expressed in kWh) that the bid prefers to consume price: trade price (expressed in Euro cents) that the bid prefers to accept time_slot (optional) : the time slot where the bid is going to be posted (to be used to trade post-delivery in the Settlement Market ) Here is an example: self.add_to_batch_commands.bid_energy_rate(asset_uuid = \"2e7866d8-34c6-49ad-a388-fd5876a3e679\", energy = 2, rate = 30, replace_existing = True, attributes = None, requirements = [{\u201cenergy_type\u201d: \u201cPV\u201d, \u201ctrading_partners\u201d = [], \u201cenergy\u201d = 5, \u201cprice\u201d: 28}], \u201ctime_slot\u201d = None) lists_bids() \u00b6 It lists all posted bids on the selected market. This command takes one argument: area_uuid, which is the Universal Unique Identifier of the selected market. Here is an example: self.add_to_batch_commands.list_bids(asset_uuid=\"62f827ec-ef86-4782-b5c3-88327751d97d\") delete_bid() \u00b6 It deletes a bid posted on the market using its ID. This command receives two arguments : asset_uuid : Universal Unique Identifier of the selected asset bid_id : ID of the selected bid. If None, all the bids posted by the selected asset will be deleted. Here is an example: self.add_to_batch_commands.delete_bid(asset_uuid=\"62f827ec-ef86-4782-b5c3-88327751d97d\", bid_id = \"2e7866d8-3dg6-49ad-afe8-fd5876a3e679\") offer_energy() \u00b6 It sends an energy offer to the exchange. This command receives 4 arguments : asset_uuid : Universal Unique Identifier of the selected asset energy : energy in kWh price : price in Euro cents replace_existing : if set to TRUE replace all existing bids with a new one attributes (optional) : a dictionary of attributes that describes the bid (not supported at the moment) requirements (optional) : a list of dictionaries containing requirements for the bid. At least one of the provided dictionaries needs to be satisfied in the matching process. Currently supported requirements for bids are: energy_type: energy type of the offer (e.g. solar) time_slot (optional) : the time slot where the bid is going to be posted (to be used to trade post-delivery in the Settlement Market ) Here is an example: self.add_to_batch_commands.offer_energy(asset_uuid = \"2e7866d8-34c6-49ad-a388-fd5876a3e679\", energy = 2, price_cents = 60, replace_existing = True, attributes = \u201cPV\u201d, requirements = [{ \u201ctrading_partners\u201d: \"62f827ec-ef86-4782-b5c3-88327751d97d\u201d}], \u201ctime_slot\u201d = None) If the offer is placed successfully, it returns the detailed information about the bid. If not, it returns the reason for the error. offer_energy_rate() \u00b6 It sends an energy offer to the exchange. This command receives four arguments : asset_uuid : Universal Unique Identifier of the selected asset energy : energy in kWh rate : price per volume in Euro cents/kWh replace_existing : if set to TRUE replace all existing offers with a new one requirements (optional) : a list of dictionaries containing requirements for the bid. At least one of the provided dictionaries needs to be satisfied in the matching process. Currently supported requirements for bids are: energy_type: energy type of the offer (e.g. solar) time_slot (optional) : the time slot where the bid is going to be posted (to be used to trade post-delivery in the Settlement Market ) Here is an example: self.add_to_batch_commands.offer_energy_rate(asset_uuid = \"2e7866d8-34c6-49ad-a388-fd5876a3e679\", energy = 2, rate = 30, replace_existing = True, attributes = \u201cPV\u201d, requirements = [{ \u201ctrading_partners\u201d: \"62f827ec-ef86-4782-b5c3-88327751d97d\u201d}], \u201ctime_slot\u201d = None) lists_offers() \u00b6 It lists all posted offers on the selected market. This command takes one argument: area_uuid, which is the Universal Unique Identifier of the selected market. Here is an example: self.add_to_batch_commands.list_offers(asset_uuid=\"62f827ec-ef86-4782-b5c3-88327751d97d\") delete_offer() \u00b6 It deletes an offer posted on the market using its ID. This command receives two arguments : asset_uuid : Universal Unique Identifier of the selected asset offer_id : ID of the selected offer. If None, all the bids posted by the selected asset will be deleted. Here is an example: self.add_to_batch_commands.delete_offer(asset_uuid=\"62f827ec-ef86-4782-b5c3-88327751d97d\", bid_id = \"2e7866d8-3dg6-49ad-afe8-fd5876a3e679\") asset_info() \u00b6 It gets asset information(returns required energy for Loads, available energy for PVs and energy to buy/sell for storages). This command receives one argument: asset_uuid, which is the Universal Unique Identifier of the selected asset. Here is an example: self.add_to_batch_commands.asset_info(asset_uuid=\"62f827ec-ef86-4782-b5c3-88327751d97d\") After adding all the wanted commands in the batch, the API can execute it with the following command: response = self.execute_batch_commands() In return the simulation will provide a detailed response for all commands submitted. Note: The total amount of energy to bid/offer at any point is limited to the energy requirement/available of the asset. Replacing/updating a bid/offer during a market slot deletes other active bids/offers. Additionally, the price of your bids/offers must be a positive float otherwise it will get rejected by the market.","title":"Asset API Commands"},{"location":"asset-api-commands/#bid_energy","text":"It sends an energy bid to the exchange. This command receives 4 arguments : asset_uuid : Universal Unique Identifier of the selected asset energy : energy in kWh price : price in Euro cents replace_existing : if set to TRUE replace all existing bids with a new one attributes (optional) : a dictionary of attributes that describes the bid (not supported at the moment) requirements (optional) : a list of dictionaries containing requirements for the bid. At least one of the provided dictionaries needs to be satisfied in the matching process. Currently supported requirements for bids are: energy_type: energy type (e.g., \u201cPV\u201d) that the bid prefers to consume trading_partners: IDs of the market or asset owner with which the bid prefers to be matched energy: energy quantity (expressed in kWh) that the bid prefers to consume price: trade price (expressed in Euro cents) that the bid prefers to accept time_slot (optional) : the time slot where the bid is going to be posted (to be used to trade post-delivery in the Settlement Market ) Here is an example: self.add_to_batch_commands.bid_energy(asset_uuid = \"2e7866d8-34c6-49ad-a388-fd5876a3e679\", energy = 2, price = 60, replace_existing = True, attributes = None, requirements = [{\u201cenergy_type\u201d: \u201cPV\u201d, \u201ctrading_partners\u201d = [], \u201cenergy\u201d = 5, \u201cprice\u201d: 28}], \u201ctime_slot\u201d = None) If the bid is placed successfully, it returns the detailed information about the bid. If not, it returns the reason for the error.","title":"bid_energy()"},{"location":"asset-api-commands/#bid_energy_rate","text":"It sends an energy bid to the exchange. This batch command receives 4 arguments : asset_uuid : Universal Unique Identifier of the selected asset energy : energy in kWh rate : price per volume in Euro cents/kWh replace_existing : if set to TRUE replace all existing bids with a new one attributes (optional) : a dictionary of attributes that describes the bid (not supported at the moment) requirements (optional) : a list of dictionaries containing requirements for the bid. At least one of the provided dictionaries needs to be satisfied in the matching process. Currently supported requirements for bids are: energy_type: energy type (e.g., \u201cPV\u201d) that the bid prefers to consume trading_partners: IDs of the market or asset owner with which the bid prefers to be matched energy: energy quantity (expressed in kWh) that the bid prefers to consume price: trade price (expressed in Euro cents) that the bid prefers to accept time_slot (optional) : the time slot where the bid is going to be posted (to be used to trade post-delivery in the Settlement Market ) Here is an example: self.add_to_batch_commands.bid_energy_rate(asset_uuid = \"2e7866d8-34c6-49ad-a388-fd5876a3e679\", energy = 2, rate = 30, replace_existing = True, attributes = None, requirements = [{\u201cenergy_type\u201d: \u201cPV\u201d, \u201ctrading_partners\u201d = [], \u201cenergy\u201d = 5, \u201cprice\u201d: 28}], \u201ctime_slot\u201d = None)","title":"bid_energy_rate()"},{"location":"asset-api-commands/#lists_bids","text":"It lists all posted bids on the selected market. This command takes one argument: area_uuid, which is the Universal Unique Identifier of the selected market. Here is an example: self.add_to_batch_commands.list_bids(asset_uuid=\"62f827ec-ef86-4782-b5c3-88327751d97d\")","title":"lists_bids()"},{"location":"asset-api-commands/#delete_bid","text":"It deletes a bid posted on the market using its ID. This command receives two arguments : asset_uuid : Universal Unique Identifier of the selected asset bid_id : ID of the selected bid. If None, all the bids posted by the selected asset will be deleted. Here is an example: self.add_to_batch_commands.delete_bid(asset_uuid=\"62f827ec-ef86-4782-b5c3-88327751d97d\", bid_id = \"2e7866d8-3dg6-49ad-afe8-fd5876a3e679\")","title":"delete_bid()"},{"location":"asset-api-commands/#offer_energy","text":"It sends an energy offer to the exchange. This command receives 4 arguments : asset_uuid : Universal Unique Identifier of the selected asset energy : energy in kWh price : price in Euro cents replace_existing : if set to TRUE replace all existing bids with a new one attributes (optional) : a dictionary of attributes that describes the bid (not supported at the moment) requirements (optional) : a list of dictionaries containing requirements for the bid. At least one of the provided dictionaries needs to be satisfied in the matching process. Currently supported requirements for bids are: energy_type: energy type of the offer (e.g. solar) time_slot (optional) : the time slot where the bid is going to be posted (to be used to trade post-delivery in the Settlement Market ) Here is an example: self.add_to_batch_commands.offer_energy(asset_uuid = \"2e7866d8-34c6-49ad-a388-fd5876a3e679\", energy = 2, price_cents = 60, replace_existing = True, attributes = \u201cPV\u201d, requirements = [{ \u201ctrading_partners\u201d: \"62f827ec-ef86-4782-b5c3-88327751d97d\u201d}], \u201ctime_slot\u201d = None) If the offer is placed successfully, it returns the detailed information about the bid. If not, it returns the reason for the error.","title":"offer_energy()"},{"location":"asset-api-commands/#offer_energy_rate","text":"It sends an energy offer to the exchange. This command receives four arguments : asset_uuid : Universal Unique Identifier of the selected asset energy : energy in kWh rate : price per volume in Euro cents/kWh replace_existing : if set to TRUE replace all existing offers with a new one requirements (optional) : a list of dictionaries containing requirements for the bid. At least one of the provided dictionaries needs to be satisfied in the matching process. Currently supported requirements for bids are: energy_type: energy type of the offer (e.g. solar) time_slot (optional) : the time slot where the bid is going to be posted (to be used to trade post-delivery in the Settlement Market ) Here is an example: self.add_to_batch_commands.offer_energy_rate(asset_uuid = \"2e7866d8-34c6-49ad-a388-fd5876a3e679\", energy = 2, rate = 30, replace_existing = True, attributes = \u201cPV\u201d, requirements = [{ \u201ctrading_partners\u201d: \"62f827ec-ef86-4782-b5c3-88327751d97d\u201d}], \u201ctime_slot\u201d = None)","title":"offer_energy_rate()"},{"location":"asset-api-commands/#lists_offers","text":"It lists all posted offers on the selected market. This command takes one argument: area_uuid, which is the Universal Unique Identifier of the selected market. Here is an example: self.add_to_batch_commands.list_offers(asset_uuid=\"62f827ec-ef86-4782-b5c3-88327751d97d\")","title":"lists_offers()"},{"location":"asset-api-commands/#delete_offer","text":"It deletes an offer posted on the market using its ID. This command receives two arguments : asset_uuid : Universal Unique Identifier of the selected asset offer_id : ID of the selected offer. If None, all the bids posted by the selected asset will be deleted. Here is an example: self.add_to_batch_commands.delete_offer(asset_uuid=\"62f827ec-ef86-4782-b5c3-88327751d97d\", bid_id = \"2e7866d8-3dg6-49ad-afe8-fd5876a3e679\")","title":"delete_offer()"},{"location":"asset-api-commands/#asset_info","text":"It gets asset information(returns required energy for Loads, available energy for PVs and energy to buy/sell for storages). This command receives one argument: asset_uuid, which is the Universal Unique Identifier of the selected asset. Here is an example: self.add_to_batch_commands.asset_info(asset_uuid=\"62f827ec-ef86-4782-b5c3-88327751d97d\") After adding all the wanted commands in the batch, the API can execute it with the following command: response = self.execute_batch_commands() In return the simulation will provide a detailed response for all commands submitted. Note: The total amount of energy to bid/offer at any point is limited to the energy requirement/available of the asset. Replacing/updating a bid/offer during a market slot deletes other active bids/offers. Additionally, the price of your bids/offers must be a positive float otherwise it will get rejected by the market.","title":"asset_info()"},{"location":"asset-api-events/","text":"Each market cycle lasts 15 minutes and is divided into 10 ticks until it ends. The bids and offers are posted within the market cycle at each tick until the cycle ends. Figure 5.4 : Market slot overall structure and Asset API events. At the beginning of each market slot, the Asset API receives markets and assets information structured in a nested dictionary according to the grid hierarchy. Each market provides statistics such as minimum, median and maximum trade rates, total energy volume traded, grid fees and each asset returns the last bills and energy volume traded in the previous market slot. At each tick of the market slot, the Asset API receives updated asset information (e.g. remaining energy to buy/sell) and can post/update/delete bids and offers. When the trade occurs, trade details are sent by the Asset API. If there are unmatched bids or offers, they are not carried to the next market cycle. In order to facilitate bid and offer management and scheduling, a python file with the class Oracle is provided. The Oracle class acts as an information aggregator for all of the energy assets (e.g. loads, PVs and storage) managed by the user, and allows the user to post bids and offers on their behalf. Several functions are triggered for different types of events , and can be overridden. Each new market slot \u00b6 def on_market_cycle(self, market_info): When a new market slot is available the client will get notified via an event. It is possible to capture this event and perform operations after it by overriding the on_market_cycle method, used to gather aggregated information about the assets and last market slot statistics, define the trading strategy and place the first bids/offers. In the variable market_info the user will get a dictionary with information on the market and assets. The user receives information for each asset he/she manages. The return values have the following structure: {'slot_completion': '0%', 'market_slot': '2014-10-01T00:15', 'grid_tree': {'477999f1-fd6e-4c68-8cc8-e8e52049de8e': {'last_market_bill': {'accumulated_trades': {}, 'external_trades': {}}, 'last_market_stats': {'min_trade_rate': 26.0, 'max_trade_rate': 26.0, 'avg_trade_rate': 26.0, 'median_trade_rate': 26.0, 'total_traded_energy_kWh': 7.5239405}, 'last_market_fee': 4, 'current_market_fee': 4, 'area_name': 'Grid', 'children': {'f02313bb-16c4-427b-90d2-d753822fe21c': {'last_market_bill': {'accumulated_trades': {}, 'external_trades': {}}, 'last_market_stats': {'min_trade_rate': 30.0, 'max_trade_rate': 30.0, 'avg_trade_rate': 30.0, 'median_trade_rate': 30.0, 'total_traded_energy_kWh': 7.5239405}, 'last_market_fee': 4, 'current_market_fee': 4, 'area_name': 'Community', 'children': {'44d19495-39e8-42e0-be2f-0432e644e5e5': {'last_market_bill': {'accumulated_trades': {}, 'external_trades': {}}, 'last_market_stats': {'min_trade_rate': None, 'max_trade_rate': None, 'avg_trade_rate': None, 'median_trade_rate': None, 'total_traded_energy_kWh': None}, 'last_market_fee': 0.0, 'current_market_fee': None, 'area_name': 'Member 1', 'children': {'075834dd-5438-4287-8393-781a4a8068f5': {'asset_info': {'energy_requirement_kWh': 0.06802025, 'energy_active_in_bids': 0.0, 'energy_traded': 0.0, 'total_cost': 0.0}, 'last_slot_asset_info': {'energy_traded': 0.0, 'total_cost': 0.0}, 'asset_bill': {}, 'area_name': 'Load 1'}, '2e7866d8-34c6-49ad-a388-fd5876a3e679': {'asset_info': {'available_energy_kWh': 0.0, 'energy_active_in_offers': 0, 'energy_traded': 0, 'total_cost': 0}, 'last_slot_asset_info': {'energy_traded': 0, 'total_cost': 0}, 'asset_bill': {}, 'area_name': 'PV 1'}, '22c495b2-4b2b-43ba-8c76-3eb956014975': {'asset_info': {'energy_to_sell': 0.0, 'energy_active_in_bids': 0, 'energy_to_buy': 1.36275, 'energy_active_in_offers': 0, 'free_storage': 10.0, 'used_storage': 0.0, 'energy_traded': 0.0, 'total_cost': 0.0}, 'last_slot_asset_info': {'energy_traded': 0.0, 'total_cost': 0.0}, 'asset_bill': {}, 'area_name': 'Storage 1'}}}, '5c0c05dd-2e23-4866-a113-e08797a2094e': {'last_market_bill': {'accumulated_trades': {}, 'external_trades': {}}, 'last_market_stats': {'min_trade_rate': 30.0, 'max_trade_rate': 30.0, 'avg_trade_rate': 30.0, 'median_trade_rate': 30.0, 'total_traded_energy_kWh': 0.064779}, 'last_market_fee': 0.0, 'current_market_fee': None, 'feed_in_tariff_rate': 21.9, 'market_maker_rate': 22, 'event': 'market', 'num_ticks': 10.0, 'simulation_id': None 'feed_in_tariff_rate': 21.9, 'market_maker_rate': 22, 'event': 'market', 'num_ticks': 10.0, 'simulation_id': None } On % of market completion \u00b6 def on_tick(self, tick_info): At each 10% of market slot completion (e.g. 10%, 20%, 30%, \u2026), the same information as market_info will be passed, with updated asset energy requirements based on trades. This can be used to update the user\u2019s bid or offer price at these milestones. On event or response \u00b6 def on_event_or_response(self, message): Each time the managed assets are triggered with an event or get any responses (from sending the batch commands such as trades confirmations), this information is repassed through on_event_or_response. This information can be stored locally or acted upon. On finish \u00b6 def on_finish(self, finish_info): This executes when the simulation finishes, and can be used to trigger exporting data, training a model or exiting the code.","title":"Asset API Events"},{"location":"asset-api-events/#each-new-market-slot","text":"def on_market_cycle(self, market_info): When a new market slot is available the client will get notified via an event. It is possible to capture this event and perform operations after it by overriding the on_market_cycle method, used to gather aggregated information about the assets and last market slot statistics, define the trading strategy and place the first bids/offers. In the variable market_info the user will get a dictionary with information on the market and assets. The user receives information for each asset he/she manages. The return values have the following structure: {'slot_completion': '0%', 'market_slot': '2014-10-01T00:15', 'grid_tree': {'477999f1-fd6e-4c68-8cc8-e8e52049de8e': {'last_market_bill': {'accumulated_trades': {}, 'external_trades': {}}, 'last_market_stats': {'min_trade_rate': 26.0, 'max_trade_rate': 26.0, 'avg_trade_rate': 26.0, 'median_trade_rate': 26.0, 'total_traded_energy_kWh': 7.5239405}, 'last_market_fee': 4, 'current_market_fee': 4, 'area_name': 'Grid', 'children': {'f02313bb-16c4-427b-90d2-d753822fe21c': {'last_market_bill': {'accumulated_trades': {}, 'external_trades': {}}, 'last_market_stats': {'min_trade_rate': 30.0, 'max_trade_rate': 30.0, 'avg_trade_rate': 30.0, 'median_trade_rate': 30.0, 'total_traded_energy_kWh': 7.5239405}, 'last_market_fee': 4, 'current_market_fee': 4, 'area_name': 'Community', 'children': {'44d19495-39e8-42e0-be2f-0432e644e5e5': {'last_market_bill': {'accumulated_trades': {}, 'external_trades': {}}, 'last_market_stats': {'min_trade_rate': None, 'max_trade_rate': None, 'avg_trade_rate': None, 'median_trade_rate': None, 'total_traded_energy_kWh': None}, 'last_market_fee': 0.0, 'current_market_fee': None, 'area_name': 'Member 1', 'children': {'075834dd-5438-4287-8393-781a4a8068f5': {'asset_info': {'energy_requirement_kWh': 0.06802025, 'energy_active_in_bids': 0.0, 'energy_traded': 0.0, 'total_cost': 0.0}, 'last_slot_asset_info': {'energy_traded': 0.0, 'total_cost': 0.0}, 'asset_bill': {}, 'area_name': 'Load 1'}, '2e7866d8-34c6-49ad-a388-fd5876a3e679': {'asset_info': {'available_energy_kWh': 0.0, 'energy_active_in_offers': 0, 'energy_traded': 0, 'total_cost': 0}, 'last_slot_asset_info': {'energy_traded': 0, 'total_cost': 0}, 'asset_bill': {}, 'area_name': 'PV 1'}, '22c495b2-4b2b-43ba-8c76-3eb956014975': {'asset_info': {'energy_to_sell': 0.0, 'energy_active_in_bids': 0, 'energy_to_buy': 1.36275, 'energy_active_in_offers': 0, 'free_storage': 10.0, 'used_storage': 0.0, 'energy_traded': 0.0, 'total_cost': 0.0}, 'last_slot_asset_info': {'energy_traded': 0.0, 'total_cost': 0.0}, 'asset_bill': {}, 'area_name': 'Storage 1'}}}, '5c0c05dd-2e23-4866-a113-e08797a2094e': {'last_market_bill': {'accumulated_trades': {}, 'external_trades': {}}, 'last_market_stats': {'min_trade_rate': 30.0, 'max_trade_rate': 30.0, 'avg_trade_rate': 30.0, 'median_trade_rate': 30.0, 'total_traded_energy_kWh': 0.064779}, 'last_market_fee': 0.0, 'current_market_fee': None, 'feed_in_tariff_rate': 21.9, 'market_maker_rate': 22, 'event': 'market', 'num_ticks': 10.0, 'simulation_id': None 'feed_in_tariff_rate': 21.9, 'market_maker_rate': 22, 'event': 'market', 'num_ticks': 10.0, 'simulation_id': None }","title":"Each new market slot"},{"location":"asset-api-events/#on-of-market-completion","text":"def on_tick(self, tick_info): At each 10% of market slot completion (e.g. 10%, 20%, 30%, \u2026), the same information as market_info will be passed, with updated asset energy requirements based on trades. This can be used to update the user\u2019s bid or offer price at these milestones.","title":"On % of market completion"},{"location":"asset-api-events/#on-event-or-response","text":"def on_event_or_response(self, message): Each time the managed assets are triggered with an event or get any responses (from sending the batch commands such as trades confirmations), this information is repassed through on_event_or_response. This information can be stored locally or acted upon.","title":"On event or response"},{"location":"asset-api-events/#on-finish","text":"def on_finish(self, finish_info): This executes when the simulation finishes, and can be used to trigger exporting data, training a model or exiting the code.","title":"On finish"},{"location":"asset-api-template-script/","text":"Asset API template scripts are flexible and versatile Python scripts that can be easily modified for the implementation of custom smart trading strategies, integration of trading preferences ( Degrees of Freedom ), interaction with the Settlement Market and other uses. In this section, each script will be described along with its functionalities, in order of complexity. Post bids and offers to the Grid Singularity Exchange \u00b6 The key functionality of the Asset API is to post bids or offers to the Grid Singularity Exchange on behalf of energy asset owners based on their preferences. A template script can be found here . Users need to list the names of the assets to be connected with the Asset API, as shown in the following example. For simulations launched from the user-interface (UI), the CONNECT_TO_ALL_ASSETS parameter is available. If set to True, the Asset API connects automatically to all the assets the aggregator is connected to. # List of assets' names to be connected with the API LOAD_NAMES = [\"Load 1 L13\", \"Load 2 L21\", \"Load 3 L17\"] PV_NAMES = [\"PV 1 (4kW)\", \"PV 3 (5kW)\"] STORAGE_NAMES = [\"Tesla Powerwall 3\"] CONNECT_TO_ALL_ASSETS = True The goal of this template script is to send, at each market slot , a bid and/or an offer for each energy asset. This is performed by the post_bid_offer function, which loops through all the assets connected with the Asset API, extracts their required or available energy and posts these values along with an associated rate for clearance and settlement by the Grid Singularity Exchange. As shown in the snippet below, the process is separated for consumption, generation and storage assets. def post_bid_offer(self): \"\"\"Post a bid or an offer to the exchange.\"\"\" for area_uuid, area_dict in self.latest_grid_tree_flat.items(): asset_info = area_dict.get(\"asset_info\") if not asset_info: continue # Consumption assets required_energy = asset_info.get(\"energy_requirement_kWh\") if required_energy: self.add_to_batch_commands.bid_energy_rate( asset_uuid=area_uuid, rate=10, energy=required_energy ) # Generation assets available_energy = asset_info.get(\"available_energy_kWh\") if available_energy: self.add_to_batch_commands.offer_energy_rate( asset_uuid=area_uuid, rate=10, energy=available_energy ) # Storage assets buy_energy = asset_info.get(\"energy_to_buy\") if buy_energy: self.add_to_batch_commands.bid_energy_rate( asset_uuid=area_uuid, rate=10, energy=buy_energy ) sell_energy = asset_info.get(\"energy_to_sell\") if sell_energy: self.add_to_batch_commands.offer_energy_rate( asset_uuid=area_uuid, rate=10, energy=sell_energy ) self.execute_batch_commands() Later in the script, the on_event_or_response is called. By default, the Asset API template does not perform any operation here but the user can add events . For instance, the user could record all the trades occurring in that event. Lastly, the script overwrites the on_finish event so that when this function is triggered, the script stops. If the user wishes to save any information reported in the logs, this can be done by exporting it to an external file. def on_event_or_response(self, message): pass def on_finish(self, finish_info): self.is_finished = True The rest of the script is used to connect to the energy assets of a running simulation / collaboration / Canary Test Network , with the purpose of actively placing bids and offers on their behalf. aggregator = Oracle(aggregator_name=ORACLE_NAME) simulation_id = os.environ[\"API_CLIENT_SIMULATION_ID\"] domain_name = os.environ[\"API_CLIENT_DOMAIN_NAME\"] websockets_domain_name = os.environ[\"API_CLIENT_WEBSOCKET_DOMAIN_NAME\"] asset_args = {\"autoregister\": False, \"start_websocket\": False} if CONNECT_TO_ALL_ASSETS: registry = aggregator.get_configuration_registry() registered_assets = get_assets_name(registry) LOAD_NAMES = registered_assets[\"Load\"] PV_NAMES = registered_assets[\"PV\"] STORAGE_NAMES = registered_assets[\"Storage\"] def register_asset_list(asset_names: List, asset_params: Dict, asset_uuid_map: Dict) -> Dict: \"\"\"Register the provided list of assets with the aggregator.\"\"\" for asset_name in asset_names: print(\"Registered asset:\", asset_name) uuid = get_area_uuid_from_area_name_and_collaboration_id( simulation_id, asset_name, domain_name ) asset_params[\"asset_uuid\"] = uuid asset_uuid_map[uuid] = asset_name asset = RestAssetClient(**asset_params) asset.select_aggregator(aggregator.aggregator_uuid) return asset_uuid_map print() print(\"Registering assets ...\") asset_uuid_mapping = {} asset_uuid_mapping = register_asset_list(LOAD_NAMES + PV_NAMES + STORAGE_NAMES, asset_args, asset_uuid_mapping) print() print(\"Summary of assets registered:\") print() print(asset_uuid_mapping) # loop to allow persistence while not aggregator.is_finished: sleep(0.5) For simulations run in the backend, a similar script is available here . Implement trading strategies \u00b6 One of the main functionalities provided by the Asset API is to implement customized trading strategies. The Asset API script stores energy assets information such as the energy requirements for the loads , the energy available for the PVs and the State of Charge for the storage . This information when aggregated could be valuable when designing a smarter trading strategy. A template script can be found here . At the beginning of the on_market_slot event, the script generates the trading strategies (in the build_strategies function). The Market Maker price and the Feed-in Tariff values are required to set the pricing boundaries for the trading strategy. fit_rate = market_info[\"feed_in_tariff_rate\"] market_maker_rate = market_info[\"market_maker_rate\"] med_price = (market_maker_rate - fit_rate) / 2 + fit_rate Then, the script creates the asset_strategy dictionary, which contains various information for each asset, such as its name, its type (load, PV or storage) and the grid fees between the assets and the market maker. To calculate the grid fees between two assets or markets in the grid, the calculate_grid_fee function is used,which takes 3 arguments: start_market_or_asset_name : UUID of the started market/asset target_market_or_asset_name : UUID of the targeted market/asset fee_type : can either be \"current_market_fee\" or \u201clast_market_fee\u201d The fees are integrated in the pricing strategy in order to avoid any power outages for the loads or PV curtailment. for area_uuid, area_dict in self.latest_grid_tree_flat.items(): if \"asset_info\" not in area_dict or area_dict[\"asset_info\"] is None: continue self.asset_strategy[area_uuid] = {} self.asset_strategy[area_uuid][\"asset_name\"] = area_dict[\"area_name\"] self.asset_strategy[area_uuid][ \"fee_to_market_maker\" ] = self.calculate_grid_fee( area_uuid, self.get_uuid_from_area_name(\"Market Maker\"), \"current_market_fee\", ) Lastly, in the asset_strategy dictionary, the pricing strategy is defined for each asset individually. This allows assets to have independent strategies depending on the available market information and their location in the grid. The current pricing strategies are deterministic, representing a linear function bounded between the Feed-in Tariff-grid fee (lower boundary) and the Market Maker price + grid fee (upper boundary). Since the Asset API can post up to 10 bids/offers per market slot, the strategies incrementally ramp up (bids) or down (offers) for a total of 10 prices per energy asset. The final bid/offer price is set at least 2 ticks before the end of the market slot (9th and 10th tick in the example). The load strategy, the PV strategy and the storage strategy, as assets that can charge and discharge and therefore place bids and offers at the same time, are designed as follows. # Consumption strategy if \"energy_requirement_kWh\" in area_dict[\"asset_info\"]: load_strategy = [] for tick in range(0, TICKS): if tick < TICKS - 2: buy_rate = (fit_rate - self.asset_strategy[area_uuid][\"fee_to_market_maker\"] + (market_maker_rate + 2 * self.asset_strategy[area_uuid][\"fee_to_market_maker\"] - fit_rate) * (tick / TICKS) ) load_strategy.append(buy_rate) else: buy_rate = market_maker_rate + ( self.asset_strategy[area_uuid][\"fee_to_market_maker\"]) load_strategy.append(buy_rate) self.asset_strategy[area_uuid][\"buy_rates\"] = load_strategy # Generation strategy if \"available_energy_kWh\" in area_dict[\"asset_info\"]: gen_strategy = [] for tick in range(0, TICKS): if tick < TICKS - 2: sell_rate = (market_maker_rate + self.asset_strategy[area_uuid][\"fee_to_market_maker\"] - (market_maker_rate + 2 * self.asset_strategy[area_uuid][\"fee_to_market_maker\"] - fit_rate) * (tick / TICKS) ) gen_strategy.append(max(0, sell_rate)) else: sell_rate = fit_rate - ( self.asset_strategy[area_uuid][\"fee_to_market_maker\"]) gen_strategy.append(max(0, sell_rate)) self.asset_strategy[area_uuid][\"sell_rates\"] = gen_strategy # Storage strategy if \"used_storage\" in area_dict[\"asset_info\"]: batt_buy_strategy = [] batt_sell_strategy = [] for tick in range(0, TICKS): buy_rate = (fit_rate - self.asset_strategy[area_uuid][\"fee_to_market_maker\"] + (med_price - (fit_rate - self.asset_strategy[area_uuid][\"fee_to_market_maker\"] ) ) * (tick / TICKS) ) batt_buy_strategy.append(buy_rate) sell_rate = (market_maker_rate + self.asset_strategy[area_uuid][\"fee_to_market_maker\"] - (market_maker_rate + self.asset_strategy[area_uuid][\"fee_to_market_maker\"] - med_price) * (tick / TICKS) ) batt_sell_strategy.append(sell_rate) self.asset_strategy[area_uuid][\"buy_rates\"] = batt_buy_strategy self.asset_strategy[area_uuid][\"sell_rates\"] = batt_sell_strategy At each on_tick event, the Asset API will post new bids and offers, or update / delete existing ones. This allows the Exchange SDK to update their price strategy until all consumption and generation have been traded. In the following lines the Exchange SDK updates the existing bids/offers with new prices to optimize trades. The updated energy information is found in latest_grid_tree_flat.items() and the prices for each bid/offer depend on the market slot progression. All the commands are then executed. def post_bid_offer(self, rate_index=0): \"\"\"Post a bid or an offer to the exchange.\"\"\" for area_uuid, area_dict in self.latest_grid_tree_flat.items(): asset_info = area_dict.get(\"asset_info\") if not asset_info: continue # Consumption assets required_energy = asset_info.get(\"energy_requirement_kWh\") if required_energy: rate = self.asset_strategy[area_uuid][\"buy_rates\"][rate_index] self.add_to_batch_commands.bid_energy_rate( asset_uuid=area_uuid, rate=rate, energy=required_energy ) # Generation assets available_energy = asset_info.get(\"available_energy_kWh\") if available_energy: rate = self.asset_strategy[area_uuid][\"sell_rates\"][rate_index] self.add_to_batch_commands.offer_energy_rate( asset_uuid=area_uuid, rate=rate, energy=available_energy ) # Storage assets buy_energy = asset_info.get(\"energy_to_buy\") if buy_energy: buy_rate = self.asset_strategy[area_uuid][\"buy_rates\"][rate_index] self.add_to_batch_commands.bid_energy_rate( asset_uuid=area_uuid, rate=buy_rate, energy=buy_energy ) sell_energy = asset_info.get(\"energy_to_sell\") if sell_energy: sell_rate = self.asset_strategy[area_uuid][\"sell_rates\"][rate_index] self.add_to_batch_commands.offer_energy_rate( asset_uuid=area_uuid, rate=sell_rate, energy=sell_energy ) self.execute_batch_commands() The rest of the script functionality has been covered in the previous section . For simulations run in the backend, a similar script is available here . Introduce trading preferences with the Degrees of Freedom \u00b6 With the Asset API, users also have the option to specify trading preferences for each asset, such as preferred trading partners, energy type, energy amount and rate. An example of such a script can be found here . These preferences are also known as requirements and attributes or \u201cdegrees of freedom\u201d, as explained here . Requirements are uploaded to the template script via a JSON file (an example can be found here ), which has the following structure: { \"Load 3 L17\":[ { \"Trading Partners\": [\"PV 9 (15kW)\"], \"Energy Types\": [], \"Energy\": \"None\", \"Rate\": \"None\" } ], \"Load 2 L21\":[ { \"Trading Partners\": [\"PV 5 (10kW)\"], \"Energy Types\": [], \"Energy\": 10, \"Rate\": 3 } ], \"Load 1 L13\":[ { \"Trading Partners\": [], \"Energy Types\": [], \"Energy\": \"None\", \"Rate\": \"None\" } ] } In this example it is shown how, for each load, the four above mentioned requirements are listed and specified in value. It is also possible not to set any specific requirement to an asset, as for Load 1 L13. If, for example, \u201cEnergy\u201d and \u201cRate\u201d are set to None, the default energy and rate values from the template trading strategies are assigned. At each market slot , the Asset API loads and reads the information contained in this JSON file with the following function: def read_requirements(self): \"\"\"Load the JSON file containing the list of requirements for each asset.\"\"\" with open( os.path.join(module_dir, \"resources/requirements.json\"), \"r\", encoding=\"utf-8\", ) as file: self.degrees_of_freedom = json.load(file) Subsequently, a bid with the associated requirements is posted to the Exchange (for more on how to post bids and offers please see here .) The requirements uploaded through the JSON file must be converted to the correct format ahead of submission to the Exchange. To do so, the build_requirements_dict function is used: def build_requirements_dict(self, rate, energy, area_name): \"\"\"Return a dictionary with the requirements of the asset.\"\"\" asset_dof_list = self.degrees_of_freedom[area_name] for asset_dof in asset_dof_list: id_trading_partners_list = get_partner_ids(asset_dof[\"Trading Partners\"]) energy_types_list = asset_dof[\"Energy Types\"] energy_requirement = ( energy if asset_dof[\"Energy\"] == \"None\" else min(asset_dof[\"Energy\"], energy) ) rate_requirement = ( rate if asset_dof[\"Rate\"] == \"None\" else asset_dof[\"Rate\"] ) requirements = [ { \"trading_partners\": id_trading_partners_list, \"energy_type\": energy_types_list, \"energy\": energy_requirement, \"price\": rate_requirement * energy_requirement, } ] return requirements The rest of the script functionality has been covered in the previous section . It is important to note that currently there is no available template script for introducing degrees of freedom from the UI, but solely from the backend . Send live data to a Canary Test Network \u00b6 As noted here , the Asset API has the functionality to send live data to Grid Singularity Canary Test Network . A template script can be found here . To do so, at each market slot , forecast for the next 15 minutes are sent through the following function: def send_forecasts(self, market_info): \"\"\"Send forecasts of the next market slot to the exchange.\"\"\" forecast_market_slot = ( from_format(market_info[\"market_slot\"], DATE_TIME_FORMAT) .add(minutes=15) .format(DATE_TIME_FORMAT) ) # pylint: disable=unused-variable for area_uuid, area_dict in self.latest_grid_tree_flat.items(): asset_info = area_dict.get(\"asset_info\") if not asset_info: continue # Consumption assets if \"energy_requirement_kWh\" in asset_info: asset_name = area_dict[\"area_name\"] globals()[f\"{asset_name}\"].set_energy_forecast( energy_forecast_kWh={forecast_market_slot: 1.2}, do_not_wait=False, ) # Generation assets if \"available_energy_kWh\" in asset_info: asset_name = area_dict[\"area_name\"] globals()[f\"{asset_name}\"].set_energy_forecast( energy_forecast_kWh={forecast_market_slot: 0.86}, do_not_wait=False, ) self.execute_batch_commands() The forecast_market_slot , namely the marker slot at which the forecasted value is sent, is first retrieved by the market_info dictionary. Then, the set_energy_forecast function is used to send consumption / generation forecasted values to the Grid Singularity Exchange. In this example, 1.2 kWh are sent as consumption forecasts and 0.86 kWh are sent as generation forecasts. The rest of the script functionality has been covered in the previous section . Post energy deviations in the Settlement Market \u00b6 Finally, the Asset API can also be used to post energy deviations between forecasts (namely the values of consumption or generation that an asset was expected to consume or produce) and measurements (namely the actual consumption or generation values) in the Settlement Market . A template script can be found here . As noted in the previous section, users can send forecasts (generated by assets or other data source) to the Grid Singularity Exchange by using the Asset API. To settle energy deviations in the Settlement Market, further action is needed, which is to send measurements to the Exchange at each market slot by using the following function: def send_measurements(self, market_info): \"\"\"Send measurements for the current market slot to the exchange.\"\"\" # pylint: disable=unused-variable for area_uuid, area_dict in self.latest_grid_tree_flat.items(): if \"asset_info\" not in area_dict or area_dict[\"asset_info\"] is None: continue # Consumption assets if \"energy_requirement_kWh\" in area_dict[\"asset_info\"]: self.add_to_batch_commands.set_energy_measurement( asset_uuid=area_uuid, energy_measurement_kWh={market_info[\"market_slot\"]: 1.23}, ) # Generation assets if \"available_energy_kWh\" in area_dict[\"asset_info\"]: self.add_to_batch_commands.set_energy_measurement( asset_uuid=area_uuid, energy_measurement_kWh={market_info[\"market_slot\"]: 0.87}, ) As shown in the snippet above, set_energy_measurement is used to send values to the Exchange which, in this example, are sent to the current market slot. Later, in settle_energy_deviation , the Asset API computes the difference between the forecast and measured values, called in the script unsettled_deviation . Depending on whether this value is positive or negative, a bid or an offer will be posted in the Settlement Market. The rate, as well as the time slot for order placement can be arbitrarily set by the user. Below is the snippet of the described function: def settle_energy_deviations(self): \"\"\"Post the energy deviations between forecasts and measurements in the Settlement market.\"\"\" for area_uuid, area_dict in self.latest_grid_tree_flat.items(): if not area_dict.get(\"asset_info\"): continue time_slot = ( list(area_dict[\"asset_info\"][\"unsettled_deviation_kWh\"].keys())[-1]) unsettled_deviation = area_dict[\"asset_info\"][ \"unsettled_deviation_kWh\" ].get(time_slot) if unsettled_deviation > 0: self.add_to_batch_commands.bid_energy_rate( asset_uuid=area_uuid, rate=5, energy=unsettled_deviation, time_slot=time_slot, ) if unsettled_deviation < 0: self.add_to_batch_commands.offer_energy_rate( asset_uuid=area_uuid, rate=10, energy=abs(unsettled_deviation), time_slot=time_slot, ) The rest of the script functionality has been covered in the previous section . It is important to note that currently there is no available template script for interacting with the Settlement Market from the UI, but solely from the backend . The next step is to adapt the Asset API template scripts developed by Grid Singularity to customize your trading strategies, whether to send live data to the Grid Singularity Canary Test Network or to interact with the Settlement Market .","title":"Asset API Template Script"},{"location":"asset-api-template-script/#post-bids-and-offers-to-the-grid-singularity-exchange","text":"The key functionality of the Asset API is to post bids or offers to the Grid Singularity Exchange on behalf of energy asset owners based on their preferences. A template script can be found here . Users need to list the names of the assets to be connected with the Asset API, as shown in the following example. For simulations launched from the user-interface (UI), the CONNECT_TO_ALL_ASSETS parameter is available. If set to True, the Asset API connects automatically to all the assets the aggregator is connected to. # List of assets' names to be connected with the API LOAD_NAMES = [\"Load 1 L13\", \"Load 2 L21\", \"Load 3 L17\"] PV_NAMES = [\"PV 1 (4kW)\", \"PV 3 (5kW)\"] STORAGE_NAMES = [\"Tesla Powerwall 3\"] CONNECT_TO_ALL_ASSETS = True The goal of this template script is to send, at each market slot , a bid and/or an offer for each energy asset. This is performed by the post_bid_offer function, which loops through all the assets connected with the Asset API, extracts their required or available energy and posts these values along with an associated rate for clearance and settlement by the Grid Singularity Exchange. As shown in the snippet below, the process is separated for consumption, generation and storage assets. def post_bid_offer(self): \"\"\"Post a bid or an offer to the exchange.\"\"\" for area_uuid, area_dict in self.latest_grid_tree_flat.items(): asset_info = area_dict.get(\"asset_info\") if not asset_info: continue # Consumption assets required_energy = asset_info.get(\"energy_requirement_kWh\") if required_energy: self.add_to_batch_commands.bid_energy_rate( asset_uuid=area_uuid, rate=10, energy=required_energy ) # Generation assets available_energy = asset_info.get(\"available_energy_kWh\") if available_energy: self.add_to_batch_commands.offer_energy_rate( asset_uuid=area_uuid, rate=10, energy=available_energy ) # Storage assets buy_energy = asset_info.get(\"energy_to_buy\") if buy_energy: self.add_to_batch_commands.bid_energy_rate( asset_uuid=area_uuid, rate=10, energy=buy_energy ) sell_energy = asset_info.get(\"energy_to_sell\") if sell_energy: self.add_to_batch_commands.offer_energy_rate( asset_uuid=area_uuid, rate=10, energy=sell_energy ) self.execute_batch_commands() Later in the script, the on_event_or_response is called. By default, the Asset API template does not perform any operation here but the user can add events . For instance, the user could record all the trades occurring in that event. Lastly, the script overwrites the on_finish event so that when this function is triggered, the script stops. If the user wishes to save any information reported in the logs, this can be done by exporting it to an external file. def on_event_or_response(self, message): pass def on_finish(self, finish_info): self.is_finished = True The rest of the script is used to connect to the energy assets of a running simulation / collaboration / Canary Test Network , with the purpose of actively placing bids and offers on their behalf. aggregator = Oracle(aggregator_name=ORACLE_NAME) simulation_id = os.environ[\"API_CLIENT_SIMULATION_ID\"] domain_name = os.environ[\"API_CLIENT_DOMAIN_NAME\"] websockets_domain_name = os.environ[\"API_CLIENT_WEBSOCKET_DOMAIN_NAME\"] asset_args = {\"autoregister\": False, \"start_websocket\": False} if CONNECT_TO_ALL_ASSETS: registry = aggregator.get_configuration_registry() registered_assets = get_assets_name(registry) LOAD_NAMES = registered_assets[\"Load\"] PV_NAMES = registered_assets[\"PV\"] STORAGE_NAMES = registered_assets[\"Storage\"] def register_asset_list(asset_names: List, asset_params: Dict, asset_uuid_map: Dict) -> Dict: \"\"\"Register the provided list of assets with the aggregator.\"\"\" for asset_name in asset_names: print(\"Registered asset:\", asset_name) uuid = get_area_uuid_from_area_name_and_collaboration_id( simulation_id, asset_name, domain_name ) asset_params[\"asset_uuid\"] = uuid asset_uuid_map[uuid] = asset_name asset = RestAssetClient(**asset_params) asset.select_aggregator(aggregator.aggregator_uuid) return asset_uuid_map print() print(\"Registering assets ...\") asset_uuid_mapping = {} asset_uuid_mapping = register_asset_list(LOAD_NAMES + PV_NAMES + STORAGE_NAMES, asset_args, asset_uuid_mapping) print() print(\"Summary of assets registered:\") print() print(asset_uuid_mapping) # loop to allow persistence while not aggregator.is_finished: sleep(0.5) For simulations run in the backend, a similar script is available here .","title":"Post bids and offers to the Grid Singularity Exchange"},{"location":"asset-api-template-script/#implement-trading-strategies","text":"One of the main functionalities provided by the Asset API is to implement customized trading strategies. The Asset API script stores energy assets information such as the energy requirements for the loads , the energy available for the PVs and the State of Charge for the storage . This information when aggregated could be valuable when designing a smarter trading strategy. A template script can be found here . At the beginning of the on_market_slot event, the script generates the trading strategies (in the build_strategies function). The Market Maker price and the Feed-in Tariff values are required to set the pricing boundaries for the trading strategy. fit_rate = market_info[\"feed_in_tariff_rate\"] market_maker_rate = market_info[\"market_maker_rate\"] med_price = (market_maker_rate - fit_rate) / 2 + fit_rate Then, the script creates the asset_strategy dictionary, which contains various information for each asset, such as its name, its type (load, PV or storage) and the grid fees between the assets and the market maker. To calculate the grid fees between two assets or markets in the grid, the calculate_grid_fee function is used,which takes 3 arguments: start_market_or_asset_name : UUID of the started market/asset target_market_or_asset_name : UUID of the targeted market/asset fee_type : can either be \"current_market_fee\" or \u201clast_market_fee\u201d The fees are integrated in the pricing strategy in order to avoid any power outages for the loads or PV curtailment. for area_uuid, area_dict in self.latest_grid_tree_flat.items(): if \"asset_info\" not in area_dict or area_dict[\"asset_info\"] is None: continue self.asset_strategy[area_uuid] = {} self.asset_strategy[area_uuid][\"asset_name\"] = area_dict[\"area_name\"] self.asset_strategy[area_uuid][ \"fee_to_market_maker\" ] = self.calculate_grid_fee( area_uuid, self.get_uuid_from_area_name(\"Market Maker\"), \"current_market_fee\", ) Lastly, in the asset_strategy dictionary, the pricing strategy is defined for each asset individually. This allows assets to have independent strategies depending on the available market information and their location in the grid. The current pricing strategies are deterministic, representing a linear function bounded between the Feed-in Tariff-grid fee (lower boundary) and the Market Maker price + grid fee (upper boundary). Since the Asset API can post up to 10 bids/offers per market slot, the strategies incrementally ramp up (bids) or down (offers) for a total of 10 prices per energy asset. The final bid/offer price is set at least 2 ticks before the end of the market slot (9th and 10th tick in the example). The load strategy, the PV strategy and the storage strategy, as assets that can charge and discharge and therefore place bids and offers at the same time, are designed as follows. # Consumption strategy if \"energy_requirement_kWh\" in area_dict[\"asset_info\"]: load_strategy = [] for tick in range(0, TICKS): if tick < TICKS - 2: buy_rate = (fit_rate - self.asset_strategy[area_uuid][\"fee_to_market_maker\"] + (market_maker_rate + 2 * self.asset_strategy[area_uuid][\"fee_to_market_maker\"] - fit_rate) * (tick / TICKS) ) load_strategy.append(buy_rate) else: buy_rate = market_maker_rate + ( self.asset_strategy[area_uuid][\"fee_to_market_maker\"]) load_strategy.append(buy_rate) self.asset_strategy[area_uuid][\"buy_rates\"] = load_strategy # Generation strategy if \"available_energy_kWh\" in area_dict[\"asset_info\"]: gen_strategy = [] for tick in range(0, TICKS): if tick < TICKS - 2: sell_rate = (market_maker_rate + self.asset_strategy[area_uuid][\"fee_to_market_maker\"] - (market_maker_rate + 2 * self.asset_strategy[area_uuid][\"fee_to_market_maker\"] - fit_rate) * (tick / TICKS) ) gen_strategy.append(max(0, sell_rate)) else: sell_rate = fit_rate - ( self.asset_strategy[area_uuid][\"fee_to_market_maker\"]) gen_strategy.append(max(0, sell_rate)) self.asset_strategy[area_uuid][\"sell_rates\"] = gen_strategy # Storage strategy if \"used_storage\" in area_dict[\"asset_info\"]: batt_buy_strategy = [] batt_sell_strategy = [] for tick in range(0, TICKS): buy_rate = (fit_rate - self.asset_strategy[area_uuid][\"fee_to_market_maker\"] + (med_price - (fit_rate - self.asset_strategy[area_uuid][\"fee_to_market_maker\"] ) ) * (tick / TICKS) ) batt_buy_strategy.append(buy_rate) sell_rate = (market_maker_rate + self.asset_strategy[area_uuid][\"fee_to_market_maker\"] - (market_maker_rate + self.asset_strategy[area_uuid][\"fee_to_market_maker\"] - med_price) * (tick / TICKS) ) batt_sell_strategy.append(sell_rate) self.asset_strategy[area_uuid][\"buy_rates\"] = batt_buy_strategy self.asset_strategy[area_uuid][\"sell_rates\"] = batt_sell_strategy At each on_tick event, the Asset API will post new bids and offers, or update / delete existing ones. This allows the Exchange SDK to update their price strategy until all consumption and generation have been traded. In the following lines the Exchange SDK updates the existing bids/offers with new prices to optimize trades. The updated energy information is found in latest_grid_tree_flat.items() and the prices for each bid/offer depend on the market slot progression. All the commands are then executed. def post_bid_offer(self, rate_index=0): \"\"\"Post a bid or an offer to the exchange.\"\"\" for area_uuid, area_dict in self.latest_grid_tree_flat.items(): asset_info = area_dict.get(\"asset_info\") if not asset_info: continue # Consumption assets required_energy = asset_info.get(\"energy_requirement_kWh\") if required_energy: rate = self.asset_strategy[area_uuid][\"buy_rates\"][rate_index] self.add_to_batch_commands.bid_energy_rate( asset_uuid=area_uuid, rate=rate, energy=required_energy ) # Generation assets available_energy = asset_info.get(\"available_energy_kWh\") if available_energy: rate = self.asset_strategy[area_uuid][\"sell_rates\"][rate_index] self.add_to_batch_commands.offer_energy_rate( asset_uuid=area_uuid, rate=rate, energy=available_energy ) # Storage assets buy_energy = asset_info.get(\"energy_to_buy\") if buy_energy: buy_rate = self.asset_strategy[area_uuid][\"buy_rates\"][rate_index] self.add_to_batch_commands.bid_energy_rate( asset_uuid=area_uuid, rate=buy_rate, energy=buy_energy ) sell_energy = asset_info.get(\"energy_to_sell\") if sell_energy: sell_rate = self.asset_strategy[area_uuid][\"sell_rates\"][rate_index] self.add_to_batch_commands.offer_energy_rate( asset_uuid=area_uuid, rate=sell_rate, energy=sell_energy ) self.execute_batch_commands() The rest of the script functionality has been covered in the previous section . For simulations run in the backend, a similar script is available here .","title":"Implement trading strategies"},{"location":"asset-api-template-script/#introduce-trading-preferences-with-the-degrees-of-freedom","text":"With the Asset API, users also have the option to specify trading preferences for each asset, such as preferred trading partners, energy type, energy amount and rate. An example of such a script can be found here . These preferences are also known as requirements and attributes or \u201cdegrees of freedom\u201d, as explained here . Requirements are uploaded to the template script via a JSON file (an example can be found here ), which has the following structure: { \"Load 3 L17\":[ { \"Trading Partners\": [\"PV 9 (15kW)\"], \"Energy Types\": [], \"Energy\": \"None\", \"Rate\": \"None\" } ], \"Load 2 L21\":[ { \"Trading Partners\": [\"PV 5 (10kW)\"], \"Energy Types\": [], \"Energy\": 10, \"Rate\": 3 } ], \"Load 1 L13\":[ { \"Trading Partners\": [], \"Energy Types\": [], \"Energy\": \"None\", \"Rate\": \"None\" } ] } In this example it is shown how, for each load, the four above mentioned requirements are listed and specified in value. It is also possible not to set any specific requirement to an asset, as for Load 1 L13. If, for example, \u201cEnergy\u201d and \u201cRate\u201d are set to None, the default energy and rate values from the template trading strategies are assigned. At each market slot , the Asset API loads and reads the information contained in this JSON file with the following function: def read_requirements(self): \"\"\"Load the JSON file containing the list of requirements for each asset.\"\"\" with open( os.path.join(module_dir, \"resources/requirements.json\"), \"r\", encoding=\"utf-8\", ) as file: self.degrees_of_freedom = json.load(file) Subsequently, a bid with the associated requirements is posted to the Exchange (for more on how to post bids and offers please see here .) The requirements uploaded through the JSON file must be converted to the correct format ahead of submission to the Exchange. To do so, the build_requirements_dict function is used: def build_requirements_dict(self, rate, energy, area_name): \"\"\"Return a dictionary with the requirements of the asset.\"\"\" asset_dof_list = self.degrees_of_freedom[area_name] for asset_dof in asset_dof_list: id_trading_partners_list = get_partner_ids(asset_dof[\"Trading Partners\"]) energy_types_list = asset_dof[\"Energy Types\"] energy_requirement = ( energy if asset_dof[\"Energy\"] == \"None\" else min(asset_dof[\"Energy\"], energy) ) rate_requirement = ( rate if asset_dof[\"Rate\"] == \"None\" else asset_dof[\"Rate\"] ) requirements = [ { \"trading_partners\": id_trading_partners_list, \"energy_type\": energy_types_list, \"energy\": energy_requirement, \"price\": rate_requirement * energy_requirement, } ] return requirements The rest of the script functionality has been covered in the previous section . It is important to note that currently there is no available template script for introducing degrees of freedom from the UI, but solely from the backend .","title":"Introduce trading preferences with the Degrees of Freedom"},{"location":"asset-api-template-script/#send-live-data-to-a-canary-test-network","text":"As noted here , the Asset API has the functionality to send live data to Grid Singularity Canary Test Network . A template script can be found here . To do so, at each market slot , forecast for the next 15 minutes are sent through the following function: def send_forecasts(self, market_info): \"\"\"Send forecasts of the next market slot to the exchange.\"\"\" forecast_market_slot = ( from_format(market_info[\"market_slot\"], DATE_TIME_FORMAT) .add(minutes=15) .format(DATE_TIME_FORMAT) ) # pylint: disable=unused-variable for area_uuid, area_dict in self.latest_grid_tree_flat.items(): asset_info = area_dict.get(\"asset_info\") if not asset_info: continue # Consumption assets if \"energy_requirement_kWh\" in asset_info: asset_name = area_dict[\"area_name\"] globals()[f\"{asset_name}\"].set_energy_forecast( energy_forecast_kWh={forecast_market_slot: 1.2}, do_not_wait=False, ) # Generation assets if \"available_energy_kWh\" in asset_info: asset_name = area_dict[\"area_name\"] globals()[f\"{asset_name}\"].set_energy_forecast( energy_forecast_kWh={forecast_market_slot: 0.86}, do_not_wait=False, ) self.execute_batch_commands() The forecast_market_slot , namely the marker slot at which the forecasted value is sent, is first retrieved by the market_info dictionary. Then, the set_energy_forecast function is used to send consumption / generation forecasted values to the Grid Singularity Exchange. In this example, 1.2 kWh are sent as consumption forecasts and 0.86 kWh are sent as generation forecasts. The rest of the script functionality has been covered in the previous section .","title":"Send live data to a Canary Test Network"},{"location":"asset-api-template-script/#post-energy-deviations-in-the-settlement-market","text":"Finally, the Asset API can also be used to post energy deviations between forecasts (namely the values of consumption or generation that an asset was expected to consume or produce) and measurements (namely the actual consumption or generation values) in the Settlement Market . A template script can be found here . As noted in the previous section, users can send forecasts (generated by assets or other data source) to the Grid Singularity Exchange by using the Asset API. To settle energy deviations in the Settlement Market, further action is needed, which is to send measurements to the Exchange at each market slot by using the following function: def send_measurements(self, market_info): \"\"\"Send measurements for the current market slot to the exchange.\"\"\" # pylint: disable=unused-variable for area_uuid, area_dict in self.latest_grid_tree_flat.items(): if \"asset_info\" not in area_dict or area_dict[\"asset_info\"] is None: continue # Consumption assets if \"energy_requirement_kWh\" in area_dict[\"asset_info\"]: self.add_to_batch_commands.set_energy_measurement( asset_uuid=area_uuid, energy_measurement_kWh={market_info[\"market_slot\"]: 1.23}, ) # Generation assets if \"available_energy_kWh\" in area_dict[\"asset_info\"]: self.add_to_batch_commands.set_energy_measurement( asset_uuid=area_uuid, energy_measurement_kWh={market_info[\"market_slot\"]: 0.87}, ) As shown in the snippet above, set_energy_measurement is used to send values to the Exchange which, in this example, are sent to the current market slot. Later, in settle_energy_deviation , the Asset API computes the difference between the forecast and measured values, called in the script unsettled_deviation . Depending on whether this value is positive or negative, a bid or an offer will be posted in the Settlement Market. The rate, as well as the time slot for order placement can be arbitrarily set by the user. Below is the snippet of the described function: def settle_energy_deviations(self): \"\"\"Post the energy deviations between forecasts and measurements in the Settlement market.\"\"\" for area_uuid, area_dict in self.latest_grid_tree_flat.items(): if not area_dict.get(\"asset_info\"): continue time_slot = ( list(area_dict[\"asset_info\"][\"unsettled_deviation_kWh\"].keys())[-1]) unsettled_deviation = area_dict[\"asset_info\"][ \"unsettled_deviation_kWh\" ].get(time_slot) if unsettled_deviation > 0: self.add_to_batch_commands.bid_energy_rate( asset_uuid=area_uuid, rate=5, energy=unsettled_deviation, time_slot=time_slot, ) if unsettled_deviation < 0: self.add_to_batch_commands.offer_energy_rate( asset_uuid=area_uuid, rate=10, energy=abs(unsettled_deviation), time_slot=time_slot, ) The rest of the script functionality has been covered in the previous section . It is important to note that currently there is no available template script for interacting with the Settlement Market from the UI, but solely from the backend . The next step is to adapt the Asset API template scripts developed by Grid Singularity to customize your trading strategies, whether to send live data to the Grid Singularity Canary Test Network or to interact with the Settlement Market .","title":"Post energy deviations in the Settlement Market"},{"location":"assets-installation/","text":"Solar Panels \u00b6 There are two options to implement a PV in a backend: Solar Profile (for template generation profile): Market( \"H2 PV\", strategy=PVStrategy( panel_count=4, initial_selling_rate=30, final_selling_rate=5, fit_to_limit=True, update_interval=duration(minutes=5))) User Profile (for uploaded generation profile): user_profile_path = os.path.join(gsy_e_path, \"assets/Solar_Curve_W_sunny.csv\") Market('H1 PV', strategy=PVUserProfileStrategy(power_profile=user_profile_path, panel_count=4)) Consumption \u00b6 To implement the consumption profile (load) in a backend simulation, two options are available: User configure Profile : Market( 'Load', strategy=LoadHoursStrategy( avg_power_W=200, hrs_per_day=6,hrs_of_day=list(range(12, 18)), initial_buying_rate=0, final_buying_rate=35)) User upload Profile : user_profile_path = os.path.join(gsy_e_path,\"assets/load.csv\") Market('Load', strategy=LoadProfileStrategy(daily_load_profile=user_profile_path, initial_buying_rate) Addendum: hrs_of_day and hrs_per_day \u00b6 hrs_of_day defines the allowed time-window in which the load has to consume for a time defined by hrs_per_day . For example, a user can input 5 hrs_per_day and give a wider range for hrs_of_day like (2,18). The Load will try to consume as fast as possible during this time if there is any offered energy to purchase within the limits of initial_buying_rate and final_buying_rate set parameters. - If there is sufficient energy at affordable rates, the load will consume in the first 5 hours, i.e. from 02:00 until 07:00, with no energy demand unmatched. - In case energy prices are too high during the time-interval from 04:00 to 16:00, the load will consume from 02:00 until 04:00, turn off, and consume from 16:00 until 18:00, resulting in one hour of energy demand unmatched. For information on changes in buying and selling rates, please see: Trading strategies Batteries \u00b6 To implement a battery in a backend simulation one option is available: Energy Storage System Market( 'Storage', strategy=StorageStrategy( initial_soc=50, energy_rate_decrease_per_update=3, battery_capacity_kWh=1.2, max_abs_battery_power_kW=5, final_buying_rate=16.99, final_selling_rate= 17.01)) Power Plant \u00b6 To implement the power plant in a backend simulation one option is available: Finite Power Plant profile_kW = { 0: 0.1, 8: 0.15, 12: 0.2, 19: 0.15, 22: 0.1 } Market( \"Power Plant\", strategy=FinitePowerPlant(energy_rate=31.3, max_available_power_kW=profile_kW)) Market Maker \u00b6 To implement a market maker in a backend simulation, two methods are available : Infinite power plant Market('Market Maker', strategy=MarketMakerStrategy(energy_rate=selling_rate, grid_connected=True)) Infinite bus Market('Market Maker', strategy=InfiniteBusStrategy(energy_buy_rate=22, energy_sell_rate=22)) Addendum: Storage Capacity Based Method. \u00b6 This method was created to sell energy at lower prices during high state of charge - SOC (when the battery has more energy stored) and at higher prices during low SOC (when the battery can afford to sell its stored energy for less). If the cap_price_strategy is True, the offer price for the storage is calculated according to: offer_rate = initial_selling_rate - ((initial_selling_rate - final_selling_rate)\\*soc/100) As an example, considering an initial_selling_rate of 30 cents/kWh and a final_selling_rate of 20 cents/kWh, a storage with an SOC of 1% would sell its energy at 29.9 cents/kWh, and a battery at 100% SOC would sell its energy at 20 cents/kWh. To implement a power plant in a backend simulation, one option is available: Finite Power Plant profile_kW = { 0: 0.1, 8: 0.15, 12: 0.2, 19: 0.15, 22: 0.1 } Market(\"Power Plant\", strategy=FinitePowerPlant(energy_rate=31.3, max_available_power_kW=profile_kW)) Heat pumps \u00b6 Heat Pump Code Configuration \u00b6 To configure a heat pump asset (HP) in the backend code, the following lines are to be added to the children's list of one of the areas in the setup file: Asset(name=\"Heat Pump\", strategy=HeatPumpStrategy()) The HeatPumpStrategy parameters can be set as follows: maximum_power_rating_kW : default=3; the maximal power that the HP will consume min_temp_C : (default=50); minimum temperature of the HP storage. If the temperature drops below this point, the HP buys energy at any cost max_temp_C : (default=60); maximum temperature of the HP storage. If the temperature rises above this point, the HP does not buy any energy. initial_temp_C : (default=50); initial temperature of the HP storage external_temp_C_profile : (mandatory user input); external temperature that influences the efficiency of the HP. If this parameter is selected, the external temperature is constant for the whole simulation run tank_volume_l : (default=15); rate in ct/kWh that determines the trading strategy consumption_kWh : (mandatory user input); constant power value in kWh or provided power profile as a dictionary that follows the supported format, representing the power that the HP consumes when operating. preferred_buying_rate : (mandatory user input); constant power value in kWh or provided power profile as a dictionary that follows the supported format, representing the power that the HP consumes when operating. source_type : set how the heat exchange is conducted, either via air or water/ground, as it determines the COP calculation; order_updater_parameters : of type HeatPumpOrderUpdaterParameters . A template configuration can be seen below . Virtual Heat Pump Code Configuration \u00b6 To configure a virtual heat pump asset (VHP) in the backend code, the following lines are to be added to the children's list of one of the areas in the setup file: Asset(name=\"Virtual Heat Pump\", strategy=VirtualHeatPumpStrategy()) The VirtualHeatPumpStrategy parameters can be set as follows: maximum_power_rating_kW : default=3; the maximal power that the VHP will consume min_temp_C : (default=50); minimum temperature of the VHP storage. If the temperature drops below this point, the HP buys energy at any cost max_temp_C : (default=60); maximum temperature of the VHP storage. If the temperature rises above this point, the HP does not buy any energy. initial_temp_C : (default=50); initial temperature of the VHP storage water_supply_temp_C_profile : (mandatory user input); supply temperature of the water that flows from the district heating network. Used to calculate the heat demand of the building water_return_temp_C_profile : (mandatory user input); return temperature of the water that flows from the district heating network. Used to calculate the heat demand of the building dh_water_flow_m3_profile : (mandatory user input); water flow from the district heating network. In aggregated cubic metres per market slot. Used to calculate the heat demand of the building tank_volume_l : (default=50); volume of the storage tank preferred_buying_rate : (default=15); rate in ct/kWh that determines the trading strategy order_updater_parameters : of type HeatPumpOrderUpdaterParameters . A template configuration can be seen below . Heat Pump Price Strategy Configuration \u00b6 In order to set the bidding strategy, the order_updater_parameters should be set by assigning the HeatPumpOrderUpdaterParameters data class and its parameters to it: from gsy_e.models.strategy.heat_pump import HeatPumpOrderUpdaterParameters from pendulum import duration from gsy_framework.enums import AvailableMarketTypes Asset(name=\"Heat Pump\", strategy=HeatPumpStrategy( order_updater_parameters={ AvailableMarketTypes.SPOT: HeatPumpOrderUpdaterParameters( update_interval=duration(minutes=1), initial_rate=20, final_rate=30)}) )) The order_updater_parameters expects a dictionary with AvailableMarketTypes as key and HeatPumpOrderUpdaterParameters as values. If not set by the user, the following default values are used: update_interval : interval that represents the time between updates of the bid prices performed by the applied trading strategy (default: 1 minute); initial_rate : bid rate at the start of the market slot; default value is the feed-in-tariff rate (if not set, the default value is 0 ct/kWh as explained in table here ); final_rate : bid rate at the end of the market slot; defined by the infinite bus strategy that is part of the simulation, which is the market maker rate (if not set, the default value is 30ct/kWh).","title":"Assets Installation"},{"location":"assets-installation/#solar-panels","text":"There are two options to implement a PV in a backend: Solar Profile (for template generation profile): Market( \"H2 PV\", strategy=PVStrategy( panel_count=4, initial_selling_rate=30, final_selling_rate=5, fit_to_limit=True, update_interval=duration(minutes=5))) User Profile (for uploaded generation profile): user_profile_path = os.path.join(gsy_e_path, \"assets/Solar_Curve_W_sunny.csv\") Market('H1 PV', strategy=PVUserProfileStrategy(power_profile=user_profile_path, panel_count=4))","title":"Solar Panels"},{"location":"assets-installation/#consumption","text":"To implement the consumption profile (load) in a backend simulation, two options are available: User configure Profile : Market( 'Load', strategy=LoadHoursStrategy( avg_power_W=200, hrs_per_day=6,hrs_of_day=list(range(12, 18)), initial_buying_rate=0, final_buying_rate=35)) User upload Profile : user_profile_path = os.path.join(gsy_e_path,\"assets/load.csv\") Market('Load', strategy=LoadProfileStrategy(daily_load_profile=user_profile_path, initial_buying_rate)","title":"Consumption"},{"location":"assets-installation/#addendum-hrs_of_day-and-hrs_per_day","text":"hrs_of_day defines the allowed time-window in which the load has to consume for a time defined by hrs_per_day . For example, a user can input 5 hrs_per_day and give a wider range for hrs_of_day like (2,18). The Load will try to consume as fast as possible during this time if there is any offered energy to purchase within the limits of initial_buying_rate and final_buying_rate set parameters. - If there is sufficient energy at affordable rates, the load will consume in the first 5 hours, i.e. from 02:00 until 07:00, with no energy demand unmatched. - In case energy prices are too high during the time-interval from 04:00 to 16:00, the load will consume from 02:00 until 04:00, turn off, and consume from 16:00 until 18:00, resulting in one hour of energy demand unmatched. For information on changes in buying and selling rates, please see: Trading strategies","title":"Addendum: hrs_of_day and hrs_per_day"},{"location":"assets-installation/#batteries","text":"To implement a battery in a backend simulation one option is available: Energy Storage System Market( 'Storage', strategy=StorageStrategy( initial_soc=50, energy_rate_decrease_per_update=3, battery_capacity_kWh=1.2, max_abs_battery_power_kW=5, final_buying_rate=16.99, final_selling_rate= 17.01))","title":"Batteries"},{"location":"assets-installation/#power-plant","text":"To implement the power plant in a backend simulation one option is available: Finite Power Plant profile_kW = { 0: 0.1, 8: 0.15, 12: 0.2, 19: 0.15, 22: 0.1 } Market( \"Power Plant\", strategy=FinitePowerPlant(energy_rate=31.3, max_available_power_kW=profile_kW))","title":"Power Plant"},{"location":"assets-installation/#market-maker","text":"To implement a market maker in a backend simulation, two methods are available : Infinite power plant Market('Market Maker', strategy=MarketMakerStrategy(energy_rate=selling_rate, grid_connected=True)) Infinite bus Market('Market Maker', strategy=InfiniteBusStrategy(energy_buy_rate=22, energy_sell_rate=22))","title":"Market Maker"},{"location":"assets-installation/#addendum-storage-capacity-based-method","text":"This method was created to sell energy at lower prices during high state of charge - SOC (when the battery has more energy stored) and at higher prices during low SOC (when the battery can afford to sell its stored energy for less). If the cap_price_strategy is True, the offer price for the storage is calculated according to: offer_rate = initial_selling_rate - ((initial_selling_rate - final_selling_rate)\\*soc/100) As an example, considering an initial_selling_rate of 30 cents/kWh and a final_selling_rate of 20 cents/kWh, a storage with an SOC of 1% would sell its energy at 29.9 cents/kWh, and a battery at 100% SOC would sell its energy at 20 cents/kWh. To implement a power plant in a backend simulation, one option is available: Finite Power Plant profile_kW = { 0: 0.1, 8: 0.15, 12: 0.2, 19: 0.15, 22: 0.1 } Market(\"Power Plant\", strategy=FinitePowerPlant(energy_rate=31.3, max_available_power_kW=profile_kW))","title":"Addendum: Storage Capacity Based Method."},{"location":"assets-installation/#heat-pumps","text":"","title":"Heat pumps"},{"location":"assets-installation/#heat-pump-code-configuration","text":"To configure a heat pump asset (HP) in the backend code, the following lines are to be added to the children's list of one of the areas in the setup file: Asset(name=\"Heat Pump\", strategy=HeatPumpStrategy()) The HeatPumpStrategy parameters can be set as follows: maximum_power_rating_kW : default=3; the maximal power that the HP will consume min_temp_C : (default=50); minimum temperature of the HP storage. If the temperature drops below this point, the HP buys energy at any cost max_temp_C : (default=60); maximum temperature of the HP storage. If the temperature rises above this point, the HP does not buy any energy. initial_temp_C : (default=50); initial temperature of the HP storage external_temp_C_profile : (mandatory user input); external temperature that influences the efficiency of the HP. If this parameter is selected, the external temperature is constant for the whole simulation run tank_volume_l : (default=15); rate in ct/kWh that determines the trading strategy consumption_kWh : (mandatory user input); constant power value in kWh or provided power profile as a dictionary that follows the supported format, representing the power that the HP consumes when operating. preferred_buying_rate : (mandatory user input); constant power value in kWh or provided power profile as a dictionary that follows the supported format, representing the power that the HP consumes when operating. source_type : set how the heat exchange is conducted, either via air or water/ground, as it determines the COP calculation; order_updater_parameters : of type HeatPumpOrderUpdaterParameters . A template configuration can be seen below .","title":"Heat Pump Code Configuration"},{"location":"assets-installation/#virtual-heat-pump-code-configuration","text":"To configure a virtual heat pump asset (VHP) in the backend code, the following lines are to be added to the children's list of one of the areas in the setup file: Asset(name=\"Virtual Heat Pump\", strategy=VirtualHeatPumpStrategy()) The VirtualHeatPumpStrategy parameters can be set as follows: maximum_power_rating_kW : default=3; the maximal power that the VHP will consume min_temp_C : (default=50); minimum temperature of the VHP storage. If the temperature drops below this point, the HP buys energy at any cost max_temp_C : (default=60); maximum temperature of the VHP storage. If the temperature rises above this point, the HP does not buy any energy. initial_temp_C : (default=50); initial temperature of the VHP storage water_supply_temp_C_profile : (mandatory user input); supply temperature of the water that flows from the district heating network. Used to calculate the heat demand of the building water_return_temp_C_profile : (mandatory user input); return temperature of the water that flows from the district heating network. Used to calculate the heat demand of the building dh_water_flow_m3_profile : (mandatory user input); water flow from the district heating network. In aggregated cubic metres per market slot. Used to calculate the heat demand of the building tank_volume_l : (default=50); volume of the storage tank preferred_buying_rate : (default=15); rate in ct/kWh that determines the trading strategy order_updater_parameters : of type HeatPumpOrderUpdaterParameters . A template configuration can be seen below .","title":"Virtual Heat Pump Code Configuration"},{"location":"assets-installation/#heat-pump-price-strategy-configuration","text":"In order to set the bidding strategy, the order_updater_parameters should be set by assigning the HeatPumpOrderUpdaterParameters data class and its parameters to it: from gsy_e.models.strategy.heat_pump import HeatPumpOrderUpdaterParameters from pendulum import duration from gsy_framework.enums import AvailableMarketTypes Asset(name=\"Heat Pump\", strategy=HeatPumpStrategy( order_updater_parameters={ AvailableMarketTypes.SPOT: HeatPumpOrderUpdaterParameters( update_interval=duration(minutes=1), initial_rate=20, final_rate=30)}) )) The order_updater_parameters expects a dictionary with AvailableMarketTypes as key and HeatPumpOrderUpdaterParameters as values. If not set by the user, the following default values are used: update_interval : interval that represents the time between updates of the bid prices performed by the applied trading strategy (default: 1 minute); initial_rate : bid rate at the start of the market slot; default value is the feed-in-tariff rate (if not set, the default value is 0 ct/kWh as explained in table here ); final_rate : bid rate at the end of the market slot; defined by the infinite bus strategy that is part of the simulation, which is the market maker rate (if not set, the default value is 30ct/kWh).","title":"Heat Pump Price Strategy Configuration"},{"location":"assets-strategies/","text":"Prosumer assets can post orders ( bids/offers ) of their energy deviations to the settlement market in order to get compensated by another entity that deviated in the opposite direction. Energy deviations are calculated from the difference between the traded energy and measured energy for production or consumption. External asset strategies \u00b6 Energy Measurement and Forecasts \u00b6 Aggregator users can post the forecasted and measured energy to the Grid Singularity exchange for each market slot via the Asset API with the batch commands set_energy_forecast and set_energy_measurement . To enable these batch commands the asset must have either PVForecastExternalStrategy or LoadForecastExternalStrategy set as a strategy in the Grid Singularity Exchange setup file. Measurements should be set in the current market cycle for the unsettled deviation to be calculated. Figure 4.10 : Settlement market posting energy deviations mechanism with external asset strategies. Posting of Orders \u00b6 Posting and updating bids and offers works the same as in the spot markets . If the provided time_slot is a settlement market already, the order is placed or updated in the settlement market. The external client can only post maximally the amount of energy of the deviation to the settlement market. Unsettled Deviation \u00b6 To find out the amount of deviated energy, a key named unsettled_deviation_kWh is added on the assets_info dictionary. Its value is itself a dictionary with past time slots as keys and the unsettled energy as values. An example is shown below: { 'unsettled_deviation_kWh': {'2022-01-14T00:00': -8.3, '2022-01-14T01:00': -10.5}, 'available_energy_kWh': 10, 'energy_active_in_offers': 0, 'energy_traded': 0, 'total_cost': 0 } There will appear as many time slots as they fit in the amount of hours specified on ConstSettings.SettlementMarketSettings.ENABLE_SETTLEMENT_MARKETS . The value in each time slot is the maximal amount of energy that can be posted (please also see Settlement Market Rotation ). The sign of the unsettled energy can vary depending on wether more energy was traded than measured or vice versa. If a PV asset has a negative deviation, it implies that more energy was produced/measured than traded, and it is possible to offer it in the settlement market. To have a positive deviation would imply that more energy was traded than it was produced, and the asset now has to make up for it by posting bids. If a Load asset has a negative deviation, it implies that more energy was initially bid (and traded) than the one that was actually used, and can then be offered on the settlement market. To have a positive deviation would imply that more energy was consumed than it was traded, and the asset now has to make up for it by posting bids. In conclusion, regardless of wether the asset is a PV or a Load, if the unsettled deviation is negative, the energy should be offered, and if positive, bid. Example settlement market strategy: if self._can_place_in_settlement_market(asset_info): for market_slot, energy in asset_info[\"unsettled_deviation_kWh\"].items(): if energy and energy > 0: self.add_to_batch_commands.bid_energy(asset_uuid=area_uuid, energy=energy, price=30, time_slot=market_slot) elif energy and energy < 0: self.add_to_batch_commands.offer_energy(asset_uuid=area_uuid, energy=-energy, price=1, time_slot=market_slot) where the method self._can_place_in_settlement_market() is defined as follows: def _can_place_in_settlement_market(asset_info): return \"unsettled_deviation_kWh\" in asset_info and ( asset_info[\"unsettled_deviation_kWh\"] != 0) Template asset strategies \u00b6 Energy Measurement and Forecasts \u00b6 For the template strategies, the forecasted energy is provided by the user, either by uploading a profile or setting up a predefined PV or Load. The forecasted energy is used to post bids or offers to the spot markets. The actual measured energy is calculated by a random deviation of the forecasted value. A gaussian random error is simulated (positive and negative deviances around the forecasted energy value possible). The intensity of this random deviation can be controlled by the following setting that represents the relative standard deviation, so the width of the random deviation around the energy forecast: ConstSettings.SettlementMarketSettings.RELATIVE_STD_FROM_FORECAST_FLOAT . Figure 4.11 : Settlement market posting energy deviations mechanism with template asset strategies. Posting of Orders \u00b6 The template strategies will post orders (bids / offers) with energy values equal to the energy deviations for each market. For example, if a PV forecasted to produce 5kWh of energy for the 12:00 market, but the simulated measured energy reveals that it only produced 4kWh for that time slot, the template strategy will post a bid to the 12:00 settlement market with the energy 1kWh. The behavior for the price increase of this bid is the same as in the spot market: the energy rate of the bid is increased during the market until the final selling rate is reached. As the settlement market will stay available for longer than the normal spot market (configurable by Const.Settings.SettlementMarketSettings.MAX_AGE_SETTLEMENT_MARKET_HOURS , please also see here ), the template strategy will not update the orders as frequent as in the normal spot market, but in the interval that can be set by the parameter SettlementTemplateStrategiesConstants.UPDATE_INTERVAL_MIN .","title":"Assets strategies"},{"location":"assets-strategies/#external-asset-strategies","text":"","title":"External asset strategies"},{"location":"assets-strategies/#energy-measurement-and-forecasts","text":"Aggregator users can post the forecasted and measured energy to the Grid Singularity exchange for each market slot via the Asset API with the batch commands set_energy_forecast and set_energy_measurement . To enable these batch commands the asset must have either PVForecastExternalStrategy or LoadForecastExternalStrategy set as a strategy in the Grid Singularity Exchange setup file. Measurements should be set in the current market cycle for the unsettled deviation to be calculated. Figure 4.10 : Settlement market posting energy deviations mechanism with external asset strategies.","title":"Energy Measurement and Forecasts"},{"location":"assets-strategies/#posting-of-orders","text":"Posting and updating bids and offers works the same as in the spot markets . If the provided time_slot is a settlement market already, the order is placed or updated in the settlement market. The external client can only post maximally the amount of energy of the deviation to the settlement market.","title":"Posting of Orders"},{"location":"assets-strategies/#unsettled-deviation","text":"To find out the amount of deviated energy, a key named unsettled_deviation_kWh is added on the assets_info dictionary. Its value is itself a dictionary with past time slots as keys and the unsettled energy as values. An example is shown below: { 'unsettled_deviation_kWh': {'2022-01-14T00:00': -8.3, '2022-01-14T01:00': -10.5}, 'available_energy_kWh': 10, 'energy_active_in_offers': 0, 'energy_traded': 0, 'total_cost': 0 } There will appear as many time slots as they fit in the amount of hours specified on ConstSettings.SettlementMarketSettings.ENABLE_SETTLEMENT_MARKETS . The value in each time slot is the maximal amount of energy that can be posted (please also see Settlement Market Rotation ). The sign of the unsettled energy can vary depending on wether more energy was traded than measured or vice versa. If a PV asset has a negative deviation, it implies that more energy was produced/measured than traded, and it is possible to offer it in the settlement market. To have a positive deviation would imply that more energy was traded than it was produced, and the asset now has to make up for it by posting bids. If a Load asset has a negative deviation, it implies that more energy was initially bid (and traded) than the one that was actually used, and can then be offered on the settlement market. To have a positive deviation would imply that more energy was consumed than it was traded, and the asset now has to make up for it by posting bids. In conclusion, regardless of wether the asset is a PV or a Load, if the unsettled deviation is negative, the energy should be offered, and if positive, bid. Example settlement market strategy: if self._can_place_in_settlement_market(asset_info): for market_slot, energy in asset_info[\"unsettled_deviation_kWh\"].items(): if energy and energy > 0: self.add_to_batch_commands.bid_energy(asset_uuid=area_uuid, energy=energy, price=30, time_slot=market_slot) elif energy and energy < 0: self.add_to_batch_commands.offer_energy(asset_uuid=area_uuid, energy=-energy, price=1, time_slot=market_slot) where the method self._can_place_in_settlement_market() is defined as follows: def _can_place_in_settlement_market(asset_info): return \"unsettled_deviation_kWh\" in asset_info and ( asset_info[\"unsettled_deviation_kWh\"] != 0)","title":"Unsettled Deviation"},{"location":"assets-strategies/#template-asset-strategies","text":"","title":"Template asset strategies"},{"location":"assets-strategies/#energy-measurement-and-forecasts_1","text":"For the template strategies, the forecasted energy is provided by the user, either by uploading a profile or setting up a predefined PV or Load. The forecasted energy is used to post bids or offers to the spot markets. The actual measured energy is calculated by a random deviation of the forecasted value. A gaussian random error is simulated (positive and negative deviances around the forecasted energy value possible). The intensity of this random deviation can be controlled by the following setting that represents the relative standard deviation, so the width of the random deviation around the energy forecast: ConstSettings.SettlementMarketSettings.RELATIVE_STD_FROM_FORECAST_FLOAT . Figure 4.11 : Settlement market posting energy deviations mechanism with template asset strategies.","title":"Energy Measurement and Forecasts"},{"location":"assets-strategies/#posting-of-orders_1","text":"The template strategies will post orders (bids / offers) with energy values equal to the energy deviations for each market. For example, if a PV forecasted to produce 5kWh of energy for the 12:00 market, but the simulated measured energy reveals that it only produced 4kWh for that time slot, the template strategy will post a bid to the 12:00 settlement market with the energy 1kWh. The behavior for the price increase of this bid is the same as in the spot market: the energy rate of the bid is increased during the market until the final selling rate is reached. As the settlement market will stay available for longer than the normal spot market (configurable by Const.Settings.SettlementMarketSettings.MAX_AGE_SETTLEMENT_MARKET_HOURS , please also see here ), the template strategy will not update the orders as frequent as in the normal spot market, but in the interval that can be set by the parameter SettlementTemplateStrategiesConstants.UPDATE_INTERVAL_MIN .","title":"Posting of Orders"},{"location":"backend-results-energy-bills/","text":"The cumulative energy bills for each market and energy asset are reported on the UI Results page and in a JSON file bills.json for a backend simulation. The bills are reported as the cash flow through each market. Figure 2.18 : Example grid setup showing connection to the grid. This configuration is simulated for one day using the Pay-as-Bid market type and the load bidding to buy energy at 12:00, leading to the propagation of the load bid and the grid operator offer until they are matched as shown in the figure below: Figure 2.19 : Example grid setup showing connection to the grid. The bid and the offer are forwarded to the higher-level Grid market and are matched in this market with a clearing price (and trade price) of \u20ac0.45. For more information on how grid fees are calculated, please read the grid fees documentation . In the bills.json file, the cash flow in each market is reported as follows: \"Parent market\": { \"Agent\": { \"bought\": Energy that has been bought during the simulation [kWh], \"sold\": Energy that has been sold during the simulation [kWh], \"spent\": Amount of money that has been spent in trades during the simulation [\u20ac] , \"earned\": Amount of money that has been earned in trades during the simulation [\u20ac], \"total_energy\": energy bought - energy sold [kWh], \"total_cost\": money spent in trades - money earned in trades [\u20ac], \"market_fee\": Money spent in the \"Parent area\" as grid fees [\u20ac] , \"type\": Type of agent. Can either be a market or the name of the asset strategy }, }, Shown below are the results of the previous example. The first set of results is from the highest market, in this case the Grid market: Figure 2.20 : Example of bills results in the Grid level. In the Grid market, House 1 has bought 1 kWh from the Gris and spent \u20ac0.375 for this trade. House 1 also pays the \u20ac0.075 grid fee that the Grid market is charging. The total cost of 1 kWh of energy is \u20ac0.375 + \u20ac0.075 = \u20ac0.45 One level down the hierarchy, the House 1 market is displayed in the figure below: The House 1 market has no information on the other markets\u2019 grid fees, so only considers its own fees in the bills table. Therefore, the Load spends \u20ac0.45 (\u20ac0.0375 + \u20ac0.075) for 1 kWh of energy that is externally supplied to House 1, with no grid fee added since House 1 has no fees. Figure 2.21 : Example of bills results in the House 1 level. Finally, the bills of each energy asset are shown: Figure 2.22 : Example of bills for all assets in the configuration.","title":"Energy bills"},{"location":"backend-results-overview/","text":"After running a simulation in the backend, the user can export simulation results. This functionality is enabled by default. If you want to disable the export of simulation results, use the --no-export flag for the simulation run. Another useful parameter is: --export-path , used to change the output path of the simulation results. The default path is $HOME/gsy-e-simulation/ . The simulation results include analytical information about the bids, offers and trades that took place in the course of the simulation. Information about energy characteristics of each asset and market are also included (eg. battery state of charge, energy traded/requested/deficit). A detailed description of these files is available on the result download page . In addition to text files, some graphs that display aggregated market information during the course of the simulation are also exposed. These can be found under the plot/ directory and are very similar to the ones available in the UI: energy_profile_*.html : Similar plot to energy trade profile average_trade_price_*.html : Similar plot to energy pricing asset_profile_*.html : each energy asset within the simulation has its own plot showing its profile (consumption, generation, State of Charge), the actual energy traded and energy rates.","title":"Backend Results Overview"},{"location":"backend-solar-panels/","text":"","title":"Backend solar panels"},{"location":"backend_events/","text":"Scheduled Events \u00b6 Events need to be defined by the user in the setup files before the start of the simulation, and they are associated with a specific point in time (or duration), at which the event is triggered. An event has to be associated with a market or an asset by using the event_list constructor parameter for that Market or Asset class. There are four different event types, described in further detail below: Add/Remove Market Events Connect/Disconnect Market Events Strategy Events Add/Remove Market Events \u00b6 This event is associated with a market, and dictates that this market (and its submarkets and assets) will be added or removed from the grid at a specific point in time. There are two ways to configure this operation, either via individual events ( EnableMarketEvent and DisableMarketEvent ) or by disabling this market for a selected time interval ( DisableIntervalMarketEvent ). EnableMarketEvent / DisableMarketEvent commands each accept one argument, which is the hour at which this event is triggered (hourly resolution is supported in the current implementation), and this area will be enabled/disabled at this specific point in time no matter its current state. DisableIntervalMarketEvent accepts two arguments, denoting the start hour and the end hour at which the Market is disabled. The term disabled market means that the relevant markets and submarkets are not performing any trading, and are hence inactive in the simulation for the time that the market is disabled. Once enabled, the relevant market and its submarkets will start to operate. Examples for these events are available on the Grid Singularity GitHub: EnableMarketEvent: isolated_enable_event.py DisableMarketEvent: isolated_disable_event.py DisableIntervalMarketEvent: disable_interval_event.py Connect/Disconnect Market Events \u00b6 These events are similar to the enable/disable event; both have a similar API and both are used for removing a market from the grid. The difference is that the Connect/Disconnect events are decoupling the relevant submarkets and assets from the main grid. When the event is enabled, there will be two independent grids trading energy internally, but not with each other. This is contrary to enable/disable events, where the subtree is not performing any trades. This can simulate grids that are abruptly decoupled from the main grid, but manage to self-sustain their assets by continuing to trade energy even after they are disconnected from the main grid. You can find examples for these events on Grid Singularity GitHub: ConnectMarketEvent: isolated_connect_event.py DisconnectMarketEvent: isolated_disconnect_event.py DisconnectIntervalMarketEvent: disconnect_interval_event.py Strategy Events \u00b6 These events are used to change an asset\u2019s trading strategy during the simulation runtime. These are distinct events with no interval event provided. Load StrategyEvent: load_event.py PV StrategyEvent: pv_event.py Storage StrategyEvent: storage_event.py","title":"Configuring Events"},{"location":"backend_events/#scheduled-events","text":"Events need to be defined by the user in the setup files before the start of the simulation, and they are associated with a specific point in time (or duration), at which the event is triggered. An event has to be associated with a market or an asset by using the event_list constructor parameter for that Market or Asset class. There are four different event types, described in further detail below: Add/Remove Market Events Connect/Disconnect Market Events Strategy Events","title":"Scheduled Events"},{"location":"backend_events/#addremove-market-events","text":"This event is associated with a market, and dictates that this market (and its submarkets and assets) will be added or removed from the grid at a specific point in time. There are two ways to configure this operation, either via individual events ( EnableMarketEvent and DisableMarketEvent ) or by disabling this market for a selected time interval ( DisableIntervalMarketEvent ). EnableMarketEvent / DisableMarketEvent commands each accept one argument, which is the hour at which this event is triggered (hourly resolution is supported in the current implementation), and this area will be enabled/disabled at this specific point in time no matter its current state. DisableIntervalMarketEvent accepts two arguments, denoting the start hour and the end hour at which the Market is disabled. The term disabled market means that the relevant markets and submarkets are not performing any trading, and are hence inactive in the simulation for the time that the market is disabled. Once enabled, the relevant market and its submarkets will start to operate. Examples for these events are available on the Grid Singularity GitHub: EnableMarketEvent: isolated_enable_event.py DisableMarketEvent: isolated_disable_event.py DisableIntervalMarketEvent: disable_interval_event.py","title":"Add/Remove Market Events"},{"location":"backend_events/#connectdisconnect-market-events","text":"These events are similar to the enable/disable event; both have a similar API and both are used for removing a market from the grid. The difference is that the Connect/Disconnect events are decoupling the relevant submarkets and assets from the main grid. When the event is enabled, there will be two independent grids trading energy internally, but not with each other. This is contrary to enable/disable events, where the subtree is not performing any trades. This can simulate grids that are abruptly decoupled from the main grid, but manage to self-sustain their assets by continuing to trade energy even after they are disconnected from the main grid. You can find examples for these events on Grid Singularity GitHub: ConnectMarketEvent: isolated_connect_event.py DisconnectMarketEvent: isolated_disconnect_event.py DisconnectIntervalMarketEvent: disconnect_interval_event.py","title":"Connect/Disconnect Market Events"},{"location":"backend_events/#strategy-events","text":"These events are used to change an asset\u2019s trading strategy during the simulation runtime. These are distinct events with no interval event provided. Load StrategyEvent: load_event.py PV StrategyEvent: pv_event.py Storage StrategyEvent: storage_event.py","title":"Strategy Events"},{"location":"balancing-implementation/","text":"Figure 4.7 : Structure of Balancing Market in Grid Singularity exchange Grid Singularity energy exchange bottom-up market design allows participants to engage in Local Energy Market (LEM) for energy trading, providing energy balance at a local level. Grid Singularity Exchange flexibility trading also facilitates the procurement of flexibility locally from participants to assist distribution grid operation in balancing the grid. Assets \u00b6 In the Grid Singularity Exchange, balancing has been implemented using: Fast responding non-critical loads to provide load shedding Battery storage Commercial power plants The trading strategies of energy assets like Loads , Storages and Power Plants can be used to balance the grid by placing balancing offers. These assets participate in the balancing market only if they are registered in the Asset Registry . Asset Registry \u00b6 The balancing asset registry is a dictionary that contains the names of assets as keys and the balancing rates as tuple values: (demand balancing rate, supply balancing rate). asset_registry_dict = { \"H1 General Load\": (33, 35), \"H2 General Load\": (33, 35), \"H1 Storage1\": (33, 35), \"H1 Storage2\": (33, 35), } Balancing Market \u00b6 The present setting is a One-Sided Pay-as-Offer market , which accepts balancing_offers from energy assets and connected hierarchies of balancing_market . balancing_offers could be positive or negative. It also facilitates the balancing_trade . Balancing Agent \u00b6 The balancing agent follows the lead of the spot_market_trade of its lower hierarchy. Whenever there is a trade in the lower hierarchy of spot_market , it will try to secure a share of spot market trades in the balancing market. Constant Parameters \u00b6 The following are the constant parameters related to the balancing market, with defaults available here . ENABLE_BALANCING_MARKET \u2192 (Default: False) (It enables the simulation with Balancing Market) BALANCING_SPOT_TRADE_RATIO \u2192 (Default: 0.2) (It dictates the ratio of spot_market_energy to be traded in balancing market) BALANCING_OFFER_DEMAND_RATIO \u2192 (Default: 0.1) (It dictates the ratio of spot_market_energy to be offered in balancing market as demand_balancing_offer ) BALANCING_OFFER_SUPPLY_RATIO \u2192 (Default: 0.1) (It dictates the ratio of spot_market_energy to be offered in balancing market as supply_balancing_offer ) BALANCING_FLEXIBLE_LOADS_SUPPORT \u2192 (Default: True) (It enables Load Strategy to place supply_balancing_offer (effectively curtailing it's load)) Multiple examples of balancing market setup are available here .","title":"Balancing Market Implementation"},{"location":"balancing-implementation/#assets","text":"In the Grid Singularity Exchange, balancing has been implemented using: Fast responding non-critical loads to provide load shedding Battery storage Commercial power plants The trading strategies of energy assets like Loads , Storages and Power Plants can be used to balance the grid by placing balancing offers. These assets participate in the balancing market only if they are registered in the Asset Registry .","title":"Assets"},{"location":"balancing-implementation/#asset-registry","text":"The balancing asset registry is a dictionary that contains the names of assets as keys and the balancing rates as tuple values: (demand balancing rate, supply balancing rate). asset_registry_dict = { \"H1 General Load\": (33, 35), \"H2 General Load\": (33, 35), \"H1 Storage1\": (33, 35), \"H1 Storage2\": (33, 35), }","title":"Asset Registry"},{"location":"balancing-implementation/#balancing-market","text":"The present setting is a One-Sided Pay-as-Offer market , which accepts balancing_offers from energy assets and connected hierarchies of balancing_market . balancing_offers could be positive or negative. It also facilitates the balancing_trade .","title":"Balancing Market"},{"location":"balancing-implementation/#balancing-agent","text":"The balancing agent follows the lead of the spot_market_trade of its lower hierarchy. Whenever there is a trade in the lower hierarchy of spot_market , it will try to secure a share of spot market trades in the balancing market.","title":"Balancing Agent"},{"location":"balancing-implementation/#constant-parameters","text":"The following are the constant parameters related to the balancing market, with defaults available here . ENABLE_BALANCING_MARKET \u2192 (Default: False) (It enables the simulation with Balancing Market) BALANCING_SPOT_TRADE_RATIO \u2192 (Default: 0.2) (It dictates the ratio of spot_market_energy to be traded in balancing market) BALANCING_OFFER_DEMAND_RATIO \u2192 (Default: 0.1) (It dictates the ratio of spot_market_energy to be offered in balancing market as demand_balancing_offer ) BALANCING_OFFER_SUPPLY_RATIO \u2192 (Default: 0.1) (It dictates the ratio of spot_market_energy to be offered in balancing market as supply_balancing_offer ) BALANCING_FLEXIBLE_LOADS_SUPPORT \u2192 (Default: True) (It enables Load Strategy to place supply_balancing_offer (effectively curtailing it's load)) Multiple examples of balancing market setup are available here .","title":"Constant Parameters"},{"location":"balancing-market/","text":"Definition \u00b6 Electrical power systems are characterized by voltage and frequency and the flow of electricity is a continuous process. Buffering or storing electrical energy at each node is still not feasible, therefore electrical energy needs to be generated exactly at the time of consumption. Differences in supply and demand causes the nominal frequency (50Hz in EU) to deviate. Consequently, supply and demand need to be monitored in real time to implement adjustments to maintain equilibrium and nominal frequency. Significant deviation from the nominal leads to cascading effect culminating in a blackout . Transmission system operators (TSOs) oversee fast, flexible, fossil fuel-based generation units and demand response service from large consumers, ensuring the continuation of operation during significant transient faults in the energy system. These generators form the basis of frequency control strategies used in balancing these electrical systems. Each control strategy has specific purposes and features and can be categorized in three groups, as shown in the figure below. Primary Control (Frequency Containment Reserve - FCR) Secondary Control (Automatic Frequency Restoration Reserves - aFRR) Tertiary Control (Manual Frequency Restoration Reserves - mFRR) Figure 4.4 : The three tiers of grid control and its activation structure In conventional grid structures \u00b6 Primary control is an automatic function that is almost instantaneously activated to stabilise the frequency drops/spikes. It is the fastest type of frequency control with a response time of a few seconds and operates using a joint process involving all TSOs of the synchronous area. This is shown in the figure below. For example, if there is an increase in demand, the energy used to compensate for this demand comes from the kinetic energy stored in large rotating synchronous generators that start decreasing its velocity. This is referred to as Inertial response . For the generators to recover the speed, the speed controller of each generator acts to increase the generator power to clear the imbalance. Within a period of 30 seconds, each generating unit is able to generate the required power and stabilise this production for at least 15 minutes or depending on the requirements of the TSO within the synchronous region. Primary control is done using generation plants that are connected to the high voltage power supply with the exception of renewable energy sources which are non-schedulable due to its intermittent nature. Figure 4.5 : Recovery of the system from a contingency event and action by primary frequency control (PFR) Secondary control is performed automatically by all the generators to restore the nominal frequency, the power exchanges and reserve of the generators used in primary control. The generators involved in this regulation function through dedicated reserve power that are set in conjunction with central controllers. The reserve control power is negotiated in a contract conjunction with the TSO and is a percentage of the maximum available power with a predefined minimum value to ensure that it can be dispatched whenever needed. This service is remunerated according to the set contracts. Tertiary control is not an automatic function and is executed upon request by the grid operator. The reserve margins used for the secondary control are restored through tertiary control. The differences between the primary, secondary and tertiary frequency control is the time the production and response can be activated, and the remuneration for each. Primary frequency control is symmetrical as the capacity for control has been scheduled and usually balances between ramping up and down the production and therefore not remunerated. Secondary and tertiary control are not symmetrical as the capacity can be used only for ramping up or down the production to restore the frequency and are remunerated. Review of the three levels of regulation \u00b6 Response Time Duration Time Operation Purpose Primary Control 10-30 Seconds 15 Minutes Automatic Act in case of frequency variation in order to stabilize frequency value Secondary Control 200 Seconds 120 minutes Automatic Act to bring back frequency value to the nominal value and restore the power reserve of the generators used for the primary frequency control Tertiary Control 15 Minutes Indicated by TSO Upon Request Act to restore power reserves of the generators used for the secondary frequency control Table 4.1 : Main features of frequency control strategies In our transactive energy low voltage grid structure primary, secondary and tertiary control are controlled by an area controller called the balancing agent. Figure 4.6 : Area control structure of market consisting of all three tiers of control (source: Martin Fornage, A generalized transactive energy-based framework: Enphase Energy. Powerpoint presentation 2015) The balancing agent monitors the health of the system and is in control of all its allocated resources. It also had the ability to control the physical connect and disconnect from upstream and downstream resources according to the type of control required. Primary control happens simultaneously as the spot market through a droop curve. Grid forming assets have different droop curves based on their behaviour (Loads, Storage, PV) which are used to keep the voltage and frequency towards nominal in case of a deviation. Local balancing is therefore done through primary control. Secondary control (Inertia Control) is done through a time schedule. The schedule is received from the upper tertiary control or from a ledger. Secondary balancing agents adjust the primary balancing agents resources within its market by disconnecting and connecting them in case of failure of upstream structure or failure to meet the schedule. Tertiary control negotiates the schedules upstream or downstream at lowest cost of operation and provides a marketplace for energy in and out of the market area. The inputs of the tertiary control are the bids, offers and error signals from secondary control. The outputs are the schedules to resources.","title":"Balancing Market Structure"},{"location":"balancing-market/#definition","text":"Electrical power systems are characterized by voltage and frequency and the flow of electricity is a continuous process. Buffering or storing electrical energy at each node is still not feasible, therefore electrical energy needs to be generated exactly at the time of consumption. Differences in supply and demand causes the nominal frequency (50Hz in EU) to deviate. Consequently, supply and demand need to be monitored in real time to implement adjustments to maintain equilibrium and nominal frequency. Significant deviation from the nominal leads to cascading effect culminating in a blackout . Transmission system operators (TSOs) oversee fast, flexible, fossil fuel-based generation units and demand response service from large consumers, ensuring the continuation of operation during significant transient faults in the energy system. These generators form the basis of frequency control strategies used in balancing these electrical systems. Each control strategy has specific purposes and features and can be categorized in three groups, as shown in the figure below. Primary Control (Frequency Containment Reserve - FCR) Secondary Control (Automatic Frequency Restoration Reserves - aFRR) Tertiary Control (Manual Frequency Restoration Reserves - mFRR) Figure 4.4 : The three tiers of grid control and its activation structure","title":"Definition"},{"location":"balancing-market/#in-conventional-grid-structures","text":"Primary control is an automatic function that is almost instantaneously activated to stabilise the frequency drops/spikes. It is the fastest type of frequency control with a response time of a few seconds and operates using a joint process involving all TSOs of the synchronous area. This is shown in the figure below. For example, if there is an increase in demand, the energy used to compensate for this demand comes from the kinetic energy stored in large rotating synchronous generators that start decreasing its velocity. This is referred to as Inertial response . For the generators to recover the speed, the speed controller of each generator acts to increase the generator power to clear the imbalance. Within a period of 30 seconds, each generating unit is able to generate the required power and stabilise this production for at least 15 minutes or depending on the requirements of the TSO within the synchronous region. Primary control is done using generation plants that are connected to the high voltage power supply with the exception of renewable energy sources which are non-schedulable due to its intermittent nature. Figure 4.5 : Recovery of the system from a contingency event and action by primary frequency control (PFR) Secondary control is performed automatically by all the generators to restore the nominal frequency, the power exchanges and reserve of the generators used in primary control. The generators involved in this regulation function through dedicated reserve power that are set in conjunction with central controllers. The reserve control power is negotiated in a contract conjunction with the TSO and is a percentage of the maximum available power with a predefined minimum value to ensure that it can be dispatched whenever needed. This service is remunerated according to the set contracts. Tertiary control is not an automatic function and is executed upon request by the grid operator. The reserve margins used for the secondary control are restored through tertiary control. The differences between the primary, secondary and tertiary frequency control is the time the production and response can be activated, and the remuneration for each. Primary frequency control is symmetrical as the capacity for control has been scheduled and usually balances between ramping up and down the production and therefore not remunerated. Secondary and tertiary control are not symmetrical as the capacity can be used only for ramping up or down the production to restore the frequency and are remunerated.","title":"In conventional grid structures"},{"location":"balancing-market/#review-of-the-three-levels-of-regulation","text":"Response Time Duration Time Operation Purpose Primary Control 10-30 Seconds 15 Minutes Automatic Act in case of frequency variation in order to stabilize frequency value Secondary Control 200 Seconds 120 minutes Automatic Act to bring back frequency value to the nominal value and restore the power reserve of the generators used for the primary frequency control Tertiary Control 15 Minutes Indicated by TSO Upon Request Act to restore power reserves of the generators used for the secondary frequency control Table 4.1 : Main features of frequency control strategies In our transactive energy low voltage grid structure primary, secondary and tertiary control are controlled by an area controller called the balancing agent. Figure 4.6 : Area control structure of market consisting of all three tiers of control (source: Martin Fornage, A generalized transactive energy-based framework: Enphase Energy. Powerpoint presentation 2015) The balancing agent monitors the health of the system and is in control of all its allocated resources. It also had the ability to control the physical connect and disconnect from upstream and downstream resources according to the type of control required. Primary control happens simultaneously as the spot market through a droop curve. Grid forming assets have different droop curves based on their behaviour (Loads, Storage, PV) which are used to keep the voltage and frequency towards nominal in case of a deviation. Local balancing is therefore done through primary control. Secondary control (Inertia Control) is done through a time schedule. The schedule is received from the upper tertiary control or from a ledger. Secondary balancing agents adjust the primary balancing agents resources within its market by disconnecting and connecting them in case of failure of upstream structure or failure to meet the schedule. Tertiary control negotiates the schedules upstream or downstream at lowest cost of operation and provides a marketplace for energy in and out of the market area. The inputs of the tertiary control are the bids, offers and error signals from secondary control. The outputs are the schedules to resources.","title":"Review of the three levels of regulation"},{"location":"battery/","text":"Batteries (also known as energy storage) are energy assets that save the surplus energy produced and store it for use at a later time. Adding a battery to a home or community will increase the self-consumption and self-sufficiency levels and enhance the potential of flexibility service for grid operators. Battery/Storage Configuration Options: \u00b6 Express Mode \u00b6 In the express battery configuration mode, the user is provided with a template (synthetic) custom battery to include as an asset at a select location in the simulated local energy market by naming the asset and setting its location: Name: select a unique name for the battery; Location: the location selected by the user is automatically uploaded. Advanced Mode \u00b6 In the advanced battery configuration mode, the following settings are available as shown in the figure and explained below: Figure 2.13 : Battery (Storage) Advanced Configuration Options in the Grid Singularity Exchange web-based interface (Singularity Map) Battery capacity: set the total energy capacity in kWh Initial capacity: set the initial capacity of the battery in terms of Initial State of Charge (SOC) in % or Initial Energy in kWh Minimum SOC: set the minimum amount of energy to leave unconsumed in the battery (note: batteries usually have a safeguard disabling them to discharge below a specific threshold to increase life expectancy) Max power rating for battery: set the power limit (charge and discharge) for each market slot in kW (note: this parameter limits the maximum sold and bought energy) Initial selling rate: set the initial rate for selling energy at the beginning of each market slot in cents/kWh Final selling rate: set the final rate for selling energy at the end of each market slot in cents/kWh Rate decrease: enter a value for the explicit rate decrease increment per update interval in cents/kWh Initial buying rate: set the initial rate for buying energy at the beginning of each market slot in cents/kWh Final buying rate: set the final rate for buying energy at the end of each market slot in cents/kWh Rate increase: enter a value for the explicit rate increase increment per update interval in cents/kWh Linear Pricing: If activated, a rate increase/decrease per amount of time (update interval) is calculated automatically in a way that the price increases/decreases linearly over the market slot time. The rate is calculated starting at the Initial selling rate and ending at the Final selling rate at the end of the market slot, based on the following formulae for increase and decrease, respectively: energy_rate_increase = (final_buying_rate - initial_buying_rate) / max(int((slot_length / update_interval) -1), 1) ; energy_rate_decrease_per_update = (initial_selling_rate - final_selling_rate) / max(int((slot_length / update_interval) -1), 1) ; note: bidding behaviour is derived from a linear fitted curve of a buying rate between initial_buying_rate and final_buying_rate and a selling rate between initial_selling_rate and final_selling_rate within the bidding interval 12. Update interval: set the frequency at which the rate is updated 13. Capacity based method: if activated, energy will be sold at lower prices during high state of charge - SOC (when the battery has more energy stored) and at higher prices during low SOC (when the battery can afford to sell its stored energy for less). In this case, the offer price for the storage is calculated according to the following formula: offer_rate = initial_selling_rate - ((initial_selling_rate - final_selling_rate)/*soc/100) As an example, considering an initial_selling_rate of 30 cents/kWh and a final_selling_rate of 20 cents/kWh, a storage with an SOC of 1% would sell its energy at 29.9 cents/kWh, and a battery at 100% SOC would sell its energy at 20 cents/kWh. Note: The default setting of the battery component is 100% energy conversion efficiency. It is not possible to change this setting at the moment but it may be in the future versions of the software. Interested contributors may propose such additions to our open source code on GitHub . Storage Behaviour in Local Energy Markets \u00b6 In general all bids and offers follow the physical constraint of the set `max_abs_battery_power_kW value. The accumulated energy per market slot cannot exceed this power value times the length of the market slot, in hours. Energy sold and bought cancel each other out, meaning that if 2kWh are both sold and bought in the same market slot, the relative power remains 0kW. For the buying rate increase and selling rate decrease behaviour, please see the Trading Strategies page . Buying energy in the One-Sided Market \u00b6 On each tick, the storage scans the connected market for affordable offers* if there is storage space to be filled (if the current SOC is lower than 100%). Once an offer is found, it is either fully or partially accepted, depending on the demand. The storage always seeks 100% SOC when buying energy. *affordable offers are offers that have a price lower or equal to the current acceptable energy rate. The acceptable energy rate changes during a market slot depending on the initial_buying_rate, final_buying_rate, energy_rate_decrease_per_update and `update_interval setting. Buying energy in the Two-Sided Market \u00b6 On each tick, the storage either places a bid for the quantity of energy it needs to reach 100% SOC or updates the price of an existing bid in the market where the bid rate depends on the initial_buying_rate, final_buying_rate, energy_rate_decrease_per_update and update_interval setting. Selling energy \u00b6 At the beginning of each market slot, the storage places an offer for all the energy it has stored (not including the energy that is needed to keep the storage at least at min_allowed_soc). This offer is updated at each update_interval pursuant to the rate decrease settings. This mechanism applies in both one and two-sided market types. Consequently, it is possible for the storage to have both an offer and a bid placed in the same market.","title":"Battery (Storage)"},{"location":"battery/#batterystorage-configuration-options","text":"","title":"Battery/Storage Configuration Options:"},{"location":"battery/#express-mode","text":"In the express battery configuration mode, the user is provided with a template (synthetic) custom battery to include as an asset at a select location in the simulated local energy market by naming the asset and setting its location: Name: select a unique name for the battery; Location: the location selected by the user is automatically uploaded.","title":"Express Mode"},{"location":"battery/#advanced-mode","text":"In the advanced battery configuration mode, the following settings are available as shown in the figure and explained below: Figure 2.13 : Battery (Storage) Advanced Configuration Options in the Grid Singularity Exchange web-based interface (Singularity Map) Battery capacity: set the total energy capacity in kWh Initial capacity: set the initial capacity of the battery in terms of Initial State of Charge (SOC) in % or Initial Energy in kWh Minimum SOC: set the minimum amount of energy to leave unconsumed in the battery (note: batteries usually have a safeguard disabling them to discharge below a specific threshold to increase life expectancy) Max power rating for battery: set the power limit (charge and discharge) for each market slot in kW (note: this parameter limits the maximum sold and bought energy) Initial selling rate: set the initial rate for selling energy at the beginning of each market slot in cents/kWh Final selling rate: set the final rate for selling energy at the end of each market slot in cents/kWh Rate decrease: enter a value for the explicit rate decrease increment per update interval in cents/kWh Initial buying rate: set the initial rate for buying energy at the beginning of each market slot in cents/kWh Final buying rate: set the final rate for buying energy at the end of each market slot in cents/kWh Rate increase: enter a value for the explicit rate increase increment per update interval in cents/kWh Linear Pricing: If activated, a rate increase/decrease per amount of time (update interval) is calculated automatically in a way that the price increases/decreases linearly over the market slot time. The rate is calculated starting at the Initial selling rate and ending at the Final selling rate at the end of the market slot, based on the following formulae for increase and decrease, respectively: energy_rate_increase = (final_buying_rate - initial_buying_rate) / max(int((slot_length / update_interval) -1), 1) ; energy_rate_decrease_per_update = (initial_selling_rate - final_selling_rate) / max(int((slot_length / update_interval) -1), 1) ; note: bidding behaviour is derived from a linear fitted curve of a buying rate between initial_buying_rate and final_buying_rate and a selling rate between initial_selling_rate and final_selling_rate within the bidding interval 12. Update interval: set the frequency at which the rate is updated 13. Capacity based method: if activated, energy will be sold at lower prices during high state of charge - SOC (when the battery has more energy stored) and at higher prices during low SOC (when the battery can afford to sell its stored energy for less). In this case, the offer price for the storage is calculated according to the following formula: offer_rate = initial_selling_rate - ((initial_selling_rate - final_selling_rate)/*soc/100) As an example, considering an initial_selling_rate of 30 cents/kWh and a final_selling_rate of 20 cents/kWh, a storage with an SOC of 1% would sell its energy at 29.9 cents/kWh, and a battery at 100% SOC would sell its energy at 20 cents/kWh. Note: The default setting of the battery component is 100% energy conversion efficiency. It is not possible to change this setting at the moment but it may be in the future versions of the software. Interested contributors may propose such additions to our open source code on GitHub .","title":"Advanced Mode"},{"location":"battery/#storage-behaviour-in-local-energy-markets","text":"In general all bids and offers follow the physical constraint of the set `max_abs_battery_power_kW value. The accumulated energy per market slot cannot exceed this power value times the length of the market slot, in hours. Energy sold and bought cancel each other out, meaning that if 2kWh are both sold and bought in the same market slot, the relative power remains 0kW. For the buying rate increase and selling rate decrease behaviour, please see the Trading Strategies page .","title":"Storage Behaviour in Local Energy Markets"},{"location":"battery/#buying-energy-in-the-one-sided-market","text":"On each tick, the storage scans the connected market for affordable offers* if there is storage space to be filled (if the current SOC is lower than 100%). Once an offer is found, it is either fully or partially accepted, depending on the demand. The storage always seeks 100% SOC when buying energy. *affordable offers are offers that have a price lower or equal to the current acceptable energy rate. The acceptable energy rate changes during a market slot depending on the initial_buying_rate, final_buying_rate, energy_rate_decrease_per_update and `update_interval setting.","title":"Buying energy in the One-Sided Market"},{"location":"battery/#buying-energy-in-the-two-sided-market","text":"On each tick, the storage either places a bid for the quantity of energy it needs to reach 100% SOC or updates the price of an existing bid in the market where the bid rate depends on the initial_buying_rate, final_buying_rate, energy_rate_decrease_per_update and update_interval setting.","title":"Buying energy in the Two-Sided Market"},{"location":"battery/#selling-energy","text":"At the beginning of each market slot, the storage places an offer for all the energy it has stored (not including the energy that is needed to keep the storage at least at min_allowed_soc). This offer is updated at each update_interval pursuant to the rate decrease settings. This mechanism applies in both one and two-sided market types. Consequently, it is possible for the storage to have both an offer and a bid placed in the same market.","title":"Selling energy"},{"location":"bills-traded-energy/","text":"This indicator shows the net energy (energy bought minus energy sold) in terms of \u20ac and kWh for each home in the community, as well as Grid Fees and the Grid Market. Each value shown is the total traded in this market for the length of the simulation. The energy values marked in green have a net export of energy while those marked in red have a net import of energy. Bills show the net amount paid or owed, marked in red or green. As an example, the grid market in the figure below is overall selling energy to the community (net exporting). If grid fees are added to the simulation, they will also show up in the energy bills table. Figure 2.21 . Total energy bills and net energy traded in Euro (\u20ac).","title":"Bills traded energy"},{"location":"bills_savings/","text":"The net energy traded (energy bought minus energy sold) traded in the local energy market (LEM) is calculated over a defined time frame (weekly or monthly) and expressed in kilowatt hours (kWh) for each participant and the LEM (energy community), respectively. The energy cost (bill) is calculated over a defined time frame (weekly or monthly) and expressed in Euros (\u20ac). The energy bills and net energy traded table is divided into three columns showing energy bought, sold and the resulting balance. The energy values marked in green indicate a net export of energy, while those marked in red indicate a net import of energy. Bills show the net amount paid or revenue generated, marked in red and green, respectively. For example, in the table below, the utility as an external LEM supplier (also termed the grid market) has sold more energy to the LEM (community) than it has bought from the community (net export), thereby showing revenue for the utility in the \"total balance\" column. When the grid charges are included in the simulation configuration, a market grid fee row appears in the table as shown in the table below. Figure 3.3 : Example of energy bills and net energy traded table in the Results Dashboard, Grid Singularity\u2019s simulation interface (Singularity Map) The energy cost savings indicator shows the financial savings from participating in local energy trading over a defined time frame (weekly or monthly). The energy cost savings value is calculated as follows: Energy cost savings (\u20ac) = Energy bill prior to local trading (total energy demand supplied by external supplier (kWh) * (energy price set by external supplier + applicable grid fees) \u20ac - energy bill with activated local energy trading (\u20ac) (LEM Bill) There are two ways in which the energy cost savings are illustrated on the Grid Singularity Exchange simulation interface (Singularity Map): as an absolute value for the selected period and as a bar chart that plots daily savings for the selected home (energy community member), comparing the cost with and without participation in local energy trading i.e. LEM Bill vs. Utility Bill. Both of these figures are shown below. Figure 3.4 : Weekly cost savings for a home with three assets over a period of one week in the Grid Singularity\u2019s simulation interface (Singularity Map). The top value shows the absolute values while the bar chart at the bottom represents daily savings","title":"Net Energy Traded, Energy Cost (Bill) and Energy Cost Savings"},{"location":"blockchain-installation/","text":"In the following section you will learn how to: Setup your computer for Substrate development Run the GSy DEX code Co-develop the GSy DEX Connect external UI to the GSy DEX Run the GSy DEX code using docker-compose You will also be provided with information on select pallets and choice of primitives/data structures to help you explore the GSy DEX codebase. Setup your computer for Substrate development \u00b6 Please install Rust toolchain and the Developer Tools following the instructions from Substrate here . Run the GSy DEX code \u00b6 The cargo run command will perform an initial build. Use the following command to build the node without launching it: cd gsy-node cargo build --release Once the project has been built, the following command can be used to explore all parameters and subcommands: ./target/release/gsy-node -h The cargo run command will launch a temporary node and its state will be discarded after you terminate the process. This command will start the single-node development chain with persistent state. This is useful in order to not discard the state of the node once the node stops running: ./target/release/gsy-node --dev Purge the development chain's state: ./target/release/gsy-node purge-chain --dev Start the development chain with detailed logging: RUST_BACKTRACE=1 ./target/release/gsy-node -ldebug --dev Integration with the current version of the GSy Energy Exchange is also possible, with the objective of modelling, simulation and optimisation of energy marketplaces. To install, please refer to these installation instructions . Once installation is completed, a new energy marketplace can be modelled following the instructions here . The same marketplace can also be simulated using the GSy DEX as the exchange engine. In order to switch to the GSy DEX and enable blockchain operations, the command-line flag --enable-bc should be used. The mnemonic of the GSy DEX account should also be provided, in order to authorise the exchange engine to restore your key when needed and interact as bids and offers\u2019 aggregator on your behalf with the blockchain. Finally, the ENABLE_SUBSTRATE parameter should be set to True. Co-develop the GSy DEX \u00b6 To develop and extend the GSy DEX features and applications please follow this guide, which is based on the rustup installer tool for Rust toolchain management. First install and configure rustup : # Install curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh # Configure source ~/.cargo/env Configure the Rust toolchain to default to the latest stable version, add nightly and the nightly wasm target: rustup default stable rustup update rustup update nightly rustup target add wasm32-unknown-unknown --toolchain nightly In order to test your setup, the best way to ensure that you have successfully prepared a computer for the GSy Node development is to follow the steps in the first Substrate tutorial . In order to run the code in developer mode, use Rust's native cargo command to build and launch the GSy Node : cd gsy-node cargo run --release -- --dev --tmp You should always use the --release flag to build optimised artifacts . The command-line options specify how you want the running node to operate. In this case, the --dev option specifies that the node runs in development mode using the predefined development chain specification. By default, this option also deletes all active data - such as keys, the blockchain database, and networking information when you stop the node by pressing Control-c. Using the --dev option ensures that you have a clean working state any time you stop and restart the node. Verify your node is up and running successfully by reviewing the output displayed in the terminal. The terminal should display output similar to this: 2022-08-16 13:43:58 Substrate Node 2022-08-16 13:43:58 \u270c\ufe0f version 4.0.0-dev-de262935ede 2022-08-16 13:43:58 \u2764\ufe0f by Substrate DevHub <https://github.com/substrate-developer-hub>, 2017-2022 2022-08-16 13:43:58 \ud83d\udccb Chain specification: Development 2022-08-16 13:43:58 \ud83c\udff7 Node name: limping-oatmeal-7460 2022-08-16 13:43:58 \ud83d\udc64 Role: AUTHORITY 2022-08-16 13:43:58 \ud83d\udcbe Database: RocksDb at /var/folders/2_/g86ns85j5l7fdnl621ptzn500000gn/T/substrate95LPvM/chains/dev/db/full 2022-08-16 13:43:58 \u26d3 Native runtime: node-template-100 (node-template-1.tx1.au1) 2022-08-16 13:43:58 \ud83d\udd28 Initializing Genesis block/state (state: 0xf6f5\u2026423f, header-hash: 0xc665\u2026cf6a) 2022-08-16 13:43:58 \ud83d\udc74 Loading GRANDPA authority set from genesis on what appears to be first startup. 2022-08-16 13:43:59 Using default protocol ID \"sup\" because none is configured in the chain specs 2022-08-16 13:43:59 \ud83c\udff7 Local node identity is: 12D3KooWCu9uPCYZVsayaCKLdZLF8CmqiHkX2wHsAwSYVc2CxmiE ... ... ... ... 2022-08-16 13:54:26 \ud83d\udca4 Idle (0 peers), best: #3 (0xcdac\u202626e5), finalized #1 (0x107c\u20269bae), \u2b07 0 \u2b06 0 If the block number, denoted by the logs that include the string finalized #<block-number> , is increasing, the GSy Node is producing new blocks and its consensus algorithm is operating correctly. Connect external UI to the GSy DEX \u00b6 Once the node is running locally, you can connect it with the Polkadot-JS Apps User Interface to interact with the running node here . Run the GSy DEX code using Docker Compose \u00b6 First, install Docker and Docker Compose . Build and tag the docker image: docker build -t gsy_dex_image . docker tag gsy_dex_image:latest gsy_dex_image:staging and start docker-compose: docker-compose up Explore the GSy DEX code \u00b6 A blockchain node is an application that allows users to participate in a blockchain network. Substrate-based blockchain nodes ensure a number of capabilities: Networking: Substrate nodes use the libp2p networking stack to allow the nodes in the network to communicate with one another. Consensus: Blockchains need to reach consensus on the state of the network to validate transactions. Substrate facilitates custom consensus engines and includes a choice of consensus mechanisms built by the Web3 Foundation research community. RPC Server: A remote procedure call (RPC) server is used to interact with Substrate-based nodes. There are several files in the node directory - take special note of the following: - chain_spec.rs : A chain specification is a source code file that defines a Substrate chain's initial (genesis) state. Chain specifications are useful for development and testing, and critical when architecting the launch of a production chain. Take note of the development_config and testnet_genesis functions, which are used to define the genesis state for the local development chain configuration. These functions identify some well-known accounts and use them to configure the blockchain's initial state. - service.rs : This file defines the node implementation. Take note of the libraries that this file imports and the names of the functions it invokes. In particular, there are references to consensus-related topics, such as the longest chain rule , the Aura block authoring mechanism and the GRANDPA finality gadget. After the node has been built, refer to the embedded documentation to learn more about the capabilities and configuration parameters it facilitates: ./target/release/gsy-node --help Runtime \u00b6 In Substrate, the terms \" runtime \" and \" state transition function \" are analogous and refer to the core logic of the blockchain that is responsible for validating blocks and executing the state changes. The gsy-node Rust package in this repository uses the FRAME framework to construct a blockchain runtime. FRAME allows runtime developers to declare domain-specific logic in modules called \"pallets\". At the heart of FRAME is helpful macro language that makes it easy to create and flexibly compose pallets to generate blockchains that can address a variety of needs . Review the FRAME runtime implementation included in the node source code ./runtime/src/lib.rs and note the following: This file configures several pallets to include in the runtime. Each pallet configuration is defined by a code block that begins with impl $PALLET_NAME::Config for Runtime . The pallets are composed into a single runtime by way of the construct_runtime! macro, which is part of the core FRAME Support library . Pallets \u00b6 The runtime in this project is constructed using many FRAME pallets that ship with the core Substrate repository and orderbook-registry , orderbook-worker and trades-settlement pallets that are defined in the ./modules directory. A FRAME pallet is comprised of a number of blockchain primitives: Storage: FRAME defines a rich set of powerful storage abstractions that makes it easy to use Substrate's efficient key-value database to manage the evolving state of a blockchain. Dispatchables: FRAME pallets define special types of functions that can be invoked (dispatched) from outside of the runtime in order to update its state. Events: Substrate uses events and errors to notify users of important changes in the runtime. Errors: When a dispatchable fails, it returns an error. Config: The Config configuration interface is used to define the types and parameters upon which a FRAME pallet depends. Order Book Registry Pallet \u00b6 The Order Book Registry pallet provides a decentralised order book management system that allows users to register accounts, insert and delete orders, and manage proxies for delegating order management. Pallet Overview \u00b6 The pallet provides several key components: 1. User and Matching Engine Operator registration. 2. Proxy account management for users. 3. Order management, including insertion and deletion. Storage Items \u00b6 RegisteredUser : Maps an AccountId to a Hash for registered users. RegisteredMatchingEngine : Maps an AccountId to a Hash for registered matching engine operators. ProxyAccounts : Maps an AccountId to a BoundedVec of ProxyDefinition for the registered proxy accounts. OrdersRegistry : Maps an OrderReference to an OrderStatus . Events \u00b6 MatchingEngineOperatorRegistered : Emitted when a new matching engine operator is registered. NewOrderInserted : Emitted when a new order is inserted. NewOrderInsertedByProxy : Emitted when a new order is inserted by a proxy account. OrderDeleted : Emitted when an order is deleted. OrderDeletedByProxy : Emitted when an order is deleted by a proxy account. ProxyAccountRegistered : Emitted when a new proxy account is registered. ProxyAccountUnregistered : Emitted when a proxy account is unregistered. UserRegistered : Emitted when a new user is registered. Errors \u00b6 AlreadyRegistered : Returned when an account is already registered. AlreadyRegisteredProxyAccount : Returned when a proxy account is already registered. NoSelfProxy : Returned when an account tries to register itself as a proxy account. NotARegisteredMatchingEngineOperator : Returned when an account is not a registered matching engine operator. NotARegisteredProxyAccount : Returned when an account is not a registered proxy account. NotARegisteredUserAccount : Returned when an account is not a registered user account. NotARegisteredUserOrProxyAccount : Returned when an account is not a registered user or proxy account. NotRegisteredProxyAccounts : Returned when there are no registered proxy accounts. OpenOrderNotFound : Returned when an open order is not found. OrderAlreadyDeleted : Returned when an order is already deleted. OrderAlreadyExecuted : Returned when an order is already executed. OrderAlreadyInserted : Returned when an order is already inserted. ProxyAccountsLimitReached : Returned when the proxy accounts limit has been reached. Dispatchable Functions \u00b6 insert_orders : Insert an order with a given order hash for a registered user account. insert_orders_by_proxy : Insert an order with a given order hash for a registered user account by a registered proxy account. delete_order : Delete an order with a given order hash for a registered user account. delete_order_by_proxy : Delete an order with a given order hash for a registered user account by a registered proxy account. register_proxy_account : Register a new proxy account for a registered user account. register_matching_engine_operator : Register a new matching engine operator account. register_user : Register a new user account. unregister_proxy_account : Unregister a proxy account for a registered user account. Helper Functions \u00b6 add_matching_engine_operator : Add a matching engine operator account. add_proxy_account : Add a proxy account for a registered user account. add_user : Add a user account. is_order_registered : Check if an order is registered. is_registered_matching_engine_operator : Check if an account is a registered matching engine operator. GSy DEX Primitives \u00b6 The implemented Rust code defines the primitive data structures used in the GSy DEX, such as types for block numbers, moments, signatures, public keys, account IDs, account indices, chain IDs, hashes, nonces, balances, headers, blocks, and extrinsics. Additionally, it exports the OrderReference and OrderStatus types from the orders module . Here is an overview of the input data types for the GSy DEX: BlockNumber : a type alias for a 64-bit unsigned integer used to represent block numbers Moment : a type alias for a 64-bit unsigned integer used to represent an instant or duration in time Signature : a type alias for the MultiSignature type from the sp_runtime module. This type is used to represent a signature for a transaction. It allows one of several underlying cryptographic algorithms to be used, so it isn't a fixed size when encoded. AccountPublic : a type alias for the Signer associated type of the Verify trait implemented for Signature . This type represents the public key used for the GSy Node and is actually a MultiSigner . Like the signature, this type also isn't a fixed size when encoded, as different cryptographic algorithms have different size public keys. AccountId : a type alias for the AccountId32 type associated with the IdentifyAccount trait implemented for AccountPublic . This type is an opaque account ID type and is always 32 bytes. AccountIndex : a type alias for a 32-bit unsigned integer used to represent the type for looking up accounts. ChainId : a type alias for a 32-bit unsigned integer used to represent the identifier for a chain. Hash : a type alias for the H256 type from the sp_core module. This type is used to represent a hash of arbitrary data objects (e.g. asset identifiers, orderbook identifiers). Nonce : a type alias for a 32-bit unsigned integer used to represent the index of a transaction. Balance : a type alias for a 128-bit unsigned integer used to represent the balance of an account. Header : a type alias for the generic::Header<BlockNumber, BlakeTwo256> type from the sp_runtime module. This type represents the header of a block. Block : a type alias for the generic::Block<Header, UncheckedExtrinsic> type from the sp_runtime module. This type represents a block. BlockId : a type alias for the generic::BlockId<Block> type from the sp_runtime module. This type represents the ID of a block. UncheckedExtrinsic : an opaque, encoded, unchecked extrinsic that is used to represent a transaction. OrderReference : a type defined in the orders module that represents a reference to a Bid or an Offer . OrderStatus : a type defined in the orders module that represents the status of a Bid or an Offer . mod orders : a module that exports the OrderReference and OrderStatus types. The Orders Module \u00b6 The orders module defines several types: Order : An enum representing the order in the GSy DEX, with two variants: Bid : A struct representing a bid order, including the buyer, nonce and the bid components. Offer : A struct representing an offer (ask) order, including the seller, nonce, and the offer components. OrderStatus : An enum that represents the status of an Order , with three variants: Open : The default status. Executed : The order has been executed. Deleted : The order has been cancelled. OrderReference : A struct that represents a reference to an Order in the GSy DEX, with two fields: user_id : The account ID of the user who created the order. hash : The hash of the order struct which represents a unique reference of the Order object. InputOrder : An enum representing the input format of the order of the GSy DEX. It has two variants: InputBid : A struct representing an input bid order, including the buyer and the bid components. InputOffer : A struct representing an input offer (ask) order, including the seller and the offer components. OrderComponent : A struct representing the common components of an order, including area UUID, market UUID, time slot, creation time, energy, and energy rate. OrderSchema : A struct representing the schema of the order. It is needed in order to enforce the order book storage and other ancillary services to use the same schema/protocol for the Order struct as the GSy Node . The Trades Module \u00b6 The trades module defines several types: Trade : A struct representing a trade, including the seller, buyer, market ID, trade UUID, creation time, time slot, offer, offer hash, bid, bid hash, residual offer, residual bid, and trade parameters. TradeParameters : A struct representing the trade parameters, including the selected energy, energy rate, and trade UUID. BidOfferMatch : A struct representing a bid and offer match, including the selected energy, energy rate, and trade UUID Validator : A trait defining the validation functions for the trades module.","title":"GSy DEX Node Installation, Operation and Development"},{"location":"blockchain-installation/#setup-your-computer-for-substrate-development","text":"Please install Rust toolchain and the Developer Tools following the instructions from Substrate here .","title":"Setup your computer for Substrate development"},{"location":"blockchain-installation/#run-the-gsy-dex-code","text":"The cargo run command will perform an initial build. Use the following command to build the node without launching it: cd gsy-node cargo build --release Once the project has been built, the following command can be used to explore all parameters and subcommands: ./target/release/gsy-node -h The cargo run command will launch a temporary node and its state will be discarded after you terminate the process. This command will start the single-node development chain with persistent state. This is useful in order to not discard the state of the node once the node stops running: ./target/release/gsy-node --dev Purge the development chain's state: ./target/release/gsy-node purge-chain --dev Start the development chain with detailed logging: RUST_BACKTRACE=1 ./target/release/gsy-node -ldebug --dev Integration with the current version of the GSy Energy Exchange is also possible, with the objective of modelling, simulation and optimisation of energy marketplaces. To install, please refer to these installation instructions . Once installation is completed, a new energy marketplace can be modelled following the instructions here . The same marketplace can also be simulated using the GSy DEX as the exchange engine. In order to switch to the GSy DEX and enable blockchain operations, the command-line flag --enable-bc should be used. The mnemonic of the GSy DEX account should also be provided, in order to authorise the exchange engine to restore your key when needed and interact as bids and offers\u2019 aggregator on your behalf with the blockchain. Finally, the ENABLE_SUBSTRATE parameter should be set to True.","title":"Run the GSy DEX code"},{"location":"blockchain-installation/#co-develop-the-gsy-dex","text":"To develop and extend the GSy DEX features and applications please follow this guide, which is based on the rustup installer tool for Rust toolchain management. First install and configure rustup : # Install curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh # Configure source ~/.cargo/env Configure the Rust toolchain to default to the latest stable version, add nightly and the nightly wasm target: rustup default stable rustup update rustup update nightly rustup target add wasm32-unknown-unknown --toolchain nightly In order to test your setup, the best way to ensure that you have successfully prepared a computer for the GSy Node development is to follow the steps in the first Substrate tutorial . In order to run the code in developer mode, use Rust's native cargo command to build and launch the GSy Node : cd gsy-node cargo run --release -- --dev --tmp You should always use the --release flag to build optimised artifacts . The command-line options specify how you want the running node to operate. In this case, the --dev option specifies that the node runs in development mode using the predefined development chain specification. By default, this option also deletes all active data - such as keys, the blockchain database, and networking information when you stop the node by pressing Control-c. Using the --dev option ensures that you have a clean working state any time you stop and restart the node. Verify your node is up and running successfully by reviewing the output displayed in the terminal. The terminal should display output similar to this: 2022-08-16 13:43:58 Substrate Node 2022-08-16 13:43:58 \u270c\ufe0f version 4.0.0-dev-de262935ede 2022-08-16 13:43:58 \u2764\ufe0f by Substrate DevHub <https://github.com/substrate-developer-hub>, 2017-2022 2022-08-16 13:43:58 \ud83d\udccb Chain specification: Development 2022-08-16 13:43:58 \ud83c\udff7 Node name: limping-oatmeal-7460 2022-08-16 13:43:58 \ud83d\udc64 Role: AUTHORITY 2022-08-16 13:43:58 \ud83d\udcbe Database: RocksDb at /var/folders/2_/g86ns85j5l7fdnl621ptzn500000gn/T/substrate95LPvM/chains/dev/db/full 2022-08-16 13:43:58 \u26d3 Native runtime: node-template-100 (node-template-1.tx1.au1) 2022-08-16 13:43:58 \ud83d\udd28 Initializing Genesis block/state (state: 0xf6f5\u2026423f, header-hash: 0xc665\u2026cf6a) 2022-08-16 13:43:58 \ud83d\udc74 Loading GRANDPA authority set from genesis on what appears to be first startup. 2022-08-16 13:43:59 Using default protocol ID \"sup\" because none is configured in the chain specs 2022-08-16 13:43:59 \ud83c\udff7 Local node identity is: 12D3KooWCu9uPCYZVsayaCKLdZLF8CmqiHkX2wHsAwSYVc2CxmiE ... ... ... ... 2022-08-16 13:54:26 \ud83d\udca4 Idle (0 peers), best: #3 (0xcdac\u202626e5), finalized #1 (0x107c\u20269bae), \u2b07 0 \u2b06 0 If the block number, denoted by the logs that include the string finalized #<block-number> , is increasing, the GSy Node is producing new blocks and its consensus algorithm is operating correctly.","title":"Co-develop the GSy DEX"},{"location":"blockchain-installation/#connect-external-ui-to-the-gsy-dex","text":"Once the node is running locally, you can connect it with the Polkadot-JS Apps User Interface to interact with the running node here .","title":"Connect external UI to the GSy DEX"},{"location":"blockchain-installation/#run-the-gsy-dex-code-using-docker-compose","text":"First, install Docker and Docker Compose . Build and tag the docker image: docker build -t gsy_dex_image . docker tag gsy_dex_image:latest gsy_dex_image:staging and start docker-compose: docker-compose up","title":"Run the GSy DEX code using Docker Compose"},{"location":"blockchain-installation/#explore-the-gsy-dex-code","text":"A blockchain node is an application that allows users to participate in a blockchain network. Substrate-based blockchain nodes ensure a number of capabilities: Networking: Substrate nodes use the libp2p networking stack to allow the nodes in the network to communicate with one another. Consensus: Blockchains need to reach consensus on the state of the network to validate transactions. Substrate facilitates custom consensus engines and includes a choice of consensus mechanisms built by the Web3 Foundation research community. RPC Server: A remote procedure call (RPC) server is used to interact with Substrate-based nodes. There are several files in the node directory - take special note of the following: - chain_spec.rs : A chain specification is a source code file that defines a Substrate chain's initial (genesis) state. Chain specifications are useful for development and testing, and critical when architecting the launch of a production chain. Take note of the development_config and testnet_genesis functions, which are used to define the genesis state for the local development chain configuration. These functions identify some well-known accounts and use them to configure the blockchain's initial state. - service.rs : This file defines the node implementation. Take note of the libraries that this file imports and the names of the functions it invokes. In particular, there are references to consensus-related topics, such as the longest chain rule , the Aura block authoring mechanism and the GRANDPA finality gadget. After the node has been built, refer to the embedded documentation to learn more about the capabilities and configuration parameters it facilitates: ./target/release/gsy-node --help","title":"Explore the GSy DEX code"},{"location":"blockchain-installation/#runtime","text":"In Substrate, the terms \" runtime \" and \" state transition function \" are analogous and refer to the core logic of the blockchain that is responsible for validating blocks and executing the state changes. The gsy-node Rust package in this repository uses the FRAME framework to construct a blockchain runtime. FRAME allows runtime developers to declare domain-specific logic in modules called \"pallets\". At the heart of FRAME is helpful macro language that makes it easy to create and flexibly compose pallets to generate blockchains that can address a variety of needs . Review the FRAME runtime implementation included in the node source code ./runtime/src/lib.rs and note the following: This file configures several pallets to include in the runtime. Each pallet configuration is defined by a code block that begins with impl $PALLET_NAME::Config for Runtime . The pallets are composed into a single runtime by way of the construct_runtime! macro, which is part of the core FRAME Support library .","title":"Runtime"},{"location":"blockchain-installation/#pallets","text":"The runtime in this project is constructed using many FRAME pallets that ship with the core Substrate repository and orderbook-registry , orderbook-worker and trades-settlement pallets that are defined in the ./modules directory. A FRAME pallet is comprised of a number of blockchain primitives: Storage: FRAME defines a rich set of powerful storage abstractions that makes it easy to use Substrate's efficient key-value database to manage the evolving state of a blockchain. Dispatchables: FRAME pallets define special types of functions that can be invoked (dispatched) from outside of the runtime in order to update its state. Events: Substrate uses events and errors to notify users of important changes in the runtime. Errors: When a dispatchable fails, it returns an error. Config: The Config configuration interface is used to define the types and parameters upon which a FRAME pallet depends.","title":"Pallets"},{"location":"blockchain-installation/#order-book-registry-pallet","text":"The Order Book Registry pallet provides a decentralised order book management system that allows users to register accounts, insert and delete orders, and manage proxies for delegating order management.","title":"Order Book Registry Pallet"},{"location":"blockchain-installation/#pallet-overview","text":"The pallet provides several key components: 1. User and Matching Engine Operator registration. 2. Proxy account management for users. 3. Order management, including insertion and deletion.","title":"Pallet Overview"},{"location":"blockchain-installation/#storage-items","text":"RegisteredUser : Maps an AccountId to a Hash for registered users. RegisteredMatchingEngine : Maps an AccountId to a Hash for registered matching engine operators. ProxyAccounts : Maps an AccountId to a BoundedVec of ProxyDefinition for the registered proxy accounts. OrdersRegistry : Maps an OrderReference to an OrderStatus .","title":"Storage Items"},{"location":"blockchain-installation/#events","text":"MatchingEngineOperatorRegistered : Emitted when a new matching engine operator is registered. NewOrderInserted : Emitted when a new order is inserted. NewOrderInsertedByProxy : Emitted when a new order is inserted by a proxy account. OrderDeleted : Emitted when an order is deleted. OrderDeletedByProxy : Emitted when an order is deleted by a proxy account. ProxyAccountRegistered : Emitted when a new proxy account is registered. ProxyAccountUnregistered : Emitted when a proxy account is unregistered. UserRegistered : Emitted when a new user is registered.","title":"Events"},{"location":"blockchain-installation/#errors","text":"AlreadyRegistered : Returned when an account is already registered. AlreadyRegisteredProxyAccount : Returned when a proxy account is already registered. NoSelfProxy : Returned when an account tries to register itself as a proxy account. NotARegisteredMatchingEngineOperator : Returned when an account is not a registered matching engine operator. NotARegisteredProxyAccount : Returned when an account is not a registered proxy account. NotARegisteredUserAccount : Returned when an account is not a registered user account. NotARegisteredUserOrProxyAccount : Returned when an account is not a registered user or proxy account. NotRegisteredProxyAccounts : Returned when there are no registered proxy accounts. OpenOrderNotFound : Returned when an open order is not found. OrderAlreadyDeleted : Returned when an order is already deleted. OrderAlreadyExecuted : Returned when an order is already executed. OrderAlreadyInserted : Returned when an order is already inserted. ProxyAccountsLimitReached : Returned when the proxy accounts limit has been reached.","title":"Errors"},{"location":"blockchain-installation/#dispatchable-functions","text":"insert_orders : Insert an order with a given order hash for a registered user account. insert_orders_by_proxy : Insert an order with a given order hash for a registered user account by a registered proxy account. delete_order : Delete an order with a given order hash for a registered user account. delete_order_by_proxy : Delete an order with a given order hash for a registered user account by a registered proxy account. register_proxy_account : Register a new proxy account for a registered user account. register_matching_engine_operator : Register a new matching engine operator account. register_user : Register a new user account. unregister_proxy_account : Unregister a proxy account for a registered user account.","title":"Dispatchable Functions"},{"location":"blockchain-installation/#helper-functions","text":"add_matching_engine_operator : Add a matching engine operator account. add_proxy_account : Add a proxy account for a registered user account. add_user : Add a user account. is_order_registered : Check if an order is registered. is_registered_matching_engine_operator : Check if an account is a registered matching engine operator.","title":"Helper Functions"},{"location":"blockchain-installation/#gsy-dex-primitives","text":"The implemented Rust code defines the primitive data structures used in the GSy DEX, such as types for block numbers, moments, signatures, public keys, account IDs, account indices, chain IDs, hashes, nonces, balances, headers, blocks, and extrinsics. Additionally, it exports the OrderReference and OrderStatus types from the orders module . Here is an overview of the input data types for the GSy DEX: BlockNumber : a type alias for a 64-bit unsigned integer used to represent block numbers Moment : a type alias for a 64-bit unsigned integer used to represent an instant or duration in time Signature : a type alias for the MultiSignature type from the sp_runtime module. This type is used to represent a signature for a transaction. It allows one of several underlying cryptographic algorithms to be used, so it isn't a fixed size when encoded. AccountPublic : a type alias for the Signer associated type of the Verify trait implemented for Signature . This type represents the public key used for the GSy Node and is actually a MultiSigner . Like the signature, this type also isn't a fixed size when encoded, as different cryptographic algorithms have different size public keys. AccountId : a type alias for the AccountId32 type associated with the IdentifyAccount trait implemented for AccountPublic . This type is an opaque account ID type and is always 32 bytes. AccountIndex : a type alias for a 32-bit unsigned integer used to represent the type for looking up accounts. ChainId : a type alias for a 32-bit unsigned integer used to represent the identifier for a chain. Hash : a type alias for the H256 type from the sp_core module. This type is used to represent a hash of arbitrary data objects (e.g. asset identifiers, orderbook identifiers). Nonce : a type alias for a 32-bit unsigned integer used to represent the index of a transaction. Balance : a type alias for a 128-bit unsigned integer used to represent the balance of an account. Header : a type alias for the generic::Header<BlockNumber, BlakeTwo256> type from the sp_runtime module. This type represents the header of a block. Block : a type alias for the generic::Block<Header, UncheckedExtrinsic> type from the sp_runtime module. This type represents a block. BlockId : a type alias for the generic::BlockId<Block> type from the sp_runtime module. This type represents the ID of a block. UncheckedExtrinsic : an opaque, encoded, unchecked extrinsic that is used to represent a transaction. OrderReference : a type defined in the orders module that represents a reference to a Bid or an Offer . OrderStatus : a type defined in the orders module that represents the status of a Bid or an Offer . mod orders : a module that exports the OrderReference and OrderStatus types.","title":"GSy DEX Primitives"},{"location":"blockchain-installation/#the-orders-module","text":"The orders module defines several types: Order : An enum representing the order in the GSy DEX, with two variants: Bid : A struct representing a bid order, including the buyer, nonce and the bid components. Offer : A struct representing an offer (ask) order, including the seller, nonce, and the offer components. OrderStatus : An enum that represents the status of an Order , with three variants: Open : The default status. Executed : The order has been executed. Deleted : The order has been cancelled. OrderReference : A struct that represents a reference to an Order in the GSy DEX, with two fields: user_id : The account ID of the user who created the order. hash : The hash of the order struct which represents a unique reference of the Order object. InputOrder : An enum representing the input format of the order of the GSy DEX. It has two variants: InputBid : A struct representing an input bid order, including the buyer and the bid components. InputOffer : A struct representing an input offer (ask) order, including the seller and the offer components. OrderComponent : A struct representing the common components of an order, including area UUID, market UUID, time slot, creation time, energy, and energy rate. OrderSchema : A struct representing the schema of the order. It is needed in order to enforce the order book storage and other ancillary services to use the same schema/protocol for the Order struct as the GSy Node .","title":"The Orders Module"},{"location":"blockchain-installation/#the-trades-module","text":"The trades module defines several types: Trade : A struct representing a trade, including the seller, buyer, market ID, trade UUID, creation time, time slot, offer, offer hash, bid, bid hash, residual offer, residual bid, and trade parameters. TradeParameters : A struct representing the trade parameters, including the selected energy, energy rate, and trade UUID. BidOfferMatch : A struct representing a bid and offer match, including the selected energy, energy rate, and trade UUID Validator : A trait defining the validation functions for the trades module.","title":"The Trades Module"},{"location":"blockchain-system-components-overview/","text":"The GSy DEX is composed of several components that work together to provide a secure, scalable, and efficient platform for energy trading. The core of the GSy DEX is built using the Substrate framework, which provides the distributed ledger and custom runtime for implementing the state transition functions required for the energy exchange. Additionally, the system includes a set of ancillary services that enable further scalability and security. GSy Node \u00b6 The Substrate -based GSy Node is the backbone of the exchange, consisting of two main parts: Client with external node services: This component handles network activities such as peer discovery, managing transaction requests, reaching consensus with peers, and responding to remote procedure calls ( RPC ). Custom runtime: This component contains all the business logic for executing the state transition functions of the blockchain. The custom runtime is designed to improve scalability and security, avoiding and mitigating multiple blockchain attack types more effectively than by using smart contracts or a generalised virtual machine. For more, please see the section on GSy Node Installation, Operation and Development . Figure 6.2 : GSY DEX On-Chain Operations via GSY Node (Note: Order Book is where bids and offers are stored, to be then matched based on the applicable trading mechanism for price verification and executed based on energy delivery verification). GSy DEX Matching Engine \u00b6 The GSy DEX Matching Engine is responsible for identifying suitable matches for energy supply and demand based on the participants' preferences and market conditions. By efficiently matching bids and offers, the engine facilitates a seamless and optimised exchange clearance. Multi-attribute auctions, which account for the participants\u2019 preferences and varied market conditions, require more advanced clearing algorithms than single attribute auctions, such as those based on price alone. The optimal approach is to engage (potentially untrusted) off-chain workers to run matching algorithms and then require either the use of trusted execution environments (enclaves) or an on-chain verification to determine whether the matching algorithm ran correctly. To enable this approach, the matching process is decoupled from the exchange, and moved to a dedicated component, namely the Matching Engine. The GSy DEX Matching Engine will operate as (one or multiple) individual autonomous service(s), responsible for identifying suitable matches for multiple open order books. Grid Singularity will serve as the Matching Engine Operator for the GSy DEX . The GSy DEX Matching Engine reads open bids and offers through the GSy Matching API and submits matches for validation. Since the exchange\u2019s verification function only checks the validity of each match rather than the result of a specific matching algorithm, there is no longer a need for an agreed matching algorithm, arbitration technique, or redundant off-chain worker computation. For more, please see the GSy Matching API section. The GSy DEX Matching Engine system component is currently in development. GSy DEX Execution Engine \u00b6 Once a trade has been matched by the GSy Matching API , the GSy DEX Execution Engine handles the execution or rejection of the trade by processing energy production and consumption measurements from the energy assets. This component ensures that trades are executed securely, transparently and in accordance with the agreed terms, while maintaining the integrity of the exchange platform. Spot and futures trading requires predictions of energy used at both the asset and network level, often associated with high prediction errors. Thus, although a balancing mechanism addresses the energy imbalances on the physical level, financial exchanges might still not be executed, causing a mismatch between the physical energy delivery and the market accounting. Multiple solutions for mismatch mitigation can be provided by the GSy DEX , to be applied pursuant to respective local regulation: Allow the grid operator to set prices or enforce penalties for any energy mismatch, Implement final gate closure time one day after delivery, allowing post-delivery trading for balance responsible parties to trade imbalances in real-time, and/or Allow post-delivery trading for all market participants. Grid Singularity will serve as the Execution Engine operator for the GSy DEX. The GSy DEX Execution Engine system component is in development. GSy DEX Analytics Engine \u00b6 The GSy DEX Analytics Engine collects and processes live trading data (bids, offers, trades) and related energy asset information, providing valuable insights and market intelligence to the exchange platform users and / or operators by generating key performance indicators. This information helps users make informed decisions and identify trends, which can lead to more efficient energy trading strategies and improved market dynamics. A list of currently supported key performance indicators can be found here , with more under development. The GSy DEX API Gateway provides REST endpoints in order to facilitate access for authenticated customers to the calculated key performance indicators overview. In addition, the full dataset pertaining to the performance indicators can be downloaded in JSON format for detailed analysis. Grid Singularity will serve as the Analytics Engine operator for the GSy DEX. The GSy DEX Analytics Engine system component is in development. GSy DEX API Gateway \u00b6 The GSy DEX API Gateway serves as a bridge between user and community clients and the GSy DEX . Through this interface, users can access the platform's features, submit energy orders, and retrieve key performance indicators , including the trade volume, as well as current and historical asset data (e.g. energy consumption / production, traded energy). The GSy DEX API Gateway also fosters community engagement and collaboration by allowing third-party developers to build and integrate complementary applications and services, such as payments. Clients of the API Gateway vary from user interfaces (that intend to facilitate exchange access to the user) to automated scripts that execute automated trading scripts to optimise trading behaviour for client-owned assets. The API Gateway will also support different client roles, in order to tailor and manage access for Community Managers, Community Members, Grid Operators, Utilities and other customer types. Secure and privacy-embedded access rights management will be enabled by the Energy Web \u2019s open-source tool for decentralised identity and access management. The objective is for each participating energy asset to have a decentralised identifier (DID) created by the manufacturer and transferred to the owner upon purchase, allowing the participant to trade in the energy market and perform other operations with a verified energy asset. Utilities, grid operators, aggregators, energy community managers and members, as well as other energy market participants can also be validated through this mechanism, facilitating unhindered onboarding and interoperability of many different asset types and participants at varied technology levels. The GSy DEX API Gateway system component is in development. GSy DEX Off-Chain Storage \u00b6 The off-chain storage component of the GSy DEX is designed to store various types of data that are crucial to the platform's operation but do not need to be recorded on the blockchain. This approach enhances scalability and efficiency by reducing the amount of data stored on-chain. The off-chain storage comprises four distinct components: GSy DEX Grid Topology Storage: contains information about the physical grid structure, such as the location and configuration of nodes, as well as the interconnections between energy assets, which enable the GSy DEX to both verify the eligibility of the assets for trading, and to facilitate performance analytics that involve the topology of the grid. GSy DEX Measurement Storage: stores the energy consumption and generation data from energy assets. Accurate measurement data is essential for validating and executing energy trades, managing grid stability, and optimising energy consumption and generation patterns. GSy DEX Trades Storage: stores all energy trades of the GSy DEX, which are required in order to maintain and update the trade status to facilitate trade execution, as well as for analytics, auditing the trading behaviour of the user energy assets, and historical market analysis. GSy DEX Order Book Storage: This storage component holds all the orders inserted in the respective market, including bids and offers issued by participants. The Order Book Storage facilitates the efficient operation of the GSy DEX Matching Engine by providing it with the necessary data to match supply to demand according to participants' preferences and market conditions. The GSy DEX Off-Chain Storage system component is in development. Complementary open-source service integration: Energy Web Green Proofs \u00b6 The Energy Web Green Proofs are a customisable, open-source, blockchain-based solution for registering and tracking low-carbon products and their attributes throughout complex supply chains. GSy DEX will also integrate with other ancillary services, including the Energy Web Digital Spine toolkit.","title":"GSy DEX System Components Overview"},{"location":"blockchain-system-components-overview/#gsy-node","text":"The Substrate -based GSy Node is the backbone of the exchange, consisting of two main parts: Client with external node services: This component handles network activities such as peer discovery, managing transaction requests, reaching consensus with peers, and responding to remote procedure calls ( RPC ). Custom runtime: This component contains all the business logic for executing the state transition functions of the blockchain. The custom runtime is designed to improve scalability and security, avoiding and mitigating multiple blockchain attack types more effectively than by using smart contracts or a generalised virtual machine. For more, please see the section on GSy Node Installation, Operation and Development . Figure 6.2 : GSY DEX On-Chain Operations via GSY Node (Note: Order Book is where bids and offers are stored, to be then matched based on the applicable trading mechanism for price verification and executed based on energy delivery verification).","title":"GSy Node"},{"location":"blockchain-system-components-overview/#gsy-dex-matching-engine","text":"The GSy DEX Matching Engine is responsible for identifying suitable matches for energy supply and demand based on the participants' preferences and market conditions. By efficiently matching bids and offers, the engine facilitates a seamless and optimised exchange clearance. Multi-attribute auctions, which account for the participants\u2019 preferences and varied market conditions, require more advanced clearing algorithms than single attribute auctions, such as those based on price alone. The optimal approach is to engage (potentially untrusted) off-chain workers to run matching algorithms and then require either the use of trusted execution environments (enclaves) or an on-chain verification to determine whether the matching algorithm ran correctly. To enable this approach, the matching process is decoupled from the exchange, and moved to a dedicated component, namely the Matching Engine. The GSy DEX Matching Engine will operate as (one or multiple) individual autonomous service(s), responsible for identifying suitable matches for multiple open order books. Grid Singularity will serve as the Matching Engine Operator for the GSy DEX . The GSy DEX Matching Engine reads open bids and offers through the GSy Matching API and submits matches for validation. Since the exchange\u2019s verification function only checks the validity of each match rather than the result of a specific matching algorithm, there is no longer a need for an agreed matching algorithm, arbitration technique, or redundant off-chain worker computation. For more, please see the GSy Matching API section. The GSy DEX Matching Engine system component is currently in development.","title":"GSy DEX Matching Engine"},{"location":"blockchain-system-components-overview/#gsy-dex-execution-engine","text":"Once a trade has been matched by the GSy Matching API , the GSy DEX Execution Engine handles the execution or rejection of the trade by processing energy production and consumption measurements from the energy assets. This component ensures that trades are executed securely, transparently and in accordance with the agreed terms, while maintaining the integrity of the exchange platform. Spot and futures trading requires predictions of energy used at both the asset and network level, often associated with high prediction errors. Thus, although a balancing mechanism addresses the energy imbalances on the physical level, financial exchanges might still not be executed, causing a mismatch between the physical energy delivery and the market accounting. Multiple solutions for mismatch mitigation can be provided by the GSy DEX , to be applied pursuant to respective local regulation: Allow the grid operator to set prices or enforce penalties for any energy mismatch, Implement final gate closure time one day after delivery, allowing post-delivery trading for balance responsible parties to trade imbalances in real-time, and/or Allow post-delivery trading for all market participants. Grid Singularity will serve as the Execution Engine operator for the GSy DEX. The GSy DEX Execution Engine system component is in development.","title":"GSy DEX Execution Engine"},{"location":"blockchain-system-components-overview/#gsy-dex-analytics-engine","text":"The GSy DEX Analytics Engine collects and processes live trading data (bids, offers, trades) and related energy asset information, providing valuable insights and market intelligence to the exchange platform users and / or operators by generating key performance indicators. This information helps users make informed decisions and identify trends, which can lead to more efficient energy trading strategies and improved market dynamics. A list of currently supported key performance indicators can be found here , with more under development. The GSy DEX API Gateway provides REST endpoints in order to facilitate access for authenticated customers to the calculated key performance indicators overview. In addition, the full dataset pertaining to the performance indicators can be downloaded in JSON format for detailed analysis. Grid Singularity will serve as the Analytics Engine operator for the GSy DEX. The GSy DEX Analytics Engine system component is in development.","title":"GSy DEX Analytics Engine"},{"location":"blockchain-system-components-overview/#gsy-dex-api-gateway","text":"The GSy DEX API Gateway serves as a bridge between user and community clients and the GSy DEX . Through this interface, users can access the platform's features, submit energy orders, and retrieve key performance indicators , including the trade volume, as well as current and historical asset data (e.g. energy consumption / production, traded energy). The GSy DEX API Gateway also fosters community engagement and collaboration by allowing third-party developers to build and integrate complementary applications and services, such as payments. Clients of the API Gateway vary from user interfaces (that intend to facilitate exchange access to the user) to automated scripts that execute automated trading scripts to optimise trading behaviour for client-owned assets. The API Gateway will also support different client roles, in order to tailor and manage access for Community Managers, Community Members, Grid Operators, Utilities and other customer types. Secure and privacy-embedded access rights management will be enabled by the Energy Web \u2019s open-source tool for decentralised identity and access management. The objective is for each participating energy asset to have a decentralised identifier (DID) created by the manufacturer and transferred to the owner upon purchase, allowing the participant to trade in the energy market and perform other operations with a verified energy asset. Utilities, grid operators, aggregators, energy community managers and members, as well as other energy market participants can also be validated through this mechanism, facilitating unhindered onboarding and interoperability of many different asset types and participants at varied technology levels. The GSy DEX API Gateway system component is in development.","title":"GSy DEX API Gateway"},{"location":"blockchain-system-components-overview/#gsy-dex-off-chain-storage","text":"The off-chain storage component of the GSy DEX is designed to store various types of data that are crucial to the platform's operation but do not need to be recorded on the blockchain. This approach enhances scalability and efficiency by reducing the amount of data stored on-chain. The off-chain storage comprises four distinct components: GSy DEX Grid Topology Storage: contains information about the physical grid structure, such as the location and configuration of nodes, as well as the interconnections between energy assets, which enable the GSy DEX to both verify the eligibility of the assets for trading, and to facilitate performance analytics that involve the topology of the grid. GSy DEX Measurement Storage: stores the energy consumption and generation data from energy assets. Accurate measurement data is essential for validating and executing energy trades, managing grid stability, and optimising energy consumption and generation patterns. GSy DEX Trades Storage: stores all energy trades of the GSy DEX, which are required in order to maintain and update the trade status to facilitate trade execution, as well as for analytics, auditing the trading behaviour of the user energy assets, and historical market analysis. GSy DEX Order Book Storage: This storage component holds all the orders inserted in the respective market, including bids and offers issued by participants. The Order Book Storage facilitates the efficient operation of the GSy DEX Matching Engine by providing it with the necessary data to match supply to demand according to participants' preferences and market conditions. The GSy DEX Off-Chain Storage system component is in development. Complementary open-source service integration:","title":"GSy DEX Off-Chain Storage"},{"location":"blockchain-system-components-overview/#energy-web-green-proofs","text":"The Energy Web Green Proofs are a customisable, open-source, blockchain-based solution for registering and tracking low-carbon products and their attributes throughout complex supply chains. GSy DEX will also integrate with other ancillary services, including the Energy Web Digital Spine toolkit.","title":"Energy Web Green Proofs"},{"location":"blockchain/","text":"The Grid Singularity Exchange decentralised implementation (GSy DEX) aims to create a robust, secure, and efficient platform for energy trading in a decentralised environment by leveraging distributed ledger technology, such as blockchain, and advanced distributed runtime functionalities. The GSy DEX is designed to further optimise energy consumption and generation, promote peer-to-peer energy trading, and contribute to a more sustainable and resilient energy infrastructure. The GSy DEX powers Symbiotic Energy Markets , combining multi-attribute double-sided auctions, graph representations of the energy grid and the decentralised computation and verification enabled by blockchain. In the envisaged consumer-centric market design, spot, futures, settlement, and balancing markets are intertwined through the use of time slots, allowing market-driven pricing and accurate accounting of delivered energy. Individuals can optimise for their own multi-attribute objectives (e.g. green energy source, reduced energy bill, preferred trading partner) through Degrees of Freedom in the multi-attribute double auction with dynamic pricing. The grid is represented as a weighted graph, offering grid operators efficient management tools and allowing energy communities to interconnect and trade. The complexity of the matching algorithm is decoupled from the verification of transactions, with matching facilitated by third party matching algorithm providers, termed \u201cmycos\u201d, enabling the exchange itself to operate on a blockchain. New energy market participants are rewarded for providing valuable services such as data and algorithms, while the roles of established market participants (aggregators, grid operators, utilities, and regulators) converge towards the individual and the community. The GSy DEX is built on Substrate , which allows modular business logic to be built directly in the blockchain and facilitates a high and secure transaction throughput. Substrate has components called pallets, where each pallet can represent different functionality, such as smart contracts, storage, auctions, and more. The first GSy DEX feature developed and published as part of the Grid Singularity Exchange open-source GPL v.3 licence code base, is the GSy Node with a storage pallet that provides immutable storage of executed transactions. The GSy DEX is currently available in the form of simulated transactions, intended for developers interested in contributing and/or building complementary features. Blockchain code can also optionally be enabled on simulations running locally with the backend code base. Full blockchain deployment will be enabled once the following GSy DEX System Components are completed, with current development in part supported by the European Union FEDECOM project : GSy Node (completed) GSy DEX Matching Engine (in development) and GSy Matching API (developed in Python; Rust version to be released with the Engine) GSy DEX Execution Engine (in development) GSy DEX Analytics Engine (in development) GSy DEX API Gateway (in development) GSy DEX API Off-Chain Storage (in development) Energy Web Green Proofs (in development) The Energy Web Chain is the blockchain of choice for the Grid Singularity Exchange decentralised implementation, anchored upon Polkadot\u2019s scaling solution. Grid Singularity, an energy technology startup, and the Rocky Mountain Institute, a nonprofit clean technology organisation, jointly founded the Energy Web Foundation (EWF) in January 2017 as a non-profit entrepreneurial foundation building web3 applications for the energy transition. Having significantly contributed to EWF development and the launch of the Energy Web Chain, Grid Singularity\u2019s role today in the Energy Web is supervisory and advisory via Foundation Council. Figure 6.1 : Decentralised Peer-to-Peer Energy Exchange (GSY DEX) Architecture (Note: GSY DEX system components, designated in green, interact with the GSy Node for on-chain operations via Energy Web Data Hub that provides a secure and interoperable data exchange service. Grid and asset management services are provided through interoperable API interfaces, as are third party services such as billing and payments). The GSy DEX Design Principles The GSy DEX is designed around a set of key principles that guide its development and ensure that it meets the requirements of a modern, efficient, and secure energy trading platform. These design principles are aligned with the use of the Substrate framework for the development of the distributed ledger combined with the definition of a set of complementary ancillary services. Modularity: The GSy DEX is built on a modular structure, enabling each component to be developed, tested, and maintained independently. This modularity simplifies the development process and allows for easy integration of new features, modules, or services in the future. Scalability: The GSy DEX is designed to scale horizontally, accommodating the growing number of participants, transactions, and data. The use of Substrate allows for a highly scalable and efficient distributed ledger, while the ancillary services can also scale independently to handle increased throughput. Interoperability: The GSy DEX promotes the use of open standards, protocols, and APIs to facilitate seamless integration with other systems, platforms, and technologies in the energy sector. This approach enables the GSy DEX to easily interact with other energy management systems, IoT devices, and related infrastructure and applications. Security: Ensuring the security and integrity of the GSy DEX is a top priority. The Substrate framework provides robust security features, including strong cryptographic algorithms and a proven consensus mechanism. In addition, the ancillary services and communication protocols must be designed with security best practices in mind, including encryption, access control, and secure data storage. Decentralisation: The GSy DEX leverages the power of blockchain technology to enable a fully decentralised system. This approach eliminates the need for a central authority, ensuring a transparent, secure, and efficient energy trading platform that is less susceptible to manipulation or control by any single entity. Flexibility: The GSy DEX is designed to be adaptable and capable of incorporating new technologies, innovations, and evolving market requirements. This flexibility is achieved through the use of modular components, extensible APIs, and a development process that encourages innovation and experimentation. Usability: The user experience is an essential aspect of the GSy DEX. The GSy DEX should be easy to use and accessible to a wide range of users, including energy producers, consumers, grid operators, and regulators. The user interfaces and APIs are designed with simplicity, efficiency, and intuitiveness in mind. In brief, while the Grid Singularity Exchange does not require blockchain technology, its decentralised implementation (GSy DEX) enables a more optimal energy market design, deriving a multitude of benefits, directly or by interacting with complementary blockchain-based solutions, including Energy Web\u2019s decentralised identity access management for energy assets and related open-source tools of the Energy Web Digital Spine toolkit , as well as Energy Web Green Proofs , a customisable solution for registering and tracking low-carbon products and their attributes throughout complex supply chains. We rely on open source innovation and ecosystem collaboration to develop an inclusive, efficient, accountable and secure energy exchange.","title":"GSy DEX Overview"},{"location":"canary-network/","text":"The Grid Singularity Canary Test Network (CN) is the first peer-to-peer energy exchange with live energy asset data and real-time trading . At the current stage, CN acts as a uni-directional bridge between the physical and digital world, reading real consumption and generation data from real energy assets in real-time, while simulating trading with the grid\u2019s digital twins. Flexible assets\u2019 digital twins such as storage are unbundled from their physical ones, to simulate the benefits of Local Energy Markets without real world energy and financial transactions. All energy trades in the GSy Canary Test Network are simulated, meaning that no real-world financial or energy transaction occurs and flexible assets such as batteries may physically charge or discharge at different times than their simulated behaviour in the Canary Network. The GSy Canary Test Network runs at real time, meaning that assets send their actual energy usage through the Asset API once every 15 minutes . This mimics how deployed exchanges will operate, but provides only a few sets of data points every hour, requiring iterations of experiments to which doesn\u2019t meet the needs of the ongoing research efforts to determine effective market, grid fee, and agent designs. Determining the mechanics for deployable markets require frequent iterations and experimentation. Grid Singularity simulations allow for energy exchanges to be run at warp speed, meaning one week of trading can be simulated and analysed in less than two hours. This functionality allows for rapid prototyping of grid models and experimental setups . CN is designed to host an iterative process to test new ideas in a safe environment, closest as possible to reality. The following link will direct you to the Grid Singularity Canary Test Network tutorial .","title":"Canary network"},{"location":"cloud-service-guide/","text":"Guide to setup and run an API agent from a cloud based service \u00b6 Amazon Web Services (AWS) \u00b6 Step 1: Set up an instance \u00b6 Login to your AWS account. If you don\u2019t have one, you can create one, the free plan is sufficient. Create a virtual machine. Select an AMI . We strongly recommend using Ubuntu Server 20.04 LTS (HVM), SSD Volume Type Choose instance type t2.micro 1vcpus and 1GiB and click on review and launch Create a new ssh key and download it on your local machine. The key file\u2019s format is .pem Now you need to copy your scripts/files from your local computer onto your AWS instance. To do that you need to connect to your instance by using the ssh key and your public DNS. You can find the DNS of your instance by selecting your instance and looking at the summary First you need to make sure your key is not publicly available on your machine. Run the following command chmod 400 path_to/mykey.pem Step 2: Upload relevant files onto the instance \u00b6 To copy a file into your AWS instance please run the equivalent command (with your own information) scp -i path_to_ssh_key.pem path_to_file username@public_DNS:/path_to_copy The username can be found after clicking on connect. The default username will depend on the instance platform you are using. If you are using Linux, \u201cubuntu\u201d will be the default username. Additionally we recommend copying your files into the home directory of your instance /home/ubuntu . Here is an example of command scp -i Desktop/mykey.pem myscript.py ubuntu@ec2-18-188-221-121.us-east-2.compute.amazonaws.com:/home/ubuntu/ Step 3: Connect to the instance \u00b6 Once you have copied all necessary files onto you AWS instance you can connect to your instance with 2 ways Directly with the AWS terminal cli that you can access by clicking on connect on your EC2 instance connect With your local terminal cli (recommended) To connect to your instance from your local terminal you just need to run the following command with your equivalent information ssh -i path_to/mykey.pem username@public_DNS Example ssh -i Desktop/mykey.pem ubuntu@ec2-18-188-221-121.us-east-2.compute.amazonaws.com Once connected, go into the directory you have previously sent your files. If you have copied them in /home/ubuntu , just run the following command cd /home/ubuntu You can list all the files in the directory, to confirm that your files are correctly copied onto the instance by running ls Step 4: Initialize the instance's environment and install Grid Singularity Client \u00b6 Update and install all required package on your AWS instance Update your sudo sudo apt update Install python3 pip sudo apt install python3-pip Add deadnakes to your system source sudo add-apt-repository ppa:deadsnakes/ppa Install python 3.6 sudo apt-get install python3.6 Install virtual environment sudo apt install python3-virtualenv Create a virtual environment with python 3.6 virtualenv /tmp/d3a --python=/usr/bin/python3.6 Activate your virtual environment source /tmp/d3a/bin/activate Install d3a api client pip3 install git+https://github.com/gridsingularity/d3a-api-client.git Step 5: Install screen and run the API agent \u00b6 To be able to run the script indefinitely on your AWS instance you need to install Linux Screen (that allows to have multiple screen within your terminal) with the following command sudo apt-get install screen Create a new screen screen -S screen_name Run your python script python3 assets.py To detach from the current screen session Ctr+a+d If you want to log back in the relevant screen run screen -r screen_name Once you are detached for the running screen you are able to close your terminal and your script will continue to run indefinitely on your AWS instance","title":"Cloud service guide"},{"location":"cloud-service-guide/#guide-to-setup-and-run-an-api-agent-from-a-cloud-based-service","text":"","title":"Guide to setup and run an API agent from a cloud based service"},{"location":"cloud-service-guide/#amazon-web-services-aws","text":"","title":"Amazon Web Services (AWS)"},{"location":"cloud-service-guide/#step-1-set-up-an-instance","text":"Login to your AWS account. If you don\u2019t have one, you can create one, the free plan is sufficient. Create a virtual machine. Select an AMI . We strongly recommend using Ubuntu Server 20.04 LTS (HVM), SSD Volume Type Choose instance type t2.micro 1vcpus and 1GiB and click on review and launch Create a new ssh key and download it on your local machine. The key file\u2019s format is .pem Now you need to copy your scripts/files from your local computer onto your AWS instance. To do that you need to connect to your instance by using the ssh key and your public DNS. You can find the DNS of your instance by selecting your instance and looking at the summary First you need to make sure your key is not publicly available on your machine. Run the following command chmod 400 path_to/mykey.pem","title":"Step 1: Set up an instance"},{"location":"cloud-service-guide/#step-2-upload-relevant-files-onto-the-instance","text":"To copy a file into your AWS instance please run the equivalent command (with your own information) scp -i path_to_ssh_key.pem path_to_file username@public_DNS:/path_to_copy The username can be found after clicking on connect. The default username will depend on the instance platform you are using. If you are using Linux, \u201cubuntu\u201d will be the default username. Additionally we recommend copying your files into the home directory of your instance /home/ubuntu . Here is an example of command scp -i Desktop/mykey.pem myscript.py ubuntu@ec2-18-188-221-121.us-east-2.compute.amazonaws.com:/home/ubuntu/","title":"Step 2: Upload relevant files onto the instance"},{"location":"cloud-service-guide/#step-3-connect-to-the-instance","text":"Once you have copied all necessary files onto you AWS instance you can connect to your instance with 2 ways Directly with the AWS terminal cli that you can access by clicking on connect on your EC2 instance connect With your local terminal cli (recommended) To connect to your instance from your local terminal you just need to run the following command with your equivalent information ssh -i path_to/mykey.pem username@public_DNS Example ssh -i Desktop/mykey.pem ubuntu@ec2-18-188-221-121.us-east-2.compute.amazonaws.com Once connected, go into the directory you have previously sent your files. If you have copied them in /home/ubuntu , just run the following command cd /home/ubuntu You can list all the files in the directory, to confirm that your files are correctly copied onto the instance by running ls","title":"Step 3: Connect to the instance"},{"location":"cloud-service-guide/#step-4-initialize-the-instances-environment-and-install-grid-singularity-client","text":"Update and install all required package on your AWS instance Update your sudo sudo apt update Install python3 pip sudo apt install python3-pip Add deadnakes to your system source sudo add-apt-repository ppa:deadsnakes/ppa Install python 3.6 sudo apt-get install python3.6 Install virtual environment sudo apt install python3-virtualenv Create a virtual environment with python 3.6 virtualenv /tmp/d3a --python=/usr/bin/python3.6 Activate your virtual environment source /tmp/d3a/bin/activate Install d3a api client pip3 install git+https://github.com/gridsingularity/d3a-api-client.git","title":"Step 4: Initialize the instance's environment and install Grid Singularity Client"},{"location":"cloud-service-guide/#step-5-install-screen-and-run-the-api-agent","text":"To be able to run the script indefinitely on your AWS instance you need to install Linux Screen (that allows to have multiple screen within your terminal) with the following command sudo apt-get install screen Create a new screen screen -S screen_name Run your python script python3 assets.py To detach from the current screen session Ctr+a+d If you want to log back in the relevant screen run screen -r screen_name Once you are detached for the running screen you are able to close your terminal and your script will continue to run indefinitely on your AWS instance","title":"Step 5: Install screen and run the API agent"},{"location":"collaboration/","text":"Note: Collaborations are only available at Grid Singularity\u2019s previous interface (d3a .io ) at the moment, and we will update this document as soon as the tool is migrated to the new interface. Collaboration is a type of simulation in the Grid Singularity user interface that allows multiple users to participate in the same environment. They can act in a collaborative or competitive way, aiming to optimize specific metrics, for instance the cost of energy bill or peak congestion. Users can connect through the Grid Singularity API to actively engage in the collaboration, assuming one of the following roles: Exchange Operator \u00b6 The exchange operator (EO) is responsible for building the digital twin representation of the electrical grid, including energy assets and (sub)markets. Once the setup is complete, the EO facilitates the approval of other users to register to manage a set of (sub)markets and energy assets, and subsequently launches the collaboration. The EO is also in charge of expanding the grid (see events ) or registering new energy assets in the course of a simulated collaboration. Grid Operator \u00b6 The grid operator role is designed specifically for Distribution System Operators (DSOs), Distribution Network Operators (DNOs), Independent System Operators (ISOs) and Transmission System Operators (TSOs), which can register to manage different (sub)markets, on different grid levels in the collaboration. Once registered and approved by the EO, they can manage the relevant markets by using the Grid Operator API to change grid fees to manage the grid congestion in the local energy market by optimizing specific metrics, such as peak percentage. Aggregator \u00b6 The aggregator role is designed for aggregator companies participating in the Grid Singularity Exchange. Aggregators can apply to manage energy assets (Load i.e. energy consumption , PV and Storage i.e. batteries ) owned by communities, consumers, producers and prosumers. Once approved by the Exchange Operator, aggregators are responsible for buying and selling energy on behalf of their customers by connecting their energy assets with set trading preferences through the Asset API . To create a Collaboration in the Grid Singularity user interface, follow these steps: Log-in to Grid Singularity Exchange (as noted, the full functionality is still available only via our previous interface: d3a.io) with your Grid Singularity credentials to automatically access previously created simulations. Select the simulation that you want to set up as a Collaboration by clicking on Edit \u2192 Create a Collaboration . If you have not yet created a simulation or want to create a new one, please follow the instructions here . Currently, this step is managed manually. A personal account of an external user does not have the admin rights to create a Collaboration. We are currently working on automating the functionalities of a Collaboration (i.e., connection with API). Please contact us at contact@gridsingularity.com for technical support and provide us with the following information: Your Name Grid Singularity account email address Company name Location of the community Size of the community (number of participants, assets) Current utility / grid operator Purpose of the Collaboration Simulation URL The simulation URL should look like this at the moment:","title":"Create a Grid Singularity Collaboration"},{"location":"collaboration/#exchange-operator","text":"The exchange operator (EO) is responsible for building the digital twin representation of the electrical grid, including energy assets and (sub)markets. Once the setup is complete, the EO facilitates the approval of other users to register to manage a set of (sub)markets and energy assets, and subsequently launches the collaboration. The EO is also in charge of expanding the grid (see events ) or registering new energy assets in the course of a simulated collaboration.","title":"Exchange Operator"},{"location":"collaboration/#grid-operator","text":"The grid operator role is designed specifically for Distribution System Operators (DSOs), Distribution Network Operators (DNOs), Independent System Operators (ISOs) and Transmission System Operators (TSOs), which can register to manage different (sub)markets, on different grid levels in the collaboration. Once registered and approved by the EO, they can manage the relevant markets by using the Grid Operator API to change grid fees to manage the grid congestion in the local energy market by optimizing specific metrics, such as peak percentage.","title":"Grid Operator"},{"location":"collaboration/#aggregator","text":"The aggregator role is designed for aggregator companies participating in the Grid Singularity Exchange. Aggregators can apply to manage energy assets (Load i.e. energy consumption , PV and Storage i.e. batteries ) owned by communities, consumers, producers and prosumers. Once approved by the Exchange Operator, aggregators are responsible for buying and selling energy on behalf of their customers by connecting their energy assets with set trading preferences through the Asset API . To create a Collaboration in the Grid Singularity user interface, follow these steps: Log-in to Grid Singularity Exchange (as noted, the full functionality is still available only via our previous interface: d3a.io) with your Grid Singularity credentials to automatically access previously created simulations. Select the simulation that you want to set up as a Collaboration by clicking on Edit \u2192 Create a Collaboration . If you have not yet created a simulation or want to create a new one, please follow the instructions here . Currently, this step is managed manually. A personal account of an external user does not have the admin rights to create a Collaboration. We are currently working on automating the functionalities of a Collaboration (i.e., connection with API). Please contact us at contact@gridsingularity.com for technical support and provide us with the following information: Your Name Grid Singularity account email address Company name Location of the community Size of the community (number of participants, assets) Current utility / grid operator Purpose of the Collaboration Simulation URL The simulation URL should look like this at the moment:","title":"Aggregator"},{"location":"community-settings/","text":"Users can configure the overall settings for their communities by selecting the blue dot on the circle surrounding their energy community on the Singularity Map. Figure 2.14 : Map view of community settings. Community Configuration Options \u00b6 Express Mode \u00b6 The express tab includes basic settings of the simulated local energy community: name, currency and simulation length, as shown in the figure and explained in more detail below. Figure 2.15 : Community market express mode settings in the Grid Singularity Exchange web-based interface (Singularity Map) Name: select a unique name for the community Currency: select the currency used by the community Simulation Length: select the length of time for the simulation, as well as corresponding dates; by default, simulations are set to run for one week starting from the current date. If uploading own data, set the simulation length, start date and end date according to the used profile Show community on the Grid Singularity web-based interface (Singularity Map): choose whether the simulated community will be publicly visible. If visible, the name, approximate location (circle outline) and simulation results will be available for anyone to see. This information will be kept private to the user if the user selects otherwise Advanced Mode \u00b6 In the advanced tab, there are settings referring to the market type information as shown in the figure and explained in more detail below. Figure 2.15 : Community market advanced mode settings in the Grid Singularity Exchange web-based interface (Singularity Map) Description: add an optional description of the simulated community Spot market type: select either the one-sided or the two-sided market type In the One-Sided Pay-as-Offer spot market , agents representing energy producers, including prosumers (sellers), post offers in the market with an energy price determined by the assets' trading strategy In the two-sided spot market, where buyers are able to place bids in the market alongside the offers placed by sellers, users can choose the Two-Sided Pay-as-Bid Market or the Two-Sided Pay-as-Clear Market Matching algorithm: select pay-as-bid, pay-as-clear or an external trading algorithm Spot markets number: set the number of active spot markets where the energy assets represented by trading agents can trade Spot market length: set the length of the spot market in minutes Tick length: set the length of ticks in seconds Grid fees: if switched on, select one of two grid fee types: Constant grid fee or Percentage grid fee and enter a value in cents/kWh or % depending on the selected option Market slot real time duration: set the desired market slot duration (default is 0s)","title":"Community Settings"},{"location":"community-settings/#community-configuration-options","text":"","title":"Community Configuration Options"},{"location":"community-settings/#express-mode","text":"The express tab includes basic settings of the simulated local energy community: name, currency and simulation length, as shown in the figure and explained in more detail below. Figure 2.15 : Community market express mode settings in the Grid Singularity Exchange web-based interface (Singularity Map) Name: select a unique name for the community Currency: select the currency used by the community Simulation Length: select the length of time for the simulation, as well as corresponding dates; by default, simulations are set to run for one week starting from the current date. If uploading own data, set the simulation length, start date and end date according to the used profile Show community on the Grid Singularity web-based interface (Singularity Map): choose whether the simulated community will be publicly visible. If visible, the name, approximate location (circle outline) and simulation results will be available for anyone to see. This information will be kept private to the user if the user selects otherwise","title":"Express Mode"},{"location":"community-settings/#advanced-mode","text":"In the advanced tab, there are settings referring to the market type information as shown in the figure and explained in more detail below. Figure 2.15 : Community market advanced mode settings in the Grid Singularity Exchange web-based interface (Singularity Map) Description: add an optional description of the simulated community Spot market type: select either the one-sided or the two-sided market type In the One-Sided Pay-as-Offer spot market , agents representing energy producers, including prosumers (sellers), post offers in the market with an energy price determined by the assets' trading strategy In the two-sided spot market, where buyers are able to place bids in the market alongside the offers placed by sellers, users can choose the Two-Sided Pay-as-Bid Market or the Two-Sided Pay-as-Clear Market Matching algorithm: select pay-as-bid, pay-as-clear or an external trading algorithm Spot markets number: set the number of active spot markets where the energy assets represented by trading agents can trade Spot market length: set the length of the spot market in minutes Tick length: set the length of ticks in seconds Grid fees: if switched on, select one of two grid fee types: Constant grid fee or Percentage grid fee and enter a value in cents/kWh or % depending on the selected option Market slot real time duration: set the desired market slot duration (default is 0s)","title":"Advanced Mode"},{"location":"community/","text":"The Singularity Map is an interactive Grid Singularity Exchange simulation platform where users can model and simulate digital twins (digital representations) of local energy markets (LEM or energy communities). Modelling is performed by adding homes, representing households or other LEM participants, and the respective energy assets, such as consumption load profiles, solar panels (PVs), heat pumps and / or storages (batteries), which are digitally represented by trading agents. For more, see Grid Singularity\u2019s Technical Approach . Figure 2.1 : The Singularity Map - Grid Singularity Exchange web-based interface at https://map.gridsingularity.com/singularity-map. The map includes a search bar in the top left corner, a list of simulations in the extendable panel below the search bar, user icons on the right hand side of the screen (explained below) and coloured dots representing different simulations on the map. Icons This icon allows the user to reorient their view of the map to the standard north-facing direction. These icons allow users to zoom in and out of the map. This icon allows access to the user's location. These icons allow users a change of view between birds eye view (straight down/2D) and 3D. This icon allows the user to see their assets in a list view and to click on the items in the list in order to navigate the map and results views This icon allows the user to request upgrading their simulation to Grid Singularity\u2019s Canary Test Network , which is a paid service. Legend Figure 2.2 : Legend explaining colouring indicating net energy import / export of simulated energy communities in the Singularity Map, Grid Singularity Exchange simulation interface. The coloured dots on the map represent energy community simulations. The legend is found in the top right corner of the page. \ud83d\udfe2 Green dots are communities that have a net export of energy; \ud83d\udd34 Red dots are communities that have a net import of energy; \ud83d\udd35 Blue dots are communities that have a neutral energy balance (neither net import/export) or communities that have been configured but not yet simulated. User Profile Configuration By clicking on the icon in the top right corner next to \u201cRun Simulation\u201d, users can see their profile, edit their password, and change their profile picture by clicking on the image and uploading a file from their computer (as shown in the picture below). Figure 2.3 : User profile in the Singularity Map, Grid Singularity Exchange simulation interface Configuring an Energy Community To configure an energy community to perform a simulation, the user should take the following steps: elect location for the simulated community, either by manually navigating the map or by typing the location in the search bar; Add homes (representing households or other community members) and the relevant information relating to their energy assets (described in more detail below under Community Assets Configuration ). Register or log in to your account, making sure that you understand and accept the Terms of Service . Name the community, set the currency and the simulation period, as well as relevant market settings, such as pricing, the trading mechanism and grid market settings (described in more detail below under Community Market Settings ) and save the configured information. Run the simulation for each selected period and analyse the results (note: a community must have at least two homes before it can be saved and local energy trading simulated). A guided onboarding of the community configuration process launches automatically in the top right-hand side of the screen when the user clicks on the Build Community icon in the top right corner. Figure 2.4 : Build Community icon in the Grid Singularity Exchange web-based interface (Singularity Map). Figure 2.5 : Guided onboarding feature in the Grid Singularity Exchange web-based interface (Singularity Map). This feature can be shown/hidden by clicking on the interrogation green icon at the top of the icon list on the right-hand side of the screen: This icon and feature only appear after a user has selected the community location and clicked on the first button to start building a community. Figure 2.6 : The first button a user selects to start building a community in the Grid Singularity Exchange web-based interface (Singularity Map)","title":"Build a community"},{"location":"configuration/","text":"There are four different types of energy assets a user can currently configure when modelling energy communities on Grid Singularity\u2019s web-based simulation user interface, the Singularity Map - solar panels (PVs) , consumption (load) profiles and batteries (storages) . Each simulated community can consist of at least two participating members (homes representing households, buildings or other community members) and up to 1000 digital agents representing assets and/or homes. Simulation users can model an energy community quickly by adding template homes and assets using the express options, or they can configure the technical details and trading parameters by exploring the advanced options for each asset. Each asset within a community can trade energy with other assets, as well as with the external suppliers via grid network (also termed the grid market). By default, assets shall buy/sell energy locally, interacting with their neighbours, and only in case of any gaps in the local market (either caused by insufficient energy production / consumption in the community, or by inefficient or not affordable trading settings), purchase the energy from the external energy supplier (usually a utility). Trading occurs in market slots , which are by default 15-minute time slots in which energy assets can exchange energy at market rates. The market slot length can be changed by a user to reflect the spot market length of any region of the world. Users can set custom market rates based on a smart trading algorithm that can be applied to any asset, or use default rates when adding assets to their communities, with the latter conditioned upon the provided Market Maker (utility) rate and any applicable feed-in-tariff.","title":"Assets Configuration Overview"},{"location":"configure-trading-strategies-walkthrough/","text":"The Grid Singularity Asset API is designed for aggregators (energy service providers) who wish to provide their customers (individuals and communities) with benefits of peer-to-peer and community trading facilitated by the Grid Singularity Exchange. They can create agents that follow custom trading strategies to buy and sell energy in the energy market on behalf of managed energy assets. The agent can request and receive information through the Asset API, feed that information into an algorithm, and post bids or offers on the exchange. To actively place bids and offers on behalf of energy assets, please follow these steps: Install the Grid Singularity Exchange SDK on your computer by launching the following commands on your terminal window: Install gsy-e-sdk mkvirtualenv gsy-e-sdk pip install https://github.com/gridsingularity/gsy-e-sdk.git Update gsy-e-sdk (needed when an update is deployed) pip uninstall -y gsy-e-sdk pip install git+https://github.com/gridsingularity/gsy-e-sdk.git Go to the Registry section of the Collaboration of your interest and apply for each asset you wish to connect to manage their trading strategies by clicking on the asset or home. Then click on the green Apply button. If you have not already created a Collaboration / Canary Test Network or users are not yet registered for their assets, please follow instructions respectively here or here first. Figure 5.2 : View of the connection overview. Notify Grid Singularity administration by sending an email to contact@gridsingularity.com to accept your applications (note: this action will be automated in the future). Figure 5.3 : View of the connection overview for the admin Edit the Asset SDK Script template developed by Grid Singularity to customize the trading strategies. Launch the Asset SDK Script to connect with the Grid Singularity Collaboration / Canary Test Network. A video tutorial is also available here . Run the Collaboration or notify Grid Singularity that you are ready.","title":"Grid Singularity Asset API Overview"},{"location":"connect-ctn/","text":"The Grid Singularity Canary Test Network, inspired by the \u201ccanary in a coal mine\u201d, is designed to test new ideas while operating in conditions as close as possible to reality. Energy assets, managed by aggregators, send their actual energy usage through the Asset API each 15 minutes (or another specified timeframe depending on the determined spot market length) and the exchange operates in real-time to facilitate local energy markets. However, the network does not represent actual energy and financial transactions because the assets\u2019 virtual representations (digital twins) are decoupled in state from their physical (e.g. a battery\u2019s digital twin might have a different state of charge in simulation vs. reality). To create a Grid Singularity Canary Test Network, follow these steps (a video tutorial is also available here ): Select the Simulation that you want to set up as a Canary Test Network. Once your simulation has completed, click on settings, and click Go in the box that says, \u201cbring your simulation closer to reality\u201d. A Grid Singularity agent will be in touch with you shortly after to lead you through setting up a Canary Network. Currently, this step requires manual Grid Singularity intervention. A personal account of an external user does not have the admin rights to create a Canary Test Network. If you have any questions, please contact us at contact@gridsingularity.com for technical support and provide us with the following: Your Name Grid Singularity account email address Company name Location of the community Size of the community (number of participants, assets) Energy Supplier / grid operator Purpose of the canary network Simulation name Once Grid Singularity has approved your request, follow the steps below: With the creation of a Canary Network, a Registry tab has been added next to settings in the sidebar. Each homeowner or asset owner can be assigned to a home and invited to participate in the Canary Network by email through the Add More People invitation tool by the Canary Network owner. Once they accept the emailed invitation, they will be able to view the simulation and their assets through the Registry . The Canary Network owner can also set User Roles for each user. Invited people default to GSy User , allowing them to view and analyze results for their owned assets. Aggregators must login and register to trade on behalf of each asset on the Community Assets tab. Once their registration is accepted by the simulation owner, they can trade on behalf of assets through the Asset API . The Grid Operator, once registered, has access to manage grid fees and network congestion through the Grid Operator API . Connect live data streams to the energy exchange (see section below ).","title":"Connect to a Grid Singularity Canary Test Network"},{"location":"connection-energy-assets/","text":"Send live energy asset data streams to the Grid Singularity exchange \u00b6 Once the Grid Singularity Canary Test Network is created, you need to send the live data stream from your community energy assets to the Grid Singularity exchange by establishing a connection from your hardware\u2019s data service through the Grid Singularity Asset API . Please make sure to satisfy all the data requirements (check here ) in order to connect live data streams to the Canary Network. Enable Live Asset data on the User Interface \u00b6 On the map, the Canary Network owner can click on the home and the asset they\u2019d like to connect live data to. In the Advanced Settings tab, the live data switch can be toggled so the checkmark is highlighted. Once this step and the one below is completed ( Establish a connection with your energy assets ), the real energy data will be represented for those assets in the results in the UI. Note that if live data is turned off, data will be read through the uploaded profiles instead of reading data sent through the Asset API. Establish a connection with your energy assets \u00b6 It is possible to connect and register automatically to a running Canary Network: User-Interface (gridsingularity.com; please note that the energy asset uuid has to be obtained first for this option) \u00b6 asset_uuid = get_area_uuid_from_area_name_and_collaboration_id( <simulation_id>, <asset_name>, <domain_name> ) asset_client = RestAssetClient(asset_uuid, autoregister=True) Backend simulation \u00b6 asset_client = RedisAssetClient(<asset-uuid>, autoregister=True) Otherwise, it is also possible to connect manually by doing: asset_client.register() To disconnect/unregistering, the following command is available: asset_client.unregister() There are two options for you to connect live data streaming to the Grid Singularity Exchange: Exchange SDK (recommended, python-based agents) REST API (for non-python trading agents)","title":"Establish a connection with your energy assets"},{"location":"connection-energy-assets/#send-live-energy-asset-data-streams-to-the-grid-singularity-exchange","text":"Once the Grid Singularity Canary Test Network is created, you need to send the live data stream from your community energy assets to the Grid Singularity exchange by establishing a connection from your hardware\u2019s data service through the Grid Singularity Asset API . Please make sure to satisfy all the data requirements (check here ) in order to connect live data streams to the Canary Network.","title":"Send live energy asset data streams to the Grid Singularity exchange"},{"location":"connection-energy-assets/#enable-live-asset-data-on-the-user-interface","text":"On the map, the Canary Network owner can click on the home and the asset they\u2019d like to connect live data to. In the Advanced Settings tab, the live data switch can be toggled so the checkmark is highlighted. Once this step and the one below is completed ( Establish a connection with your energy assets ), the real energy data will be represented for those assets in the results in the UI. Note that if live data is turned off, data will be read through the uploaded profiles instead of reading data sent through the Asset API.","title":"Enable Live Asset data on the User Interface"},{"location":"connection-energy-assets/#establish-a-connection-with-your-energy-assets","text":"It is possible to connect and register automatically to a running Canary Network:","title":"Establish a connection with your energy assets"},{"location":"connection-energy-assets/#user-interface-gridsingularitycom-please-note-that-the-energy-asset-uuid-has-to-be-obtained-first-for-this-option","text":"asset_uuid = get_area_uuid_from_area_name_and_collaboration_id( <simulation_id>, <asset_name>, <domain_name> ) asset_client = RestAssetClient(asset_uuid, autoregister=True)","title":"User-Interface (gridsingularity.com; please note that the energy asset uuid has to be obtained first for this option)"},{"location":"connection-energy-assets/#backend-simulation","text":"asset_client = RedisAssetClient(<asset-uuid>, autoregister=True) Otherwise, it is also possible to connect manually by doing: asset_client.register() To disconnect/unregistering, the following command is available: asset_client.unregister() There are two options for you to connect live data streaming to the Grid Singularity Exchange: Exchange SDK (recommended, python-based agents) REST API (for non-python trading agents)","title":"Backend simulation"},{"location":"constant-fees/","text":"The constant grid fee is a market based fee, defined in \u20ac/kWh and added to each trade that is cleared, as shown in the figure below. Figure 4.15 : Constant grid fee calculation in the Grid Singularity Exchange. The rate of a bid or offer changes as that bid or offer is propagated into different markets. The offer rate increases to account for the added fees for the relevant market, ensuring that the seller receives a revenue equal or greater than the original offer. The bid rate decreases for the same reason. Example Calculation in One-Sided Pay-as-Offer Market \u00b6 Figure 4.16 : Constant Grid Fee Example Calculation in One-Sided Pay-as-Offer Market. In an One-Sided Pay-as-Offer market, there are no bids, only offers. Offers are propagated throughout the markets in the hierarchy shown in the figure above. Grid fees are accounted for when an offer is forwarded to the higher market, adding that market\u2019s grid fees to any previously accumulated fees. The formula to calculate the new offer rate when placing an offer to a higher market is the following: offer_rate_after_fees (\u20ac/kWh) = offer_rate (\u20ac/kWh) + grid_fee (\u20ac/kWh) If the offer is not purchased after two ticks , it is moved into the next market, with the total rate incremented by the amount of that market's grid fee. In the example above, the PV offer of 0.10 \u20ac/kWh is first placed into the House 2 Market where it gains zero fees. Then it moves into the Neighborhood 2 Market, gaining a fee of 0.01 \u20ac/kWh to become 0.11 \u20ac/kWh. Then, if not purchased, it moves into the Grid Market, gaining a fee of 0.02 \u20ac/kWh to become 0.13 \u20ac/kWh. Continuing into the Neighborhood 1 Market, the offer gains a fee of 0.01 \u20ac/kWh to become 0.14 \u20ac/kWh. Continuing into the House 1 Market, the offer gains zero fees. The Load ultimately buys the offer in the House 1 Market at the Clearing Rate of 0.14 \u20ac/kWh. The trade price is calculated by adding the original offer rate ( 0.10 \u20ac/kWh ) and the total fees ( (0.01+0.02+0.01) = 0.04 \u20ac/kWh ), then multiplying by the amount of energy traded ( 1 kWh ) to yield the Trade Price of 0.14\u20ac. The Load pays the Trade Price of 0.14\u20ac, which includes 0.10\u20ac revenue for the PV, 0.01\u20ac fees for the Neighborhood Market 1, 0.02\u20ac fees for the Grid Market, and 0.01\u20ac fees for the Neighborhood Market 2. Since the market type is pay-as-offer, the offer rate is used as the clearing rate. The grid fees are added to the offer rate to determine the trade rate and therefore the trade price in each market. The following formula is used: supply_side_fee (\u20ac/kWh) = forwarded_offer_rate (\u20ac/kWh) - original_offer_rate (\u20ac/kWh) trade_rate (\u20ac/kWh) = clearing rate (\u20ac/kWh) trade_price (\u20ac) = energy (kWh) * trade_rate (\u20ac/kWh) For the provided example, the trade price for each market is: Market_trade_price (\u20ac) = (original_offer_rate (\u20ac/kWh) + supply_side_fee (\u20ac/kWh)) * energy (kWh) Grid Market = (0.10 + 0.03)*1 = 0.13 Neighborhood 2 Market = (0.10 + 0.01)*1 = 0.11 Neighborhood 1 Market = (0.10 + 0.04)*1 = 0.14 House 1 Market = (0.10 + 0.04)*1 = 0.14 House 2 Market = (0.10 + 0)*1 = 0.10 Example Calculation in Two-Sided Pay-as-Bid Market \u00b6 Figure 4.17 : Constant Grid Fee Example Calculation in Two-Sided Pay-as-Bid Market. In the Two-Sided Pay-as-Bid market, there are both bids and offers, and both are propagated through the markets in the hierarchy. If a bid or offer is not matched after two ticks , it is moved into the next market. In order to prevent the double accounting of a market's grid fee when a bid and an offer are matched in that market, market fees are added to offers when they enter a new market (target market), and they are subtracted from bids when they leave a market (source market) and enter another one. The formula for propagating the offers is the same as for the one-sided market : offer_rate_after_fees (\u20ac/kWh) = offer_rate (\u20ac/kWh) + grid_fee (\u20ac/kWh) The IAA subtracts the fees from the bid before propagating the bid to the higher market, based on the following formula: bid_rate_after_fees (\u20ac/kWh) = bid_rate (\u20ac/kWh) - grid_fee (\u20ac/kWh) In the case of a Two-Sided Pay-as-Bid market, the offer is moved into the Grid Market by the same mechanism as in the One-Sided Pay-as-Offer market. The bid of 0.30 \u20ac/kWh is placed into the House 1 Market where there are zero fees. If it is not purchased after two ticks, it is moved into the Neighborhood 1 Market. As explained above, only the fees from the source market are added, which are zero in this case. Hence the bid rate remains 0.30 \u20ac/kWh. Next, the bid is moved into the Grid Market, where its value is reduced by the amount of the fees of its source market, the Neighborhood 1 Market at 0.01 \u20ac/kWh, resulting in a rate of 0.29 \u20ac/kWh as it enters the Grid Market. In the example above, the bid and offer are matched in the Grid Market. When the offer entered the Grid Market, its rate was immediately updated to account for the Grid Market fees (0.11 + 0.02). The bid was not updated, and if it was not matched in the Grid Market and moved to the Neighborhood 2 Market, the 0.02 \u20ac/kWh fee from the Grid Market would be subtracted to become (0.29 - 0.02) 0.27 \u20ac/kWh. The fees from the Neighborhood 2 Market would not be added to the bid unless it entered the House 2 Market (fees added according to the source market). In the Grid Market, the Load bid rate is listed as 0.29 \u20ac/kWh and the PV offer as 0.13 \u20ac/kWh. As the bid\u2019s rate is greater than the offer\u2019s rate, a trade can be scheduled. The trade clears at the bid\u2019s rate, resulting in a Clearing Rate of 0.29 \u20ac/kWh. The Grid Singularity energy exchange engine includes an algorithm that calculates the grid fee according to the clearing rate, basing the calculation on the original bid and offer rates. This allows the markets to act more independently and in a decentralized manner, without having to share information regarding their fees with other markets. The algorithm formula is as follows: demand_side_fee (\u20ac/kWh) = original_bid_rate (\u20ac/kWh) - forwarded_bid_rate (\u20ac/kWh) supply_side_fee (\u20ac/kWh) = forwarded_offer_rate (\u20ac/kWh) - original_offer_rate (\u20ac/kWh) For the example, we have the following values: supply_side_fee = 0.13 - 0.10 = 0.03 \u20ac/kWh demand_side_fee = 0.30 - 0.29 = 0.01 \u20ac/kWh After calculating the supply and demand side fee, the trade revenue can be calculated. Note the original_trade_rate is the amount that the original buyer (in our case the Load) will need to pay, therefore in the Pay-as-Bid market type this is the original bid price. The formula is the following: total_fee (\u20ac/kWh) = supply_side_fee (\u20ac/kWh) + demand_side_fee (\u20ac/kWh) revenue_rate (\u20ac/kWh) = original_trade_rate (\u20ac/kWh) - total_fee (\u20ac/kWh) For the example, the revenue will be: revenue = 0.30 - 0.04 = 0.26 \u20ac/kWh Finally, the trade rate is adapted according to the supply side fee, in order to include the fees of the current market: trade_rate (\u20ac/kWh) = revenue_rate (\u20ac/kWh) + supply_side_fee (\u20ac/kWh) trade_price (\u20ac) = energy (kWh) * trade_rate (\u20ac/kWh) For our example, the trade price for each market is: Market_trade_price (\u20ac) = (revenue_rate (\u20ac/kWh) + supply_side_fee (\u20ac/kWh)) * energy (kWh) Grid Market = (0.26 + 0.03)*1 = 0.29, Neighborhood 2 Market = (0.26 + 0.01)*1 = 0.27, Neighborhood 1 Market = (0.26 + 0.04)*1 = 0.30, House 1 Market = (0.26 + 0.04)*1 = 0.30, House 2 Market = (0.26 + 0)*1 = 0.26. The Load pays the Trade Price of 0.30\u20ac, which includes 0.26\u20ac revenue for the PV, 0.01\u20ac fees for Neighborhood Market 1, 0.02\u20ac fees for the Grid Market, and 0.01\u20ac fees for the Neighborhood Market 2.","title":"Constant Grid Fee Calculation"},{"location":"constant-fees/#example-calculation-in-one-sided-pay-as-offer-market","text":"Figure 4.16 : Constant Grid Fee Example Calculation in One-Sided Pay-as-Offer Market. In an One-Sided Pay-as-Offer market, there are no bids, only offers. Offers are propagated throughout the markets in the hierarchy shown in the figure above. Grid fees are accounted for when an offer is forwarded to the higher market, adding that market\u2019s grid fees to any previously accumulated fees. The formula to calculate the new offer rate when placing an offer to a higher market is the following: offer_rate_after_fees (\u20ac/kWh) = offer_rate (\u20ac/kWh) + grid_fee (\u20ac/kWh) If the offer is not purchased after two ticks , it is moved into the next market, with the total rate incremented by the amount of that market's grid fee. In the example above, the PV offer of 0.10 \u20ac/kWh is first placed into the House 2 Market where it gains zero fees. Then it moves into the Neighborhood 2 Market, gaining a fee of 0.01 \u20ac/kWh to become 0.11 \u20ac/kWh. Then, if not purchased, it moves into the Grid Market, gaining a fee of 0.02 \u20ac/kWh to become 0.13 \u20ac/kWh. Continuing into the Neighborhood 1 Market, the offer gains a fee of 0.01 \u20ac/kWh to become 0.14 \u20ac/kWh. Continuing into the House 1 Market, the offer gains zero fees. The Load ultimately buys the offer in the House 1 Market at the Clearing Rate of 0.14 \u20ac/kWh. The trade price is calculated by adding the original offer rate ( 0.10 \u20ac/kWh ) and the total fees ( (0.01+0.02+0.01) = 0.04 \u20ac/kWh ), then multiplying by the amount of energy traded ( 1 kWh ) to yield the Trade Price of 0.14\u20ac. The Load pays the Trade Price of 0.14\u20ac, which includes 0.10\u20ac revenue for the PV, 0.01\u20ac fees for the Neighborhood Market 1, 0.02\u20ac fees for the Grid Market, and 0.01\u20ac fees for the Neighborhood Market 2. Since the market type is pay-as-offer, the offer rate is used as the clearing rate. The grid fees are added to the offer rate to determine the trade rate and therefore the trade price in each market. The following formula is used: supply_side_fee (\u20ac/kWh) = forwarded_offer_rate (\u20ac/kWh) - original_offer_rate (\u20ac/kWh) trade_rate (\u20ac/kWh) = clearing rate (\u20ac/kWh) trade_price (\u20ac) = energy (kWh) * trade_rate (\u20ac/kWh) For the provided example, the trade price for each market is: Market_trade_price (\u20ac) = (original_offer_rate (\u20ac/kWh) + supply_side_fee (\u20ac/kWh)) * energy (kWh) Grid Market = (0.10 + 0.03)*1 = 0.13 Neighborhood 2 Market = (0.10 + 0.01)*1 = 0.11 Neighborhood 1 Market = (0.10 + 0.04)*1 = 0.14 House 1 Market = (0.10 + 0.04)*1 = 0.14 House 2 Market = (0.10 + 0)*1 = 0.10","title":"Example Calculation in One-Sided Pay-as-Offer Market"},{"location":"constant-fees/#example-calculation-in-two-sided-pay-as-bid-market","text":"Figure 4.17 : Constant Grid Fee Example Calculation in Two-Sided Pay-as-Bid Market. In the Two-Sided Pay-as-Bid market, there are both bids and offers, and both are propagated through the markets in the hierarchy. If a bid or offer is not matched after two ticks , it is moved into the next market. In order to prevent the double accounting of a market's grid fee when a bid and an offer are matched in that market, market fees are added to offers when they enter a new market (target market), and they are subtracted from bids when they leave a market (source market) and enter another one. The formula for propagating the offers is the same as for the one-sided market : offer_rate_after_fees (\u20ac/kWh) = offer_rate (\u20ac/kWh) + grid_fee (\u20ac/kWh) The IAA subtracts the fees from the bid before propagating the bid to the higher market, based on the following formula: bid_rate_after_fees (\u20ac/kWh) = bid_rate (\u20ac/kWh) - grid_fee (\u20ac/kWh) In the case of a Two-Sided Pay-as-Bid market, the offer is moved into the Grid Market by the same mechanism as in the One-Sided Pay-as-Offer market. The bid of 0.30 \u20ac/kWh is placed into the House 1 Market where there are zero fees. If it is not purchased after two ticks, it is moved into the Neighborhood 1 Market. As explained above, only the fees from the source market are added, which are zero in this case. Hence the bid rate remains 0.30 \u20ac/kWh. Next, the bid is moved into the Grid Market, where its value is reduced by the amount of the fees of its source market, the Neighborhood 1 Market at 0.01 \u20ac/kWh, resulting in a rate of 0.29 \u20ac/kWh as it enters the Grid Market. In the example above, the bid and offer are matched in the Grid Market. When the offer entered the Grid Market, its rate was immediately updated to account for the Grid Market fees (0.11 + 0.02). The bid was not updated, and if it was not matched in the Grid Market and moved to the Neighborhood 2 Market, the 0.02 \u20ac/kWh fee from the Grid Market would be subtracted to become (0.29 - 0.02) 0.27 \u20ac/kWh. The fees from the Neighborhood 2 Market would not be added to the bid unless it entered the House 2 Market (fees added according to the source market). In the Grid Market, the Load bid rate is listed as 0.29 \u20ac/kWh and the PV offer as 0.13 \u20ac/kWh. As the bid\u2019s rate is greater than the offer\u2019s rate, a trade can be scheduled. The trade clears at the bid\u2019s rate, resulting in a Clearing Rate of 0.29 \u20ac/kWh. The Grid Singularity energy exchange engine includes an algorithm that calculates the grid fee according to the clearing rate, basing the calculation on the original bid and offer rates. This allows the markets to act more independently and in a decentralized manner, without having to share information regarding their fees with other markets. The algorithm formula is as follows: demand_side_fee (\u20ac/kWh) = original_bid_rate (\u20ac/kWh) - forwarded_bid_rate (\u20ac/kWh) supply_side_fee (\u20ac/kWh) = forwarded_offer_rate (\u20ac/kWh) - original_offer_rate (\u20ac/kWh) For the example, we have the following values: supply_side_fee = 0.13 - 0.10 = 0.03 \u20ac/kWh demand_side_fee = 0.30 - 0.29 = 0.01 \u20ac/kWh After calculating the supply and demand side fee, the trade revenue can be calculated. Note the original_trade_rate is the amount that the original buyer (in our case the Load) will need to pay, therefore in the Pay-as-Bid market type this is the original bid price. The formula is the following: total_fee (\u20ac/kWh) = supply_side_fee (\u20ac/kWh) + demand_side_fee (\u20ac/kWh) revenue_rate (\u20ac/kWh) = original_trade_rate (\u20ac/kWh) - total_fee (\u20ac/kWh) For the example, the revenue will be: revenue = 0.30 - 0.04 = 0.26 \u20ac/kWh Finally, the trade rate is adapted according to the supply side fee, in order to include the fees of the current market: trade_rate (\u20ac/kWh) = revenue_rate (\u20ac/kWh) + supply_side_fee (\u20ac/kWh) trade_price (\u20ac) = energy (kWh) * trade_rate (\u20ac/kWh) For our example, the trade price for each market is: Market_trade_price (\u20ac) = (revenue_rate (\u20ac/kWh) + supply_side_fee (\u20ac/kWh)) * energy (kWh) Grid Market = (0.26 + 0.03)*1 = 0.29, Neighborhood 2 Market = (0.26 + 0.01)*1 = 0.27, Neighborhood 1 Market = (0.26 + 0.04)*1 = 0.30, House 1 Market = (0.26 + 0.04)*1 = 0.30, House 2 Market = (0.26 + 0)*1 = 0.26. The Load pays the Trade Price of 0.30\u20ac, which includes 0.26\u20ac revenue for the PV, 0.01\u20ac fees for Neighborhood Market 1, 0.02\u20ac fees for the Grid Market, and 0.01\u20ac fees for the Neighborhood Market 2.","title":"Example Calculation in Two-Sided Pay-as-Bid Market"},{"location":"consumption/","text":"The load is an energy asset that consumes energy over time which is represented by a consumption profile. It is possible to use a single load digital twin to represent an entire building\u2019s consumption, as well as to configure multiple loads to represent different assets within a building (e.g. washing machine, air-conditioner, etc.). Singularity Map express mode users are provided with a selection of template (synthetic) consumption load profiles, modelled using data from Load Profile Generator . Users who want to upload their own consumption profile data can do so in the \u2018upload profile\u2019 section in the Custom Load advanced settings. Load Configuration Options: \u00b6 Express Mode \u00b6 In the express load configuration mode, the user is provided with a template (synthetic) custom load to include as an asset at a select location in the simulated local energy market by naming the asset and setting its location: Name: select a unique name for the load; Location: the location selected by the user is automatically uploaded; Advanced Mode \u00b6 In the advanced load configuration mode, the following settings are available as shown in the figure and explained below: Figure 2.12 : Consumption Load Profile Advanced Configuration Options in the Grid Singularity Exchange web-based interface (Singularity Map) Load profile type: select the user upload profile or the user configure profile: User upload profile allows users to upload data from their own consumption profile in the form of a csv file . User configure profile allows users to manually create a consumption profile by setting the load average consuming power in Watts, the number of hours the load operates per day and the time range in which the load operates (hours of day). The latter is used to model disaggregated consuming devices such as a TV, washing machine, boiler etc. Initial buying rate: set the initial energy buying rate for the beginning of each market slot in cents/kWh Final buying rate: set the final energy buying rate at the end of each market slot in cents/kWh by entering a custom value or the Market Maker rate Rate increase: enter a value for the explicit rate increase increment per update interval in cents/kWh Linear price increase: If activated, the rate increase per amount of time (update interval) is calculated automatically in a way that the price increases linearly over the market slot time. The rate is calculated starting at the Initial buying rate at the start of the market slot and ending at the Final buying rate at the end of the market slot, while updating the rate at each Update Interval: energy rate_increase = (final_buying_rate - initial_buying_rate) / max(int((slot_length / update_interval) -1), 1) Update interval: set the frequency at which the rate is updated.","title":"Consumption (Load) Profiles"},{"location":"consumption/#load-configuration-options","text":"","title":"Load Configuration Options:"},{"location":"consumption/#express-mode","text":"In the express load configuration mode, the user is provided with a template (synthetic) custom load to include as an asset at a select location in the simulated local energy market by naming the asset and setting its location: Name: select a unique name for the load; Location: the location selected by the user is automatically uploaded;","title":"Express Mode"},{"location":"consumption/#advanced-mode","text":"In the advanced load configuration mode, the following settings are available as shown in the figure and explained below: Figure 2.12 : Consumption Load Profile Advanced Configuration Options in the Grid Singularity Exchange web-based interface (Singularity Map) Load profile type: select the user upload profile or the user configure profile: User upload profile allows users to upload data from their own consumption profile in the form of a csv file . User configure profile allows users to manually create a consumption profile by setting the load average consuming power in Watts, the number of hours the load operates per day and the time range in which the load operates (hours of day). The latter is used to model disaggregated consuming devices such as a TV, washing machine, boiler etc. Initial buying rate: set the initial energy buying rate for the beginning of each market slot in cents/kWh Final buying rate: set the final energy buying rate at the end of each market slot in cents/kWh by entering a custom value or the Market Maker rate Rate increase: enter a value for the explicit rate increase increment per update interval in cents/kWh Linear price increase: If activated, the rate increase per amount of time (update interval) is calculated automatically in a way that the price increases linearly over the market slot time. The rate is calculated starting at the Initial buying rate at the start of the market slot and ending at the Final buying rate at the end of the market slot, while updating the rate at each Update Interval: energy rate_increase = (final_buying_rate - initial_buying_rate) / max(int((slot_length / update_interval) -1), 1) Update interval: set the frequency at which the rate is updated.","title":"Advanced Mode"},{"location":"data-requirements/","text":"Users who would like to model a local energy market (an energy community participating in peer-to-peer trading) in the Grid Singularity Exchange using their own data instead of the template (synthetic) data need to collect the following information, usually for at least one-month or one-week period in at least two seasons: Grid topology : a diagram or a brief description of the location of community members and their energy assets and/or any other available assets for community supply like wind turbines and community PV Energy assets specifications : Disaggregated data (not net metre) is recommended to efficiently connect and measure performance, provided ideally at 15-minute interval, as csv files (upload format described below) for each of the assets (if not available, home/building metre data can be provided) together with complementary information, as follows: Consumption (Load Profile) Name (can be anonymous, e.g. Load1) and location Energy consumed per time interval by each asset/home in kWh PV (Solar panel) Name (can be anonymous, e.g. PV1) and location Energy produced per time interval by each PV in kWh and/or PV capacity in kW, including tilt and azimuth Wind Name (can be anonymous, e.g. Wind1) and location Energy produced per time interval by each wind turbine in kWh Storage (Battery) Name (can be anonymous, e.g. Battery1) and location Capacity in kWh Power delivery in kW Maximum charge/discharge rate per time interval in kW Minimum SOC in % and/or actual SOC per time interval (optional) Heat Pumps Name (can be anonymous, e.g. HP1) and location Maximum power rating (based on nameplate) Volume of thermal storage tank if applicable (based on nameplate) Minimum and maximum comfort temperature Heat demand of the homes/building in kWh per time interval Heat pump water tank temperature (time series profile) Ambient temperature profile to configure the heat pump performance Grid Market Pricing Information Feed-in-tariff Conventional (utility) energy price (profile) per community member Grid tariffs (fixed value or profile) Market Mechanism Data: User, simulating the role of community manager, selects preferred buying and selling prices (default setting to buy at the best available price between utility and fee-in-tariff rate) based on a pay-as-bid mechanism (other mechanisms in development). For the upload format, Grid Singularity Exchange currently only supports Comma Separated Values files (.csv). Comma Separated Values (.csv) \u00b6 The separation can be done by comma , or semicolon ; . Two time formats are supported, see below. All entered csv data values need to be positive hh:mm \u00b6 Example: INTERVAL;ENERGY(kWh): 00:00;10 00:15;10 00:30;10 00:45;10 01:00;10 YYYY-MM-DDThh:mm \u00b6 Example: INTERVAL,ENERGY(kWh) 2019-01-01T00:00,10.0 2019-01-01T00:15,10.0 2019-01-01T00:30,10.0 2019-01-01T00:45,10.0 2019-01-01T01:00,10.0","title":"Data Requirements and File Upload Format"},{"location":"data-requirements/#comma-separated-values-csv","text":"The separation can be done by comma , or semicolon ; . Two time formats are supported, see below. All entered csv data values need to be positive","title":"Comma Separated Values (.csv)"},{"location":"data-requirements/#hhmm","text":"Example: INTERVAL;ENERGY(kWh): 00:00;10 00:15;10 00:30;10 00:45;10 01:00;10","title":"hh:mm"},{"location":"data-requirements/#yyyy-mm-ddthhmm","text":"Example: INTERVAL,ENERGY(kWh) 2019-01-01T00:00,10.0 2019-01-01T00:15,10.0 2019-01-01T00:30,10.0 2019-01-01T00:45,10.0 2019-01-01T01:00,10.0","title":"YYYY-MM-DDThh:mm"},{"location":"default-trading-strategy/","text":"Grid Singularity\u2019s exchange engine has a built-in template trading agent. The agent\u2019s trading strategy is deterministic . Each consumer asset will first try to buy energy at a low price and, if not cleared, the price will increase linearly during the market slot until a user-defined maximum is reached. In turn, assets generating energy will try to sell at a high price first and, if not cleared, reduce their rate linearly until a user-set minimum is reached. Offers\u2019 trading settings are as follows: initial_selling_rate final_selling_rate update_interval energy_rate_decrease_per_update fit_to_limit The following plot shows the changing energy rate in a spot market slot (slot_length = 15min) for four different trading settings. Figure 4.13 : Four different generation trading settings in a spot market slot (slot_length = 15 min). If fit_to_limit is set to True , energy_rate_decrease_per_update is ignored and a rate decrease per time is calculated, starting at initial_selling_rate and ending at final_selling_rate while updating the rate at each update_interval . Bids\u2019 Trading settings: initial_buying_rate final_buying_rate update_interval energy_rate_increase_per_update fit_to_limit The following plot shows the energy rate change in a spot market slot (slot_length = 15min) for different trading settings. If fit_to_limit is set to True , energy_rate_increase_per_update is ignored and a rate increase per time is calculated that starts at initial_buying_rate and ends at final_buying_rate while updating the rate at each update_interval . Figure 4.14 : Four different load trading settings in a spot market slot (slot_length = 15 min). Assets can also deploy more intelligent trading strategies, as shown in the example Heat Pump Trading Strategy and further demonstrated in the 2020 Energy Singularity Challenge, described in the following two articles: Grid Singularity. (September 10, 2020). En Route to Energy Singularity Odyssey Momentum: Learnings from the 2020 Chaos Experiment Grid Singularity. (November 25, 2020). Energy Singularity Challenge 2020: Social Energy Networks Information on how to set up and train intelligent trading strategies through the Grid Singularity Asset API is available here .","title":"Trading Strategies"},{"location":"degrees-of-freedom/","text":"Through the Grid Singularity Exchange, and as permitted by local legislation, users can enjoy enhanced degrees of freedom, or choices to trade or share energy based on a set of preferences, such as energy quantity, price, source or preferred trading partner. The degrees of freedom are a key functionality of the Symbiotic Energy Market , a future decentralised market design we aim to enable to the extent that legislation in relevant markets allows people to have more energy choices. The implementation of a decentralised version of the Grid Singularity Exchange (GSy DEX) is described here . A user might be interested to set trading preferences in order to prioritise consumption of green energy (i.e. solar, wind) over grey energy (i.e. coal) or in order to buy or sell energy directly to a friend or family member, for example.The bids and offers for an energy asset include a set of attributes and requirements that reflect its owner\u2019s trading preferences. Attributes are parameters currently supported only for offers, that describe the energy type of the offer posted, which is commonly associated with the energy source (e.g. PV, Wind, Hydro, Biomass, etc\u2026). On the other hand, requirements are parameters associated with both bids and offers, and represent the trading preferences of the users. The currently supported requirements are the following: Offers: Preferred trading partners: community participants the users wish to sell energy to; Bids: Preferred trading partners: community participants the users wish to buy energy from; Energy type: the energy source that the user prefers to consume (e.g. PV, Wind, Hydro, Biomass, etc.) Energy: the maximum amount of energy that the user is willing to consume; Price: the maximum price for energy that the user is willing to pay. Naturally, attributes and requirements can be aggregated/grouped in different combinations to express customised trading preferences. The figure below displays an example of a bid and offer with attributes and requirements. The bid submits three sets of conditions that must be interpreted as OR statements, i.e. each condition must be assessed individually and each requirement of the condition must be fulfilled. In this example, the Consumer desires to buy up to 1.0 kWh from their Mom for a maximum of 28 cents OR up to 1.0 kWh of solar energy for a maximum of 25 cents OR up to 0.5 kWh of energy from any source for a maximum of 20 cents. The Producer has 0.8 kWh of solar energy to sell for no less than 21 cents. In this case, the second condition is fulfilled by the offer, thus the two orders are successfully matched: The energy source (solar) is the same in the bid and the offer; The energy to be traded results in 0.8 kWh; The trading price can range between 21 and 25 cents and will be determined by the matching algorithm in place. Figure 4.21 : Example of a bid and offer with attributes and requirements. The GSy Matching Engine parses the order book and submits proposed bids and offers matches to the Grid Singularity Exchange via the Matching API. A verification function, integrated into the exchange , confirms that the attributes of the proposed bid and offer match satisfies each other\u2019s respective requirements. The verification function accepts a bid / offer pair as input and, if the requirements are met, a trade is created. Otherwise, the trade is rejected. Multi-attributed bids and offers are submitted through Grid Singularity\u2019s existing Asset API . For more information on how to add attributes and requirements to bids and offers by using the Asset API, please follow this link .","title":"Degrees of Freedom"},{"location":"development-path/","text":"Grid Singularity Exchange is built as an open source GPL v.3 codebase with an interactive interface to simulate and operate interconnected, grid-aware energy marketplaces. The future market design implementation, termed Symbiotic Energy Markets, combines multi-attribute double-sided auctions, graph representations of the energy grid and the decentralised computation and verification enabled by blockchain. In the envisaged consumer-centric market design, spot, futures, settlement, and balancing markets are intertwined through the use of time slots, allowing market-driven pricing and accurate accounting of delivered energy. Individuals can optimise for their own multi-attribute objectives (e.g. green energy source, reduced energy bill, preferred trading partner) through degrees of freedom in the multi-attribute double auction with dynamic pricing. The grid is represented as a weighted graph, offering grid operators efficient management tools and allowing energy communities to interconnect and trade. The complexity of the matching algorithm is decoupled from the verification of transactions, with matching facilitated by third party matching algorithm providers, termed \u201cmatching engines\u201d, enabling the exchange itself to operate on a blockchain. New energy market participants are rewarded for providing valuable services such as data and algorithms, while the roles of established market participants (aggregators, grid operators, utilities, and regulators) converge towards the individual and the community. Figure 1.1 : Information flow between aggregator, Grid Singularity exchange and matching algorithm provider (to be sourced through Data and Algorithm Marketplace). IPFS or RDBMS will likely be used for off-chain storage of the order book. The matching algorithms will be run off-chain or in an instance of SubstraTEE. The Grid Singularity Exchange will operate as a pallet on a Substrate-based parachain or another network that provides the best security and privacy combined with execution efficiency. Grid Singularity is implementing Symbiotic Energy Markets in stages, adding or adapting modules to its codebase to take advantage of advancements in blockchain technology, increasing regulatory interest to enable bottom-up markets and the proliferation of connected energy resources. We rely on open source innovation and ecosystem collaboration to develop an inclusive, efficient, accountable and secure energy exchange: Inclusive to all stakeholders, providing barrier-free access for all market actors (established and new) including individuals and their communities, grid operators and utilities, trading algorithm providers, aggregators/energy management service providers, regulators, as well as diverse energy assets; to any individual choice, allowing participants to trade and interact with energy based on their personal preferences on a wide choice of attributes. Efficient physically, that the system accurately represents the grid topology and meets its feasibility requirements , ensuring supply-demand equilibrium to manage critical infrastructure including balancing services; environmentally, prioritising local trading and sustainable energy sources, and enables market transformation to meet the UN Sustainable Development Goals of affordable and clean energy and responsible production and consumption ; economically, [striving for advantageous market prices], a high rate of self-consumption, individual rationality , incentive compatibility and a large amount of energy traded yielding high self-sufficiency and liquidity. Accountable for settlement of energy usage (consumption and generation) and financial responsibility, providing confidentiality of personal data while delivering transparency of the auction process; for audit of transaction records by regulators without relying on a trusted third party and nudge consumers to become more active players ; Scalable technically, structured modularly and without matching and arbitration turning into a computational burden for scenarios with many participants; organisationally, allowing democratic deliberation and decisions on system upgrades; Secure to enable privacy, preserving the confidentiality of personal data and authorising its access on demand; against malicious activity, protecting the integrity of the market while enhancing communication security in the network. Our market design discussion paper explores how defined market requirements translate to the following functional capabilities, outlining the path forward to the deployment of the Symbiotic Energy Markets concept: Validated market participation and asset ownership, Degrees of freedom (choice of energy source, trading partner, etc.) with multi-attribute bids and offers, Matching and arbitration by third party algorithm providers that can be fully decentralised, A time-slot mechanism that allows for spot, futures, settlement (post-delivery) and balancing trading, An accurate grid topology representation that takes into account physical constraints and is scalable, Dynamic grid fees that allow grid operators to manage physical grid constraints, A blockchain implementation for verification and storage of transactions and the grid topology in a deployed network, with decentralised blockchain architecture to allow deliberation and decisions on system changes, Privacy and security considerations for the protection of sensitive user data, A data and algorithm marketplace to inform and optimise market participation, and Interoperable architecture to integrate existing and new business models, leading to a transformation of energy market roles.","title":"Grid Singularity Development Path"},{"location":"documentation/","text":"Grid Singularity is an awarded , open source energy technology startup, placing the individual and the environment at the centre of the energy market by developing the Grid Singularity Exchange and co-founding the Energy Web Foundation (EWF) . Grid Singularity simulates and operates interconnected grid-aware energy marketplaces enabling the utmost degrees of freedom in trading for any market participant. Our co-founders are seasoned energy market professionals and blockchain pioneers, who engaged a talented and diverse team of energy design thinkers and developers, guided by the following principles: Grid Singularity\u2019s mission is to build a sustainable, inclusive and democratic energy market that facilitates the ultimate degrees of freedom for the individual and the energy communities, allowing you to consume, trade or share energy based on your preferences of an energy type, location source, price or trading partner. You are energy. The European Union and other regulators are also supporting a bottom-up, user-centric market design, recognizing its diverse benefits: Grid Singularity facilitates a bottom-up market design by connecting aggregators, which in turn connect households and distributed energy assets digitally represented by trading agents, and grid operators through an application interface ( Grid Operator API and Asset API ). Economic, by incentivising prosumership and local generation and consumption which is cheaper than buying/selling energy directly from the grid while taking into account a wider range of individual preferences; Environmental, optimising the use of green energy supply by fostering collective self-consumption and increased investment in local renewable production; Social, promoting the creation of social energy networks by enabling energy exchange within a community and/or to support local initiatives, advancing community engagement and social inclusion. Modelling simulation studies carried out by Grid Singularity and German and Dutch energy communities and utilities using real-world data have revealed that the activation of local energy markets via Grid Singularity Exchange can increase community self-sufficiency and self-consumption by 7.7% and 5.7%, respectively, and reduce energy bills by around 21% , which could be reinvested in additional storage or other distributed energy assets (DERs). Grid operators can benefit from Grid Singularity Exchange to reduce peak loading and congestion by purchasing grid balancing services and levying flexible grid fees . The initial simulation experiments undertaken by Grid Singularity and German and Dutch energy grid operators revealed 10% reductions in peak loading and congestion, expected to improve with innovation in trading algorithms and grid tariff models.","title":"Grid Singularity Mission"},{"location":"duplicating-simulations/","text":"Any user can duplicate public simulations, in order to run different scenarios and compare or make changes to an existing simulation without losing the original configuration. To duplicate a simulation, click the three dots on the \u2018my communities\u2019 list and select \u2018Duplicate\u2019. This will open the duplicate version of the simulation for editing. Figure 3.16 : Duplicating simulations in the Grid Singularity\u2019s simulation interface (Singularity Map)","title":"Duplicating simulations"},{"location":"energy-bills/","text":"The cumulative energy bills for each market and energy asset are reported on the UI Results page and in a JSON file bills.json for a backend simulation. The bills are reported as the cash flow through each market. For a visual example, the following configuration will be used: This configuration is simulated for one day using the Pay-as-Bid market type and the load bidding to buy energy at 12:00, leading to the propagation of the load bid and the grid operator offer until they are matched as shown in the figure below: The bid and the offer are forwarded to the higher-level Grid market and are matched in this market with a clearing price (and trade price) of 0.45 \u20ac. For more information on how grid fees are calculated, please read the grid fees documentation ). In the bills.json file, the cash flow in each market is reported as follows: \"Parent market\": { \"Agent\": { \"bought\": Energy that has been bought during the simulation [kWh], \"sold\": Energy that has been sold during the simulation [kWh], \"spent\": Amount of money that has been spent in trades during the simulation [\u20ac] , \"earned\": Amount of money that has been earned in trades during the simulation [\u20ac], \"total_energy\": energy bought - energy sold [kWh], \"total_cost\": money spent in trades - money earned in trades [\u20ac], \"market_fee\": Money spent in the \"Parent area\" as grid fees [\u20ac] , \"type\": Type of agent. Can either be a market or the name of the asset strategy }, }, Shown below are the results of the previous example. The first set of results is from the highest market, in this case the Grid market : In the Grid market, House 1 has bought 1 kWh from the DSO and spent 0.375\u20ac in this trade. House 1 also pays the 0.075\u20ac grid fee that the Grid market is charging. The total cost of 1 kWh of energy is 0.375 + 0.075 = 0.45\u20ac One level down the hierarchy, the House 1 market is displayed in the figure below: The House 1 market has no information on the other markets\u2019 grid fees, so only considers its own fees in the bills table. Therefore, the Load spends 0.45\u20ac (0.0375+0.075) for 1 kWh of energy coming outside of House 1, with no grid fee added since House 1 has no fees. Finally, the bills of each energy asset is shown : The Load has bought 1 kWh of energy for 0.45\u20ac. Since 0.075\u20ac was paid as fees to the Grid market, the DSO received the remaining 0.375\u20ac for 1 kWh.","title":"Energy bills"},{"location":"events/","text":"This feature is currently only available for simulations using the backend code and it will soon be available in the new interface, when this documentation will be updated. For backend modelling instructions please see this section .","title":"Events (Adding, Removing Assets, etc.)"},{"location":"general-settings/","text":"Grid Singularity exchange engine can be used to simulate, collaborate and optimize grid-aware local energy markets (LEMs). The simulation tool is freely available through our User Interface (UI) at map.gridsingularity and our backend codebase is open source under GNU general public license . This section will focus on a step-by-step guide to create and simulate LEMs using our software, starting with an explanation and guide for the UI, followed by a more technical tutorial to reproduce in the backend. User-Interface Simulation Configuration \u00b6 When creating a new simulation, simulation collaboration or a simulation in the Canary Test Network, the user needs to define the following general settings: Simulation name : Please provide a unique name. Description : Description of the simulation (optional but encouraged to clarify the intent of the simulation). Project : The user can select a project folder where the simulation is saved. Start date : Simulation start date (please make sure that the date-stamp of any uploaded data coincides with the defined start and end date). End date : Simulation end date. The user can simulate up to 7 days of LEM trading. Solar profile : Sets a template production curve for all photovoltaics (PVs) without custom production curves. Select one the following possible configurations: Sunny (generation profile with 250W panel) Cloudy (generation profile with 250W panel) Partially Cloudy (generation profile with 250W panel) Gaussian (the user can define the panel power output) Upload a profile (a custom default PV production curve can be uploaded as described in Upload File Formats ) Spot market type : The user can select one of three market types: One-sided pay-as-offer , Two-sided pay-as-bid and Two-sided pay-as-clear . Number of spot markets : Number of future spot markets where the energy assets and agents can trade. Duration of market slot : Duration of each spot market,between 2 and 60 minutes. Default is set to 15 minutes. Tick duration : Amount of time between two increments of each market slot when trades are cleared or agent trading rates are updated. Default duration is 15 simulated seconds, yielding 60 ticks per market slot. Grid Fees : The user can select one of two types: Constant grid fee or Percentage grid fee The interface for selecting general settings is shown below: Once the general settings of the simulation are defined, the user can move to the modelling page and set up the grid architecture by adding Markets and Energy Assets. Each market or energy asset is considered as 1 node . At the moment, up to 1000 nodes can be configured. Markets contain a spot market where all connected energy assets, submarkets and parent markets trade energy. Markets can potentially house multiple submarkets of different market types, and this feature will be available in the future version of our software. After adding the first market the user has to select a Market Maker rate. Subsequently, the user can model the simulation by configuring multiple submarkets and energy assets in a hierarchical electrical grid. Once the modelling is completed, the user goes to the Results page to initiate the simulation and view results. Backend Simulation Configuration \u00b6 In the backend, the simulation process is slightly different. There is no need to login to set up a simulation. The user first needs to download the code from our Github Repository (Installation Instructions for Linux , Mac and Windows ). In the setup-file (in Python programming language), general and trading strategy settings can be defined. Examples can be found in the relevant Grid Singularity GitHub folder. This is the most basic skeleton for a setup-file: ```python from gsy_e.models.area import Area def get_setup(config): area = Area('Grid', []) return area The user can add more nested submarkets recursively by adding more instances of Area to the second parameter (list) of the Area class. If the strategy parameter is set in the Area class, the area is converted to a leaf node, e.g. a load. The following grid architecture is given: Grid House 1 H1 General Load H1 Storage 1 H1 Storage 2 House 2 H2 General Load Bold instances in the outline above are markets ( Area component). For each of these markets, an inter-area-agent is created in the background to execute offer/bid forwarding and matching. In the following, the corresponding setup-file is shown. ```python from gsy_e.models.area import Area from d3a.models.strategy.storage import StorageStrategy from gsy_e.models.strategy.load_hours import LoadHoursStrategy from d3a.models.strategy.pv import PVStrategy def get_setup(config): area = Area( 'Grid', [ Area( 'House 1', [ Area('H1 General Load', strategy=LoadHoursStrategy(avg_power_W=200, hrs_per_day=6, hrs_of_day=list( range(12, 18)), final_buying_rate=35) ), Area('H1 Storage1', strategy=StorageStrategy(initial_soc=50) ), Area('H1 Storage2', strategy=StorageStrategy(initial_soc=50) ), ], grid_fee_pct=0, grid_fee_const=0, ), Area( 'House 2', [ Area('H2 General Load', strategy=LoadHoursStrategy(avg_power_W=200, hrs_per_day=4, hrs_of_day=list( range(12, 16)), final_buying_rate=35) ), Area('H2 PV', strategy=PVStrategy(panel_count=4, initial_selling_rate=30, final_selling_rate=5) ), ], grid_fee_pct=0, grid_fee_const=0, ), ], config=config ) return area Additionally the user has the possibility to change the default general settings in two different ways: Setup file (best option) d3a-setting.json setup-file (best option): \u00b6 For a description of each grid component please see the Modelling section. The user can overwrite the configuration settings by changing variables of the ConstSettings class in the setup-file. This class defines the default values for various parameters (general simulation settings, market settings and energy asset configuration). For instance, the user can define multiple configuration parameters in the get_setup function by overwriting the ConstSettings default values. For example, the following parameters can be set : Market_type (if equal to 1: One-Sided Pay-as-Offer , if equal to 2 : Two-Sided Pay-as-Bid , if equal to 3 : Two-Sided Pay-as-Clear ) Grid_fee_type (if equal to 1: Constant grid fee , if equal to 2 : Percentage grid fee ) Here is an example to setup a simulation with the Two-Sided Pay-as-Bid market type, constant grid fee and default min (0cts/kWh) and max to (35cts/kWh) energy rate for all loads : from gsy_framework.constants_limits import ConstSettings def get_setup(config): ConstSettings.MASettings.MARKET_TYPE = 2 ConstSettings.LoadSettings.MIN_ENERGY_RATE = 0 ConstSettings.LoadSettings.MAX_ENERGY_RATE = 35 ConstSettings.MASettings.GRID_FEE_TYPE = 1 d3a-settings.json \u00b6 These general settings can also be parsed via a settings file in JSON format, which contains all constants in the advanced_settings branch. An example can be found here: src/d3a/setup/d3a-settings.json The settings JSON file can be parsed via the --settings-file keyword Setting General Configuration Parameters \u00b6 The following parameters are part of Simulation Config and are initialised before updating any ConstSettings : sim_duration slot_length tick_length cloud_coverage* market_maker_rate* grid_fee_pct* grid_fee_const* pv_user_profile* max_panel_power_W In order to update some of these parameters (starred in list above), please use update_config_parameters method to update the general configuration parameters in the setup file: def get_setup(config): config.update_config_parameters(grid_fee_pct=5, grid_fee_const=35, cloud_coverage=2, pv_user_profile=\"<path>/<profile_name>\", market_maker_rate=30) area = Area( 'Grid', [ Area('General Load', strategy=LoadHoursStrategy(avg_power_W=200, hrs_per_day=4, hrs_of_day=list(range(12, 16)), final_buying_rate=35) ), Area('PV', strategy=PVStrategy(4, 80) ), ], config=config ) return area Simulation launch \u00b6 Once the entire grid architecture is modelled, including energy assets, the user can launch the trading simulation by running a command line including desired setup features: -d, --duration: simulated duration of simulation [default: 1d] -t, --tick-length: simulated duration of a tick [default: 1s] -s, --slot-length: simulated duration of a market slot [default: 15m] -c, --cloud-coverage: Cloud coverage, 0 for sunny, 1 for partial coverage, 2 for clouds. [default: 0] --slot-length-realtime: Desired duration of slot in realtime [default: 0s] Example simulation call: d3a -l ERROR run --duration=1d --tick-length=1s --slot-length=15m --cloud-coverage=0 --setup default_2a Getting help in the command line: d3a --help returns: Usage: d3a [OPTIONS] COMMAND [ARGS]... Options: -l, --log-level [CRITICAL|FATAL|ERROR|WARN|WARNING|INFO|DEBUG|NOTSET|TRACE] Log level [default: INFO] --help Show this message and exit. Commands: run* resume d3a run --help returns: Usage: d3a run [OPTIONS] Options: -d, --duration INTERVAL Duration of simulation [default: 1d] -t, --tick-length INTERVAL Length of a tick [default: 1s] -s, --slot-length INTERVAL Length of a market slot [default: 15m] --slot-length-realtime INTERVAL Desired duration of slot in realtime [default: 0s] -c, --cloud-coverage INTEGER Cloud coverage, 0 for sunny, 1 for partial coverage, 2 for clouds. [default: 0] --setup TEXT Simulation setup module use. Available modules: [1000_houses, market_events.cloud_coverage_event, market_events.disable_interval_event, market_events.disconnect_interval_event, market_events.isolated_connect_event, market_events.isolated_disable_event, market_events.isolated_disconnect_event, market_events.isolated_enable_event, market_events.load_event, market_events.pv_event, market_events.storage_event, balancing_market.default_2a, balancing_market.one_load_one_pv, balancing_market.one_load_one_storage, balancing_market.one_storage_one_pv, balancing_market.test_asset_registry, balancing_market.two_sided_one_load_one_pv, config_parameter_test, default_2, default_2a, default_2b, default_3, default_3_pv_only, default_3a, default_3b, default_4, default_5, default_addcurve, default_addcurve2, default_csv, graphs_testing, jira.d3asim_1024, jira.d3asim_1139, jira.d3asim_638_custom_load, jira.d3asim_639_custom_storage, jira.d3asim_640_custom_pv, jira.d3asim_778, jira.d3asim_780, jira.d3asim_869, jira.d3asim_871, jira.d3asim_895, jira.d3asim_895_pr1, jira.d3asim_895_pr2, jira.d3asim_895_pr3, jira.d3asim_962, jira.default_2off_d3asim_1475, jira.default_595, jira.default_611, jira.default_613, jira.default_623, jira.default_645, jira.default_737, jira.test_strategy_custom_load, jira.test_strategy_custom_pv, jira.test_strategy_custom_storage, json_arg, json_file, non_compounded_grid_fees, redis_communication_default_2a, sam_config, sam_config_const_load, sam_config_small, strategy_tests.commercial_producer_market_maker_rate, strategy_tests.ess_capacity_based_sell_offer, strategy_tests.ess_sell_offer_decrease_based_on_risk_or_rate, strategy_tests.finite_power_plant, strategy_tests.finite_power_plant_profile, strategy_tests.home_cp_ess_load, strategy_tests.home_hybrid_pv_ess_load, strategy_tests.infinite_bus, strategy_tests.predefined_pv_test, strategy_tests.pv_const_price_decrease, strategy_tests.pv_final_selling_rate, strategy_tests.pv_initial_pv_rate_option, strategy_tests.pv_max_panel_output, strategy_tests.pv_max_panel_power_global, strategy_tests.pv_risk_based_price_decrease, strategy_tests.storage_buys_and_offers, strategy_tests.storage_strategy_break_even_hourly, strategy_tests.user_profile_load_csv, strategy_tests.user_profile_load_csv_multiday, strategy_tests.user_profile_load_dict, strategy_tests.user_profile_pv_csv, strategy_tests.user_profile_pv_dict, strategy_tests.user_profile_wind_csv, strategy_tests.user_rate_profile_load_dict, tobalaba.one_producer_load, two_sided_market.default_2a, two_sided_market.infinite_bus, two_sided_market.offer_reposted_at_old_offer_rate, two_sided_market.one_cep_one_load, two_sided_market.one_load_5_pv_partial, two_sided_market.one_load_one_storage, two_sided_market.one_pv_one_load, two_sided_market.one_pv_one_storage, two_sided_market.one_storage_5_pv_partial, two_sided_market.user_min_rate_profile_load_dict, two_sided_market.with_balancing_market, two_sided_pay_as_clear.default_2a, two_sided_pay_as_clear.test_clearing_energy] -g, --settings-file TEXT Settings file path --seed TEXT Manually specify random seed --paused Start simulation in paused state [default: False] --pause-at TEXT Automatically pause at a certain time. Accepted Input formats: (YYYY-MM-DD, HH:mm) [default: disabled] --repl / --no-repl Start REPL after simulation run. [default: False] --no-export Skip export of simulation data --export-path TEXT Specify a path for the csv export files (default: ~/d3a-simulation) --enable-bc Run simulation on Blockchain --start-date DATE Start date of the Simulation (YYYY-MM-DD) [default: 2019-09-27] --help Show this message and exit.","title":"General settings"},{"location":"general-settings/#user-interface-simulation-configuration","text":"When creating a new simulation, simulation collaboration or a simulation in the Canary Test Network, the user needs to define the following general settings: Simulation name : Please provide a unique name. Description : Description of the simulation (optional but encouraged to clarify the intent of the simulation). Project : The user can select a project folder where the simulation is saved. Start date : Simulation start date (please make sure that the date-stamp of any uploaded data coincides with the defined start and end date). End date : Simulation end date. The user can simulate up to 7 days of LEM trading. Solar profile : Sets a template production curve for all photovoltaics (PVs) without custom production curves. Select one the following possible configurations: Sunny (generation profile with 250W panel) Cloudy (generation profile with 250W panel) Partially Cloudy (generation profile with 250W panel) Gaussian (the user can define the panel power output) Upload a profile (a custom default PV production curve can be uploaded as described in Upload File Formats ) Spot market type : The user can select one of three market types: One-sided pay-as-offer , Two-sided pay-as-bid and Two-sided pay-as-clear . Number of spot markets : Number of future spot markets where the energy assets and agents can trade. Duration of market slot : Duration of each spot market,between 2 and 60 minutes. Default is set to 15 minutes. Tick duration : Amount of time between two increments of each market slot when trades are cleared or agent trading rates are updated. Default duration is 15 simulated seconds, yielding 60 ticks per market slot. Grid Fees : The user can select one of two types: Constant grid fee or Percentage grid fee The interface for selecting general settings is shown below: Once the general settings of the simulation are defined, the user can move to the modelling page and set up the grid architecture by adding Markets and Energy Assets. Each market or energy asset is considered as 1 node . At the moment, up to 1000 nodes can be configured. Markets contain a spot market where all connected energy assets, submarkets and parent markets trade energy. Markets can potentially house multiple submarkets of different market types, and this feature will be available in the future version of our software. After adding the first market the user has to select a Market Maker rate. Subsequently, the user can model the simulation by configuring multiple submarkets and energy assets in a hierarchical electrical grid. Once the modelling is completed, the user goes to the Results page to initiate the simulation and view results.","title":"User-Interface Simulation Configuration"},{"location":"general-settings/#backend-simulation-configuration","text":"In the backend, the simulation process is slightly different. There is no need to login to set up a simulation. The user first needs to download the code from our Github Repository (Installation Instructions for Linux , Mac and Windows ). In the setup-file (in Python programming language), general and trading strategy settings can be defined. Examples can be found in the relevant Grid Singularity GitHub folder. This is the most basic skeleton for a setup-file: ```python from gsy_e.models.area import Area def get_setup(config): area = Area('Grid', []) return area The user can add more nested submarkets recursively by adding more instances of Area to the second parameter (list) of the Area class. If the strategy parameter is set in the Area class, the area is converted to a leaf node, e.g. a load. The following grid architecture is given: Grid House 1 H1 General Load H1 Storage 1 H1 Storage 2 House 2 H2 General Load Bold instances in the outline above are markets ( Area component). For each of these markets, an inter-area-agent is created in the background to execute offer/bid forwarding and matching. In the following, the corresponding setup-file is shown. ```python from gsy_e.models.area import Area from d3a.models.strategy.storage import StorageStrategy from gsy_e.models.strategy.load_hours import LoadHoursStrategy from d3a.models.strategy.pv import PVStrategy def get_setup(config): area = Area( 'Grid', [ Area( 'House 1', [ Area('H1 General Load', strategy=LoadHoursStrategy(avg_power_W=200, hrs_per_day=6, hrs_of_day=list( range(12, 18)), final_buying_rate=35) ), Area('H1 Storage1', strategy=StorageStrategy(initial_soc=50) ), Area('H1 Storage2', strategy=StorageStrategy(initial_soc=50) ), ], grid_fee_pct=0, grid_fee_const=0, ), Area( 'House 2', [ Area('H2 General Load', strategy=LoadHoursStrategy(avg_power_W=200, hrs_per_day=4, hrs_of_day=list( range(12, 16)), final_buying_rate=35) ), Area('H2 PV', strategy=PVStrategy(panel_count=4, initial_selling_rate=30, final_selling_rate=5) ), ], grid_fee_pct=0, grid_fee_const=0, ), ], config=config ) return area Additionally the user has the possibility to change the default general settings in two different ways: Setup file (best option) d3a-setting.json","title":"Backend Simulation Configuration"},{"location":"general-settings/#setup-file-best-option","text":"For a description of each grid component please see the Modelling section. The user can overwrite the configuration settings by changing variables of the ConstSettings class in the setup-file. This class defines the default values for various parameters (general simulation settings, market settings and energy asset configuration). For instance, the user can define multiple configuration parameters in the get_setup function by overwriting the ConstSettings default values. For example, the following parameters can be set : Market_type (if equal to 1: One-Sided Pay-as-Offer , if equal to 2 : Two-Sided Pay-as-Bid , if equal to 3 : Two-Sided Pay-as-Clear ) Grid_fee_type (if equal to 1: Constant grid fee , if equal to 2 : Percentage grid fee ) Here is an example to setup a simulation with the Two-Sided Pay-as-Bid market type, constant grid fee and default min (0cts/kWh) and max to (35cts/kWh) energy rate for all loads : from gsy_framework.constants_limits import ConstSettings def get_setup(config): ConstSettings.MASettings.MARKET_TYPE = 2 ConstSettings.LoadSettings.MIN_ENERGY_RATE = 0 ConstSettings.LoadSettings.MAX_ENERGY_RATE = 35 ConstSettings.MASettings.GRID_FEE_TYPE = 1","title":"setup-file (best option):"},{"location":"general-settings/#d3a-settingsjson","text":"These general settings can also be parsed via a settings file in JSON format, which contains all constants in the advanced_settings branch. An example can be found here: src/d3a/setup/d3a-settings.json The settings JSON file can be parsed via the --settings-file keyword","title":"d3a-settings.json"},{"location":"general-settings/#setting-general-configuration-parameters","text":"The following parameters are part of Simulation Config and are initialised before updating any ConstSettings : sim_duration slot_length tick_length cloud_coverage* market_maker_rate* grid_fee_pct* grid_fee_const* pv_user_profile* max_panel_power_W In order to update some of these parameters (starred in list above), please use update_config_parameters method to update the general configuration parameters in the setup file: def get_setup(config): config.update_config_parameters(grid_fee_pct=5, grid_fee_const=35, cloud_coverage=2, pv_user_profile=\"<path>/<profile_name>\", market_maker_rate=30) area = Area( 'Grid', [ Area('General Load', strategy=LoadHoursStrategy(avg_power_W=200, hrs_per_day=4, hrs_of_day=list(range(12, 16)), final_buying_rate=35) ), Area('PV', strategy=PVStrategy(4, 80) ), ], config=config ) return area","title":"Setting General Configuration Parameters"},{"location":"general-settings/#simulation-launch","text":"Once the entire grid architecture is modelled, including energy assets, the user can launch the trading simulation by running a command line including desired setup features: -d, --duration: simulated duration of simulation [default: 1d] -t, --tick-length: simulated duration of a tick [default: 1s] -s, --slot-length: simulated duration of a market slot [default: 15m] -c, --cloud-coverage: Cloud coverage, 0 for sunny, 1 for partial coverage, 2 for clouds. [default: 0] --slot-length-realtime: Desired duration of slot in realtime [default: 0s] Example simulation call: d3a -l ERROR run --duration=1d --tick-length=1s --slot-length=15m --cloud-coverage=0 --setup default_2a Getting help in the command line: d3a --help returns: Usage: d3a [OPTIONS] COMMAND [ARGS]... Options: -l, --log-level [CRITICAL|FATAL|ERROR|WARN|WARNING|INFO|DEBUG|NOTSET|TRACE] Log level [default: INFO] --help Show this message and exit. Commands: run* resume d3a run --help returns: Usage: d3a run [OPTIONS] Options: -d, --duration INTERVAL Duration of simulation [default: 1d] -t, --tick-length INTERVAL Length of a tick [default: 1s] -s, --slot-length INTERVAL Length of a market slot [default: 15m] --slot-length-realtime INTERVAL Desired duration of slot in realtime [default: 0s] -c, --cloud-coverage INTEGER Cloud coverage, 0 for sunny, 1 for partial coverage, 2 for clouds. [default: 0] --setup TEXT Simulation setup module use. Available modules: [1000_houses, market_events.cloud_coverage_event, market_events.disable_interval_event, market_events.disconnect_interval_event, market_events.isolated_connect_event, market_events.isolated_disable_event, market_events.isolated_disconnect_event, market_events.isolated_enable_event, market_events.load_event, market_events.pv_event, market_events.storage_event, balancing_market.default_2a, balancing_market.one_load_one_pv, balancing_market.one_load_one_storage, balancing_market.one_storage_one_pv, balancing_market.test_asset_registry, balancing_market.two_sided_one_load_one_pv, config_parameter_test, default_2, default_2a, default_2b, default_3, default_3_pv_only, default_3a, default_3b, default_4, default_5, default_addcurve, default_addcurve2, default_csv, graphs_testing, jira.d3asim_1024, jira.d3asim_1139, jira.d3asim_638_custom_load, jira.d3asim_639_custom_storage, jira.d3asim_640_custom_pv, jira.d3asim_778, jira.d3asim_780, jira.d3asim_869, jira.d3asim_871, jira.d3asim_895, jira.d3asim_895_pr1, jira.d3asim_895_pr2, jira.d3asim_895_pr3, jira.d3asim_962, jira.default_2off_d3asim_1475, jira.default_595, jira.default_611, jira.default_613, jira.default_623, jira.default_645, jira.default_737, jira.test_strategy_custom_load, jira.test_strategy_custom_pv, jira.test_strategy_custom_storage, json_arg, json_file, non_compounded_grid_fees, redis_communication_default_2a, sam_config, sam_config_const_load, sam_config_small, strategy_tests.commercial_producer_market_maker_rate, strategy_tests.ess_capacity_based_sell_offer, strategy_tests.ess_sell_offer_decrease_based_on_risk_or_rate, strategy_tests.finite_power_plant, strategy_tests.finite_power_plant_profile, strategy_tests.home_cp_ess_load, strategy_tests.home_hybrid_pv_ess_load, strategy_tests.infinite_bus, strategy_tests.predefined_pv_test, strategy_tests.pv_const_price_decrease, strategy_tests.pv_final_selling_rate, strategy_tests.pv_initial_pv_rate_option, strategy_tests.pv_max_panel_output, strategy_tests.pv_max_panel_power_global, strategy_tests.pv_risk_based_price_decrease, strategy_tests.storage_buys_and_offers, strategy_tests.storage_strategy_break_even_hourly, strategy_tests.user_profile_load_csv, strategy_tests.user_profile_load_csv_multiday, strategy_tests.user_profile_load_dict, strategy_tests.user_profile_pv_csv, strategy_tests.user_profile_pv_dict, strategy_tests.user_profile_wind_csv, strategy_tests.user_rate_profile_load_dict, tobalaba.one_producer_load, two_sided_market.default_2a, two_sided_market.infinite_bus, two_sided_market.offer_reposted_at_old_offer_rate, two_sided_market.one_cep_one_load, two_sided_market.one_load_5_pv_partial, two_sided_market.one_load_one_storage, two_sided_market.one_pv_one_load, two_sided_market.one_pv_one_storage, two_sided_market.one_storage_5_pv_partial, two_sided_market.user_min_rate_profile_load_dict, two_sided_market.with_balancing_market, two_sided_pay_as_clear.default_2a, two_sided_pay_as_clear.test_clearing_energy] -g, --settings-file TEXT Settings file path --seed TEXT Manually specify random seed --paused Start simulation in paused state [default: False] --pause-at TEXT Automatically pause at a certain time. Accepted Input formats: (YYYY-MM-DD, HH:mm) [default: disabled] --repl / --no-repl Start REPL after simulation run. [default: False] --no-export Skip export of simulation data --export-path TEXT Specify a path for the csv export files (default: ~/d3a-simulation) --enable-bc Run simulation on Blockchain --start-date DATE Start date of the Simulation (YYYY-MM-DD) [default: 2019-09-27] --help Show this message and exit.","title":"Simulation launch"},{"location":"get-simulation-data/","text":"Historical Data API \u00b6 The Historical Data API has been developed by Grid Singularity to allow users to retrieve the assets\u2019 historical data in a given simulation, such as loads (consumption profiles) or generation profiles. This information can be used, for instance, by trading agents to adapt the assets\u2019 trading settings to optimise the asset owner\u2019s savings / revenue from these assets. This API requires the following parameters: Simulation_id : This is the ID of the simulation or the Grid Singularity Canary Test Network , and can be found in the url on the Grid Singularity user interface (UI) (see Fig. 1) Market_uuid : This is the ID of the asset or market of the energy community for which the historical information is to be retrieved. It can also be found in the url on the Grid Singularity UI (see Fig. 1) Start_time and end_time : This is the time period for which the historical information is downloaded You can then connect to the API with the following URL, which divides the parameters with a slash (/): https://gsyweb.gridsingularity.com/historical-data/assets/{simulation_id}/{market_uuid}/{start_time}/{end_time} Grid Data API \u00b6 Grid Singularity has developed the Grid Data API to provide information about the topology of a simulated energy community, listing the relevant attributes and connections for each energy asset. This API requires the following parameters: Simulation_id : This is the ID of the simulation or the Grid Singularity Canary Test Network , and can be found in the url on the Grid Singularity user interface (UI) (see Fig. 1) You can then connect to the API with the following URL, which divides the parameters with a slash (/): https://gsyweb.gridsingularity.com/external-connection/configurations/{simulation_id}/registry The response will include the following data: Uuid : unique identifier of each asset Name : name of each asset Type : type of each asset Aggregator : name of the aggregator that manages the asset, if any Attributes : any relevant asset attributes We will gradually add more data points to the response of the Grid Data API, for instance the geographic location (longitude and latitude) of each asset. Figure 1: Screenshot of a simulation url, which includes the simulation_id and the market_uuid parameters in the Grid Singularity UI Connect to the data APIs \u00b6 Perform a request using Postman \u00b6 Postman is a widely used API client that enables you to save your requests as well as share settings with others. To use Postman with this API, the first step is to create a \u201ccollection\u201d that contains all settings needed to perform a request to the Historical Data API. To install and set up a collection on postman, please follow these steps: Download and install app from Postman Import attached collection: Download the collection file here . Go to File > Import and click on Upload Files , select the collection file that you just downloaded and click on Import . Change user credentials in the pre-request scripts Adapt the url with the wanted parameters following the description mentioned above and press Send (the results should be shown in the Body tab of the response): (Optional) Save the response as a json file clicking on Save Response on the right side. Perform a request using a Python script \u00b6 Alternatively, you can directly use Python to make a request to the API. For this method, please follow this steps: Import the library and set the parameters of your simulation import requests username = \"<your_user>\" password = \"<your_password>\" domain = \"https://gsyweb.gridsingularity.com\" simulation_id = \"990abe5e-3126-4b8b-9978-66ca07824d3c\" market_uuid = \"a245cff8-d90a-44d9-82e5-d37999b62e04\" start_date = \"2021-09-25T00:00\" end_date = \"2021-10-01T00:00\" Generate your JWT token response = requests.post(url=domain + \"/api-token-auth/\", json={\"username\": username, \"password\": password}) token = response.json()[\"token\"] Create a URL and send the request: historical_data_url = f\"{domain}/historical-data/assets/{configuration_id}/{asset_id}/{start_date}/{end_date}\" headers = {\"Authorization\": f\"JWT {token}\"} response = requests.get(url=historical_data_url, headers=headers) profile = response.json()","title":"Extract data (historical profile and grid topology) through the Grid Singularity Historical Data and Grid Data APIs"},{"location":"get-simulation-data/#historical-data-api","text":"The Historical Data API has been developed by Grid Singularity to allow users to retrieve the assets\u2019 historical data in a given simulation, such as loads (consumption profiles) or generation profiles. This information can be used, for instance, by trading agents to adapt the assets\u2019 trading settings to optimise the asset owner\u2019s savings / revenue from these assets. This API requires the following parameters: Simulation_id : This is the ID of the simulation or the Grid Singularity Canary Test Network , and can be found in the url on the Grid Singularity user interface (UI) (see Fig. 1) Market_uuid : This is the ID of the asset or market of the energy community for which the historical information is to be retrieved. It can also be found in the url on the Grid Singularity UI (see Fig. 1) Start_time and end_time : This is the time period for which the historical information is downloaded You can then connect to the API with the following URL, which divides the parameters with a slash (/): https://gsyweb.gridsingularity.com/historical-data/assets/{simulation_id}/{market_uuid}/{start_time}/{end_time}","title":"Historical Data API"},{"location":"get-simulation-data/#grid-data-api","text":"Grid Singularity has developed the Grid Data API to provide information about the topology of a simulated energy community, listing the relevant attributes and connections for each energy asset. This API requires the following parameters: Simulation_id : This is the ID of the simulation or the Grid Singularity Canary Test Network , and can be found in the url on the Grid Singularity user interface (UI) (see Fig. 1) You can then connect to the API with the following URL, which divides the parameters with a slash (/): https://gsyweb.gridsingularity.com/external-connection/configurations/{simulation_id}/registry The response will include the following data: Uuid : unique identifier of each asset Name : name of each asset Type : type of each asset Aggregator : name of the aggregator that manages the asset, if any Attributes : any relevant asset attributes We will gradually add more data points to the response of the Grid Data API, for instance the geographic location (longitude and latitude) of each asset. Figure 1: Screenshot of a simulation url, which includes the simulation_id and the market_uuid parameters in the Grid Singularity UI","title":"Grid Data API"},{"location":"get-simulation-data/#connect-to-the-data-apis","text":"","title":"Connect to the data APIs"},{"location":"get-simulation-data/#perform-a-request-using-postman","text":"Postman is a widely used API client that enables you to save your requests as well as share settings with others. To use Postman with this API, the first step is to create a \u201ccollection\u201d that contains all settings needed to perform a request to the Historical Data API. To install and set up a collection on postman, please follow these steps: Download and install app from Postman Import attached collection: Download the collection file here . Go to File > Import and click on Upload Files , select the collection file that you just downloaded and click on Import . Change user credentials in the pre-request scripts Adapt the url with the wanted parameters following the description mentioned above and press Send (the results should be shown in the Body tab of the response): (Optional) Save the response as a json file clicking on Save Response on the right side.","title":"Perform a request using Postman"},{"location":"get-simulation-data/#perform-a-request-using-a-python-script","text":"Alternatively, you can directly use Python to make a request to the API. For this method, please follow this steps: Import the library and set the parameters of your simulation import requests username = \"<your_user>\" password = \"<your_password>\" domain = \"https://gsyweb.gridsingularity.com\" simulation_id = \"990abe5e-3126-4b8b-9978-66ca07824d3c\" market_uuid = \"a245cff8-d90a-44d9-82e5-d37999b62e04\" start_date = \"2021-09-25T00:00\" end_date = \"2021-10-01T00:00\" Generate your JWT token response = requests.post(url=domain + \"/api-token-auth/\", json={\"username\": username, \"password\": password}) token = response.json()[\"token\"] Create a URL and send the request: historical_data_url = f\"{domain}/historical-data/assets/{configuration_id}/{asset_id}/{start_date}/{end_date}\" headers = {\"Authorization\": f\"JWT {token}\"} response = requests.get(url=historical_data_url, headers=headers) profile = response.json()","title":"Perform a request using a Python script"},{"location":"grid-fees/","text":"Grid operators (Distribution and Transmission System Operators - DSOs and TSOs - or Independent System Operators - ISOs in the USA) are tasked to monitor and manage the electrical grid. It is their responsibility to ensure a connection for end-users on the distribution network along with energy transport security. Grid operators use grid fees to cover the cost of managing their grid infrastructure. Lately, due to the heightened pace of innovation, increased demand and investment in distributed energy resources (DERs), grid operators face many challenges, such as lines and transformers congestion at specific times of the day. One solution is to use grid fees as a tool to actively manage grid congestion by increasing and reducing the fee during the day, week or year. Increasing the fee at peak transmission and reducing the price during off-peak periods makes it financially attractive for end-users to use flexible energy assets (e.g. batteries, EVs, heat-pumps) to provide demand response services and reduce reliance on the grid. Grid Singularity offers an environment to simulate, test and optimize grid fee incentives for local energy markets (LEMs) At the moment grid fee can be set as : Market Fee : This is a fee that is added to each trade that is cleared. The buyer of energy is responsible for paying all the grid fees: bid\u2019s price >= offer\u2019s price + grid fee . Constant grid fee : constant value in cents/kWh that is added to each trade Percentage grid fee : percentage value determined by the clearing price that is added to each trade The following article explains how flexible grid fees may be implemented towards peak reduction. For a video tutorial on how to set grid fees in the Grid Singularity exchange engine , please follow this link .","title":"Grid Fee Objectives"},{"location":"grid-market-settings/","text":"Energy markets are regulated exchange systems in which energy assets can buy, sell and trade energy. In the Grid Singularity Exchange, as a user models an energy community, that community by default exists in one, local energy market (LEM). LEM participants include the community assets and the external suppliers (the grid market). A LEM can contain submarkets, such as a home market where a solar panel is supplying a fridge and a battery, and the battery is supplying a television, etc. Markets follow a hierarchical structure and are interconnected, allowing bids and offers to pass between markets until they are matched, following a select market clearing mechanism and accounting for network costs. Only one grid market can be set per simulation in the Grid Singularity web-based simulation interface, integrating the energy community with external suppliers that are able to sell an infinite amount of energy, thereby matching any demand that cannot be supplied locally, and/or to buy an infinite amount of energy as with a feed-in-tariff scheme. By connecting through the Asset API , more than one grid market can be configured in backend code to represent an energy community supplied by more than one energy retailer. Users can configure the grid market settings by selecting the black dot on the circle surrounding their energy community on the Singularity Map, the Grid Singularity Exchange simulation interface. Figure 2.16 : Map view of the grid market settings in the Grid Singularity web-based simulation interface Grid Market configuration options \u00b6 Grid Market \u00b6 Under the Grid Market tab, the user will provide the following information: Name: select a unique name for the grid market; Location: the location selected by the user is automatically uploaded Grid Agent \u00b6 Under the Grid Agent tab, the following settings are available as shown in the figure and explained below: Figure 2.17 : Grid Agent Configuration Options of the Grid Market in the Grid Singularity web-based simulation interface Role: select the option to either be grid connected or Islanded. The default role is set to grid connected, whereby the energy demanded of any consumer can be fulfilled and surplus generation can be absorbed. Selling rate type: select the user input option to define a fixed selling rate or upload a custom selling rate profile with which the external grid sells deficit electricity to the community Selling rate: enter a value in cents/kWh to set the rate at which external suppliers will sell their energy. Buying rate type: select the user input option to define a fixed buying rate or upload a custom buying rate profile (dynamic prices) with which the external grid buys surplus energy from the community Buying rate: enter a value in cents/kWh to represent the feed-in-tariff scheme","title":"Grid Market Settings"},{"location":"grid-market-settings/#grid-market-configuration-options","text":"","title":"Grid Market configuration options"},{"location":"grid-market-settings/#grid-market","text":"Under the Grid Market tab, the user will provide the following information: Name: select a unique name for the grid market; Location: the location selected by the user is automatically uploaded","title":"Grid Market"},{"location":"grid-market-settings/#grid-agent","text":"Under the Grid Agent tab, the following settings are available as shown in the figure and explained below: Figure 2.17 : Grid Agent Configuration Options of the Grid Market in the Grid Singularity web-based simulation interface Role: select the option to either be grid connected or Islanded. The default role is set to grid connected, whereby the energy demanded of any consumer can be fulfilled and surplus generation can be absorbed. Selling rate type: select the user input option to define a fixed selling rate or upload a custom selling rate profile with which the external grid sells deficit electricity to the community Selling rate: enter a value in cents/kWh to set the rate at which external suppliers will sell their energy. Buying rate type: select the user input option to define a fixed buying rate or upload a custom buying rate profile (dynamic prices) with which the external grid buys surplus energy from the community Buying rate: enter a value in cents/kWh to represent the feed-in-tariff scheme","title":"Grid Agent"},{"location":"grid-operator-api-commands/","text":"The Grid Operator API can function once at the start of each market slot . When the current market slot ends, a new one is automatically created and the client is notified via the on_market_cycle event. It is possible to capture this event and perform operations when it occurs by overriding the functionality of the on_market_cycle method. The Grid Operator API can send batch commands, grouping different commands, for different markets. The commands can be grouped and then all executed at the same time. Three different commands are available for the Grid Operator API: last_market_dso_stats() \u00b6 This command is used to request information from different markets for the last market slot. This batch command receives one argument : area_uuid . This latter is the Universal Unique Identifier of the requested market statistic. Here is an example: self.add_to_batch_commands.last_market_dso_stats(area_uuid = \"62f827ec-ef86-4782-b5c3-88327751d97d\") grid_fees() \u00b6 This command is used to send the new grid fee for a specific market. The grid fee needs to be set as a positive value and the unit is cents/kWh. This batch command receives two arguments: area_uuid and fee_cents_kwh . Here is an example: self.add_to_batch_commands.grid_fees(area_uuid=62f827ec-ef86-4782-b5c3-88327751d97d\", fee_cents_kwh=3.2) After adding all the wanted commands in the batch, the API can execute it with the following command: response = self.execute_batch_commands() In return the simulation will provide a response for all commands submitted.","title":"Grid Operator API Commands"},{"location":"grid-operator-api-commands/#last_market_dso_stats","text":"This command is used to request information from different markets for the last market slot. This batch command receives one argument : area_uuid . This latter is the Universal Unique Identifier of the requested market statistic. Here is an example: self.add_to_batch_commands.last_market_dso_stats(area_uuid = \"62f827ec-ef86-4782-b5c3-88327751d97d\")","title":"last_market_dso_stats()"},{"location":"grid-operator-api-commands/#grid_fees","text":"This command is used to send the new grid fee for a specific market. The grid fee needs to be set as a positive value and the unit is cents/kWh. This batch command receives two arguments: area_uuid and fee_cents_kwh . Here is an example: self.add_to_batch_commands.grid_fees(area_uuid=62f827ec-ef86-4782-b5c3-88327751d97d\", fee_cents_kwh=3.2) After adding all the wanted commands in the batch, the API can execute it with the following command: response = self.execute_batch_commands() In return the simulation will provide a response for all commands submitted.","title":"grid_fees()"},{"location":"grid-operator-api-events/","text":"Market Information \u00b6 The Grid Operator API receives information concerning the markets that it manages. Different metrics are shared through the API : Minimum, median, average and maximum trade price [\u20ac/kWh] Total energy volume traded [kWh] Self-sufficiency / self-consumption [%] Import / Export [kWh] Current market fee [cents/kWh] Next market fee [cents/kWh] Market fee revenue [cents] Interaction with the running exchange \u00b6 As explained above the Grid Operator API function is triggered at the start of each market slot. Here is one example: At the end of the 12:45 market slot, the Grid Operator API function on_market_cycle is triggered. The Grid Operator agent receives a nested dictionary with information from the last market slot, including the grid tree ( 12:45-13:00 ). Based on these inputs, the agent script sets a new grid fee for the markets it manages. The grid fees sent during the 13:00 will be applied for the 13:15 market slot. API Events \u00b6 In the Grid Operator there are 3 events that are triggered while a simulation is running. Each new market slot \u00b6 def on_market_cycle(self, market_info): As shown in the schematic above, this event triggered at the start of every market slot. When a new market slot is created the API receives the market_info , containing market information and the code within the script event is executed. On event or response \u00b6 def on_event_or_response(self, message): In this event, the API receives a message for every event ( on_market_cycle ) or response for each commands (e.g. submitting new grid fees) On finish \u00b6 def on_finish(self, finish_info): This event is triggered when the simulation/collaboration finishes. Within that function, information stored during the simulation could potentially be exported for further analysis.","title":"Grid Operator API Events"},{"location":"grid-operator-api-events/#market-information","text":"The Grid Operator API receives information concerning the markets that it manages. Different metrics are shared through the API : Minimum, median, average and maximum trade price [\u20ac/kWh] Total energy volume traded [kWh] Self-sufficiency / self-consumption [%] Import / Export [kWh] Current market fee [cents/kWh] Next market fee [cents/kWh] Market fee revenue [cents]","title":"Market Information"},{"location":"grid-operator-api-events/#interaction-with-the-running-exchange","text":"As explained above the Grid Operator API function is triggered at the start of each market slot. Here is one example: At the end of the 12:45 market slot, the Grid Operator API function on_market_cycle is triggered. The Grid Operator agent receives a nested dictionary with information from the last market slot, including the grid tree ( 12:45-13:00 ). Based on these inputs, the agent script sets a new grid fee for the markets it manages. The grid fees sent during the 13:00 will be applied for the 13:15 market slot.","title":"Interaction with the running exchange"},{"location":"grid-operator-api-events/#api-events","text":"In the Grid Operator there are 3 events that are triggered while a simulation is running.","title":"API Events"},{"location":"grid-operator-api-events/#each-new-market-slot","text":"def on_market_cycle(self, market_info): As shown in the schematic above, this event triggered at the start of every market slot. When a new market slot is created the API receives the market_info , containing market information and the code within the script event is executed.","title":"Each new market slot"},{"location":"grid-operator-api-events/#on-event-or-response","text":"def on_event_or_response(self, message): In this event, the API receives a message for every event ( on_market_cycle ) or response for each commands (e.g. submitting new grid fees)","title":"On event or response"},{"location":"grid-operator-api-events/#on-finish","text":"def on_finish(self, finish_info): This event is triggered when the simulation/collaboration finishes. Within that function, information stored during the simulation could potentially be exported for further analysis.","title":"On finish"},{"location":"grid-operator-api-template-script/","text":"The Grid Operator API template scripts are flexible and versatile Python scripts that can be easily modified to implement dynamic grid fees in the Grid Singularity Exchange. In this section, each script will be described along with its functionalities in order of complexity. Implement basic grid fees \u00b6 A template file for managing the market fees through the gsy-e-sdk API client is available here . The script illustrates the most basic implementation of a Grid Operator API strategy: setting grid fees for different markets in the Grid Singularity Exchange. Initially, the user needs to list the markets to be managed via the API. For simulations launched via the user-interface (UI), the CONNECT_TO_ALL_ASSETS parameter is available. If this parameter is set to True, the Grid Operator API connects automatically to all the markets for which the user is registered . # List of markets' names to be connected with the API MARKET_NAMES = [ \"Grid\", \"Community\", ] ORACLE_NAME = \"dso\" SLOT_LENGTH = 15 # leave as is CONNECT_TO_ALL_MARKETS = True At the beginning of each market slot , the script loops through the markets configured in the simulation. For each market, it reads the market fee for the current time slot and sets it for the next. That information is logged in the terminal in a table format. def on_market_cycle(self, market_info): current_market_fee = {} for area_uuid, area_dict in self.latest_grid_tree_flat.items(): if area_dict[\"area_name\"] in MARKET_NAMES: self.add_to_batch_commands.last_market_dso_stats(area_uuid) current_market_fee[area_dict[\"area_name\"]] = area_dict[ \"current_market_fee\" ] next_market_fee = self._set_new_market_fee() log_grid_fees_information(MARKET_NAMES, current_market_fee, next_market_fee) Since there is no preconfigured pricing strategy in this script, the market fee is hardcoded in the set_new_market_fee function (in this example, it was assigned a value of 10). Then, the batch commands are executed. def _set_new_market_fee(self): \"\"\"Return the market fees for each market for the next time slot.\"\"\" next_market_fee = {} for area_uuid, area_dict in self.latest_grid_tree_flat.items(): if area_dict[\"area_name\"] in MARKET_NAMES: next_market_fee[area_dict[\"area_name\"]] = 10 self.add_to_batch_commands.grid_fees( area_uuid=area_uuid, fee_cents_kwh=next_market_fee[area_dict[\"area_name\"]], ) self.execute_batch_commands() return next_market_fee Later in the script, the on_event_or_response is called. By default, the Asset API template does not perform any operation here but the user can add events . For instance, the user could record all the trades occurring in that event. Lastly, the script overwrites the on_finish event so that the script stops whenever the function is triggered. If the user wishes to save any information reported in the logs, it can be done by exporting it to an external file. def on_event_or_response(self, message): pass def on_finish(self, finish_info): self.is_finished = True The rest of the script is used to connect to the energy assets of a running simulation/collaboration/Canary Test Network. These lines should work as is and no changes are required. market_args = { \"simulation_id\": os.environ[\"API_CLIENT_SIMULATION_ID\"], \"domain_name\": os.environ[\"API_CLIENT_DOMAIN_NAME\"], \"websockets_domain_name\": os.environ[\"API_CLIENT_WEBSOCKET_DOMAIN_NAME\"], } aggregator = Oracle(aggregator_name=ORACLE_NAME, **market_args) if CONNECT_TO_ALL_MARKETS: registry = aggregator.get_configuration_registry() MARKET_NAMES = get_assets_name(registry)[\"Area\"] print() print(\"Connecting to markets ...\") for i in MARKET_NAMES: market_uuid = get_area_uuid_from_area_name_and_collaboration_id( market_args[\"simulation_id\"], i, market_args[\"domain_name\"] ) market_args[\"area_id\"] = market_uuid market_registered = RestMarketClient(**market_args) market_registered.select_aggregator(aggregator.aggregator_uuid) print(\"----> Connected to \", i) print(aggregator.device_uuid_list) # loop to allow persistence while not aggregator.is_finished: sleep(0.5) For simulations ran in the backend, a similar script is available here . Implement dynamic grid fees with Time of Use strategy \u00b6 In Time of Use (ToU) strategy, grid fees are applied depending on the time of the day (hours and minutes) regardless of the market conditions. After analyzing import and export patterns of their client, grid operators can create a time-based curve, increasing fees at peak predicted times (e.g. morning and dinner time). Below is an example of a ToU strategy used by the grid operators in one of the experiments at Odyssey hackathon . A template script can be found here . The ToU strategy is uploaded to the Grid Operator API script as a CSV file (an example can be found here ), with the following structure: As shown in the table above, for each market (in this case, the Community market and the Grid market), a value in ct\u20ac/kWh is assigned with a granularity of 15 min. The file is loaded through the read_fee_strategy function: def read_fee_strategy(): \"Return a dictionary containing the Time of Use strategy loaded from the CSV input file.\" with open( os.path.join(module_dir, \"resources/ToU.csv\"), newline=\"\", encoding=\"utf-8\" ) as csvfile: csv_rows = csv.reader(csvfile, delimiter=\" \", quotechar=\"|\") headers = next(csv_rows)[0].split(\";\") market_indexes = {} planned_fee = {} for market_name in MARKET_NAMES: market_indexes.update({(market_name, headers.index(market_name))}) for row in csv_rows: row = row[0].split(\";\") for market in MARKET_NAMES: planned_fee.update({(row[0], market): row[market_indexes[market]]}) return planned_fee As explained in the previous section, here the script sets the market fee for each market for the next time slot and prints that information in the terminal. Note that in this case, the value is taken from the uploaded CSV file instead of being hardcoded (inserted in the code). The calculate_next_slot_market_fee function reads the scheduled fees from the spreadsheet and returns the corresponding grid fee value according to each market and the current market slot. def calculate_next_slot_market_fee(market_time: DateTime, market_name:str) -> float: \"\"\"Return the market fee for the next time slot.\"\"\" slot_time = market_time.add(minutes=SLOT_LENGTH).format(TIME_FORMAT_SECONDS) if (slot_time, market_name) in fee_strategy: next_fee = fee_strategy[(slot_time, market_name)] if not isinstance(next_fee, (int, float)): next_fee = float(next_fee.replace(\",\", \".\")) else: next_fee = None return next_fee The rest of the script has been covered in the previous section. For simulations ran in the backend, a similar script is available here . Implement dynamic grid fees with Aziiz strategy \u00b6 The Aziiz strategy, named after the researcher who suggested this model , is using past market information to determine the next grid fee. The model looks at past imports and exports on a specific market, applies a moving average and then based on this number sets the next grid fee for that market. This model has the advantage of integrating market conditions into its strategy. For instance, if past market slots experienced high imports, the model will increase fees in the relevant market to incentivise market participants to contain the energy within that market. A template script can be found here . With this strategy, two more parameters are available at the beginning of the script and can be tuned: MOVING_AVERAGE_PEAK = True LOOK_BACK_INDEX = 4 If MOVING_AVERAGE_PEAK is set to True, the Aziiz strategy will compare the average of the last markets\u2019 (how many is defined by the LOOK_BACK_INDEX parameter) peak import/export to the threshold. The on_market_slot event is used to request market statistics from the simulation, based on which import / export balance can be calculated for each market. This is the criteria to determine which grid fees to apply in each market. def calculate_import_export_balance(self): \"\"\"Calculate the balance (import - export) for each market.\"\"\" self.dso_stats_response = self.execute_batch_commands() for market_event in self.dso_stats_response[\"responses\"].items(): self.import_kwh[market_event[1][0][\"name\"]] = market_event[1][0][ \"market_stats\" ][\"area_throughput\"][\"import\"] self.export_kwh[market_event[1][0][\"name\"]] = market_event[1][0][ \"market_stats\" ][\"area_throughput\"][\"export\"] self.balance[market_event[1][0][\"name\"]] = ( self.import_kwh[market_event[1][0][\"name\"]] - self.export_kwh[market_event[1][0][\"name\"]] ) self.balance_hist.append(self.balance) In the Aziiz strategy, grid fees can be set for every peak import/export threshold for each market. A JSON file containing this information is uploaded to the Grid Operator API script. An example can be found here . { \"Grid\": [ {\"Import / Export threshold\": 10, \"Grid fee\": 0.9}, {\"Import / Export threshold\": 15, \"Grid fee\": 2.1}, {\"Import / Export threshold\": 20, \"Grid fee\": 3}, {\"Import / Export threshold\": 25, \"Grid fee\": 3.9}, {\"Import / Export threshold\": 30, \"Grid fee\": 6}, {\"Import / Export threshold\": 50, \"Grid fee\": 30} ], \"Community\": [ {\"Import / Export threshold\": 10, \"Grid fee\": 0.9}, {\"Import / Export threshold\": 15, \"Grid fee\": 2.1}, {\"Import / Export threshold\": 20, \"Grid fee\": 3}, {\"Import / Export threshold\": 25, \"Grid fee\": 3.9}, {\"Import / Export threshold\": 30, \"Grid fee\": 6}, {\"Import / Export threshold\": 50, \"Grid fee\": 30} ] } If the average is lower than the threshold, the relevant grid fee will be applied; for instance in the figure above, if the average peak is equal to 22 kWh, the next grid fee will be 3 cents/KWh. Below is a snippet of the _set_new_market_fee adapted to the Aziiz strategy. All the fees are added to the batch command and then executed. def _set_new_market_fee(self): \"\"\"Return the market fees for each market for the next time slot.\"\"\" next_market_fee = {} for area_uuid, area_dict in self.latest_grid_tree_flat.items(): if area_dict[\"area_name\"] in MARKET_NAMES: if MOVING_AVERAGE_PEAK: fees = [] for balance in self.balance_hist: fees.append(balance[area_dict[\"area_name\"]]) max_ext_energy_kwh = abs( sum(fees[-LOOK_BACK_INDEX:]) / len(fees[-LOOK_BACK_INDEX:]) ) else: max_ext_energy_kwh = max( self.import_kwh[area_dict[\"area_name\"]], self.export_kwh[area_dict[\"area_name\"]], ) individual_market_fees = fee_strategy[area_dict[\"area_name\"]] for market_fee in individual_market_fees: if max_ext_energy_kwh <= market_fee[\"Import / Export threshold\"]: next_market_fee[area_dict[\"area_name\"]] = market_fee[\"Grid fee\"] break next_market_fee[area_dict[\"area_name\"]] = 2000 self.add_to_batch_commands.grid_fees( area_uuid=area_uuid, fee_cents_kwh=next_market_fee[area_dict[\"area_name\"]], ) self.execute_batch_commands() return next_market_fee The rest of the script has been already covered in this previous section. For simulations run in the backend, a similar script is available here. For a video tutorial on the Grid Operator API, please follow this link . The next step is to adapt the Grid Operator API template scripts developed by Grid Singularity to customize the grid fee strategies to implement dynamic grid fees in the Grid Singularity Exchange.","title":"Grid Operator API Template Script"},{"location":"grid-operator-api-template-script/#implement-basic-grid-fees","text":"A template file for managing the market fees through the gsy-e-sdk API client is available here . The script illustrates the most basic implementation of a Grid Operator API strategy: setting grid fees for different markets in the Grid Singularity Exchange. Initially, the user needs to list the markets to be managed via the API. For simulations launched via the user-interface (UI), the CONNECT_TO_ALL_ASSETS parameter is available. If this parameter is set to True, the Grid Operator API connects automatically to all the markets for which the user is registered . # List of markets' names to be connected with the API MARKET_NAMES = [ \"Grid\", \"Community\", ] ORACLE_NAME = \"dso\" SLOT_LENGTH = 15 # leave as is CONNECT_TO_ALL_MARKETS = True At the beginning of each market slot , the script loops through the markets configured in the simulation. For each market, it reads the market fee for the current time slot and sets it for the next. That information is logged in the terminal in a table format. def on_market_cycle(self, market_info): current_market_fee = {} for area_uuid, area_dict in self.latest_grid_tree_flat.items(): if area_dict[\"area_name\"] in MARKET_NAMES: self.add_to_batch_commands.last_market_dso_stats(area_uuid) current_market_fee[area_dict[\"area_name\"]] = area_dict[ \"current_market_fee\" ] next_market_fee = self._set_new_market_fee() log_grid_fees_information(MARKET_NAMES, current_market_fee, next_market_fee) Since there is no preconfigured pricing strategy in this script, the market fee is hardcoded in the set_new_market_fee function (in this example, it was assigned a value of 10). Then, the batch commands are executed. def _set_new_market_fee(self): \"\"\"Return the market fees for each market for the next time slot.\"\"\" next_market_fee = {} for area_uuid, area_dict in self.latest_grid_tree_flat.items(): if area_dict[\"area_name\"] in MARKET_NAMES: next_market_fee[area_dict[\"area_name\"]] = 10 self.add_to_batch_commands.grid_fees( area_uuid=area_uuid, fee_cents_kwh=next_market_fee[area_dict[\"area_name\"]], ) self.execute_batch_commands() return next_market_fee Later in the script, the on_event_or_response is called. By default, the Asset API template does not perform any operation here but the user can add events . For instance, the user could record all the trades occurring in that event. Lastly, the script overwrites the on_finish event so that the script stops whenever the function is triggered. If the user wishes to save any information reported in the logs, it can be done by exporting it to an external file. def on_event_or_response(self, message): pass def on_finish(self, finish_info): self.is_finished = True The rest of the script is used to connect to the energy assets of a running simulation/collaboration/Canary Test Network. These lines should work as is and no changes are required. market_args = { \"simulation_id\": os.environ[\"API_CLIENT_SIMULATION_ID\"], \"domain_name\": os.environ[\"API_CLIENT_DOMAIN_NAME\"], \"websockets_domain_name\": os.environ[\"API_CLIENT_WEBSOCKET_DOMAIN_NAME\"], } aggregator = Oracle(aggregator_name=ORACLE_NAME, **market_args) if CONNECT_TO_ALL_MARKETS: registry = aggregator.get_configuration_registry() MARKET_NAMES = get_assets_name(registry)[\"Area\"] print() print(\"Connecting to markets ...\") for i in MARKET_NAMES: market_uuid = get_area_uuid_from_area_name_and_collaboration_id( market_args[\"simulation_id\"], i, market_args[\"domain_name\"] ) market_args[\"area_id\"] = market_uuid market_registered = RestMarketClient(**market_args) market_registered.select_aggregator(aggregator.aggregator_uuid) print(\"----> Connected to \", i) print(aggregator.device_uuid_list) # loop to allow persistence while not aggregator.is_finished: sleep(0.5) For simulations ran in the backend, a similar script is available here .","title":"Implement basic grid fees"},{"location":"grid-operator-api-template-script/#implement-dynamic-grid-fees-with-time-of-use-strategy","text":"In Time of Use (ToU) strategy, grid fees are applied depending on the time of the day (hours and minutes) regardless of the market conditions. After analyzing import and export patterns of their client, grid operators can create a time-based curve, increasing fees at peak predicted times (e.g. morning and dinner time). Below is an example of a ToU strategy used by the grid operators in one of the experiments at Odyssey hackathon . A template script can be found here . The ToU strategy is uploaded to the Grid Operator API script as a CSV file (an example can be found here ), with the following structure: As shown in the table above, for each market (in this case, the Community market and the Grid market), a value in ct\u20ac/kWh is assigned with a granularity of 15 min. The file is loaded through the read_fee_strategy function: def read_fee_strategy(): \"Return a dictionary containing the Time of Use strategy loaded from the CSV input file.\" with open( os.path.join(module_dir, \"resources/ToU.csv\"), newline=\"\", encoding=\"utf-8\" ) as csvfile: csv_rows = csv.reader(csvfile, delimiter=\" \", quotechar=\"|\") headers = next(csv_rows)[0].split(\";\") market_indexes = {} planned_fee = {} for market_name in MARKET_NAMES: market_indexes.update({(market_name, headers.index(market_name))}) for row in csv_rows: row = row[0].split(\";\") for market in MARKET_NAMES: planned_fee.update({(row[0], market): row[market_indexes[market]]}) return planned_fee As explained in the previous section, here the script sets the market fee for each market for the next time slot and prints that information in the terminal. Note that in this case, the value is taken from the uploaded CSV file instead of being hardcoded (inserted in the code). The calculate_next_slot_market_fee function reads the scheduled fees from the spreadsheet and returns the corresponding grid fee value according to each market and the current market slot. def calculate_next_slot_market_fee(market_time: DateTime, market_name:str) -> float: \"\"\"Return the market fee for the next time slot.\"\"\" slot_time = market_time.add(minutes=SLOT_LENGTH).format(TIME_FORMAT_SECONDS) if (slot_time, market_name) in fee_strategy: next_fee = fee_strategy[(slot_time, market_name)] if not isinstance(next_fee, (int, float)): next_fee = float(next_fee.replace(\",\", \".\")) else: next_fee = None return next_fee The rest of the script has been covered in the previous section. For simulations ran in the backend, a similar script is available here .","title":"Implement dynamic grid fees with Time of Use strategy"},{"location":"grid-operator-api-template-script/#implement-dynamic-grid-fees-with-aziiz-strategy","text":"The Aziiz strategy, named after the researcher who suggested this model , is using past market information to determine the next grid fee. The model looks at past imports and exports on a specific market, applies a moving average and then based on this number sets the next grid fee for that market. This model has the advantage of integrating market conditions into its strategy. For instance, if past market slots experienced high imports, the model will increase fees in the relevant market to incentivise market participants to contain the energy within that market. A template script can be found here . With this strategy, two more parameters are available at the beginning of the script and can be tuned: MOVING_AVERAGE_PEAK = True LOOK_BACK_INDEX = 4 If MOVING_AVERAGE_PEAK is set to True, the Aziiz strategy will compare the average of the last markets\u2019 (how many is defined by the LOOK_BACK_INDEX parameter) peak import/export to the threshold. The on_market_slot event is used to request market statistics from the simulation, based on which import / export balance can be calculated for each market. This is the criteria to determine which grid fees to apply in each market. def calculate_import_export_balance(self): \"\"\"Calculate the balance (import - export) for each market.\"\"\" self.dso_stats_response = self.execute_batch_commands() for market_event in self.dso_stats_response[\"responses\"].items(): self.import_kwh[market_event[1][0][\"name\"]] = market_event[1][0][ \"market_stats\" ][\"area_throughput\"][\"import\"] self.export_kwh[market_event[1][0][\"name\"]] = market_event[1][0][ \"market_stats\" ][\"area_throughput\"][\"export\"] self.balance[market_event[1][0][\"name\"]] = ( self.import_kwh[market_event[1][0][\"name\"]] - self.export_kwh[market_event[1][0][\"name\"]] ) self.balance_hist.append(self.balance) In the Aziiz strategy, grid fees can be set for every peak import/export threshold for each market. A JSON file containing this information is uploaded to the Grid Operator API script. An example can be found here . { \"Grid\": [ {\"Import / Export threshold\": 10, \"Grid fee\": 0.9}, {\"Import / Export threshold\": 15, \"Grid fee\": 2.1}, {\"Import / Export threshold\": 20, \"Grid fee\": 3}, {\"Import / Export threshold\": 25, \"Grid fee\": 3.9}, {\"Import / Export threshold\": 30, \"Grid fee\": 6}, {\"Import / Export threshold\": 50, \"Grid fee\": 30} ], \"Community\": [ {\"Import / Export threshold\": 10, \"Grid fee\": 0.9}, {\"Import / Export threshold\": 15, \"Grid fee\": 2.1}, {\"Import / Export threshold\": 20, \"Grid fee\": 3}, {\"Import / Export threshold\": 25, \"Grid fee\": 3.9}, {\"Import / Export threshold\": 30, \"Grid fee\": 6}, {\"Import / Export threshold\": 50, \"Grid fee\": 30} ] } If the average is lower than the threshold, the relevant grid fee will be applied; for instance in the figure above, if the average peak is equal to 22 kWh, the next grid fee will be 3 cents/KWh. Below is a snippet of the _set_new_market_fee adapted to the Aziiz strategy. All the fees are added to the batch command and then executed. def _set_new_market_fee(self): \"\"\"Return the market fees for each market for the next time slot.\"\"\" next_market_fee = {} for area_uuid, area_dict in self.latest_grid_tree_flat.items(): if area_dict[\"area_name\"] in MARKET_NAMES: if MOVING_AVERAGE_PEAK: fees = [] for balance in self.balance_hist: fees.append(balance[area_dict[\"area_name\"]]) max_ext_energy_kwh = abs( sum(fees[-LOOK_BACK_INDEX:]) / len(fees[-LOOK_BACK_INDEX:]) ) else: max_ext_energy_kwh = max( self.import_kwh[area_dict[\"area_name\"]], self.export_kwh[area_dict[\"area_name\"]], ) individual_market_fees = fee_strategy[area_dict[\"area_name\"]] for market_fee in individual_market_fees: if max_ext_energy_kwh <= market_fee[\"Import / Export threshold\"]: next_market_fee[area_dict[\"area_name\"]] = market_fee[\"Grid fee\"] break next_market_fee[area_dict[\"area_name\"]] = 2000 self.add_to_batch_commands.grid_fees( area_uuid=area_uuid, fee_cents_kwh=next_market_fee[area_dict[\"area_name\"]], ) self.execute_batch_commands() return next_market_fee The rest of the script has been already covered in this previous section. For simulations run in the backend, a similar script is available here. For a video tutorial on the Grid Operator API, please follow this link . The next step is to adapt the Grid Operator API template scripts developed by Grid Singularity to customize the grid fee strategies to implement dynamic grid fees in the Grid Singularity Exchange.","title":"Implement dynamic grid fees with Aziiz strategy"},{"location":"heat-pump/","text":"Heat Pump Asset Configuration Options \u00b6 Express Mode \u00b6 In the express heat pump configuration mode, the user is provided with a template (synthetic) heat pump model to include as an asset at a select location in the simulated local energy market by naming the asset and setting its location: 1. Name: select a unique name for the heat pump; 2. Location: the location selected by the user is automatically uploaded. Figure 2.23 : Heat pump express mode configuration options in the Grid Singularity Exchange web-based interface (Singularity Map) For more information, on the parameters and default values used to create the template heat pump digital twin, see Table below . Advanced Mode \u00b6 In the advanced heat pump configuration mode, there are two settings referring to its Capacity and Profile and the Trading Strategy as shown in the figure below: Figure 2.24 : Heat pump advanced mode configuration options in the Grid Singularity Exchange web-based interface (Singularity Map) Under the Capacity and Profile tab, the following parameters can be defined, described in Table 2.1 below: Heat pump type Minimum and maximum temperature Heat pump tank volume Heat pump consumption profile Initial temperature External (ambient) temperature profile Maximum power rating for the heat pump Figure 2.25 : Capacity and profile inputs in the advanced mode heat pump configuration in the Grid Singularity Exchange web-based interface (Singularity Map) Under the Trading Strategy tab, the following parameters can be defined, described in the Table 2.1 below: Initial buying rate Final buying rate Preferred buying rate Figure 2.26 : Trading strategy inputs in the advanced mode heat pump configurationin the Grid Singularity Exchange web-based interface Table 2.1: parameter-tableHeat Pump Configuration Parameters in the Grid Singularity Exchange Parameters Description Unit Data Type Mandatory User Input Default Value Name Name of the asset - Text Yes N/A Heat Pump Type Heat pump type specification from drop-down menu: Air-to-Water or Water-to-Water - Category value No N/A Minimum Temperature Minimum water temperature of the heat pump storage (provided by the user based on personal preference; if unavailable, set at 25\u00b0C since this is the comfort temperature setting for underfloor heating) \u00b0C Constant Value No 25 Maximum Temperature Maximum water temperature of the heat pump storage (provided by the user based on personal preference; if unavailable, set at 60\u00b0C based on analysis of specification sheets for several heat pumps where value ranges between 55 and 65\u00b0C) \u00b0C Constant Value No 60 Tank Volume Volume/capacity of the thermal storage tank based on technical sheet (nameplate) of the storage tank (if unavailable average volume of 500l set as default based on analysis of specification sheets for consumer heat pump storages) l Constant Value No 500 Consumption Profile Electricity consumption profile of the heat pump (amount of energy the heat pump consumes in kWh to produce heat), to be added by the user kWh Profile /csv file Yes N/A Initial temperature Initial water temperature of the heat pump storage at the beginning of the simulation (provided by the user based on personal preference; if unavailable, set at the same value as the minimum temperature) \u00baC Constant Value No 25 External Temperature Profile Ambient temperature profile at the community location based on historical weather data (user input, which can be derived from Copernicus Climate Change Service or similar service and resampled to the 15-minute or another market slot resolution) \u00baC Profile /csv file Yes N/A Maximum Power Rating Maximum electricity demand by the heat pump based on technical sheet (nameplate) of the heat pump Note: If unavailable, it can be estimated by using the historical data to calculate the maximum electricity consumption over the coldest month for each heat pump in the community separately, since the heat demand during this month is at the highest level, and then deriving the mean value and setting this value as a standard heat pump capacity. kW Constant value No 3 Initial buying rate Minimum buying price for the heat pump in each time slot (based on user input, can be set to feed-in-tariff or another value; the default is 0 since most heat pump owners prefer maximum storage / self-consumption) cts/kWh Constant value No 0 Final buying rate Maximum buying price for the heat pump in each time slot. The user can choose between \u201cUser Input\u201d and \u201cMarket maker rate\u201d. cts/kWh Constant value No Market-maker-rate Preferred buying rate Set to buy energy at a price that is equal or less than a certain value in each time slot based on a smart trading algorithm or input value that can be (i) Initial buying rate, in case your strategy is just to keep the heat pump operational to satisfy your own demand, or (ii) Feed-in-tariff in case your strategy is intending to maintain a minimum revenue level for another asset like PV, or (iii) Final buying rate, in case your strategy is intending to maximise storage regardless of the cost, or (iv) Average or another value between the feed-in-tariff and the market maker rate to balance cost and supply security preferences. cts/kWh Constant value No 15 Heat Pump Asset Trading Strategy \u00b6 The heat hump places bids for electrical energy ranging from an initial to final buying rate, with prices increasing incrementally within the market slot upon the update interval. Asset owners (or managers) can either set the final rate as a default preferred buying rate or select a preferred buying rate based on a smart trading algorithm. When the heat pump bids are below the preferred buying rate, the heat pump tries to consume as much energy as possible to satisfy the demand, while also charging the thermal storage for future use, thus maximising the benefit from lower electricity prices ( case a ). On the other hand, if the electricity price is higher than the specified buying price, the heat pump only consumes the required energy to maintain the storage at the same temperature level as the one before the energy trade occurs (i.e. consumes only the energy required to satisfy the asset owner\u2019s heat demand), aiming to minimise the costs incurred by the increased energy prices ( case b ). a. Bid rate <= Preferred buying rate \u00b6 If the bid price is below the preferred buying rate, the heat pump strategy is to consume the maximum amount of energy. The maximum energy that the heat pump can buy at any point in time is calculated based on the following equation: \\[ E_{to buy} = min(P_{max} * t_{slot}, (T_{max} - T_{curr} + T_{decrease}) * (0.00116 * V_{tank} * \\rho_{water}) / COP) \\] where \\(P_{max}\\) is the maximum power rating \\(t_{slot}\\) is the slot length \\(T_{max}\\) is the maximum temperature of the storage tank \\(T_{curr}\\) is the current temperature of the storage tank \\(T_{decrease}\\) is the temperature decrease of the storage tank due to heat consumption \\(V_{tank}\\) is the volume of the storage tank \\(\\rho_{water}\\) is the density of water \\(COP\\) is the coefficient of performance of the heat pump; depends on the heat pump type, and \\(\\Delta T = T_{curr} - T_{ambient}\\) b. Bid rate > Preferred buying rate \u00b6 In this situation, the heat pump strategy is to consume the least possible amount of energy in order to keep the temperature at the same level, since the prices are relatively high. Two different situations can arise: \\(T_{curr} > T_{min} + T_{decrease}\\) : In this case, the heat pump does not consume any energy (it\u2019s not commanded to function because the temperature will be within the temperature limits even if some heat is consumed in the market slot). Therefore, \\(E_{tobuy} = 0\\) \\(T_{curr} <= T_{min} + T_{decrease}\\) : In this case the heat pump is forced to function, and it consumes the energy to maintain the temperature at the minimum, taking into account the energy consumption of the user\u2019s premise. In all cases, the maximum power rating is respected, meaning that not more energy is requested than the energy equivalent of the Maximum Power Rating. Figure 2.27 : Graph showing the Initial, Final and Preferred Buying Rate in relation to Minimum and Maximum Energy Consumed Figure 2.28 : Graph showing the heat pump function to maintain temperature within the comfort limits","title":"Heat Pump"},{"location":"heat-pump/#heat-pump-asset-configuration-options","text":"","title":"Heat Pump Asset Configuration Options"},{"location":"heat-pump/#express-mode","text":"In the express heat pump configuration mode, the user is provided with a template (synthetic) heat pump model to include as an asset at a select location in the simulated local energy market by naming the asset and setting its location: 1. Name: select a unique name for the heat pump; 2. Location: the location selected by the user is automatically uploaded. Figure 2.23 : Heat pump express mode configuration options in the Grid Singularity Exchange web-based interface (Singularity Map) For more information, on the parameters and default values used to create the template heat pump digital twin, see Table below .","title":"Express Mode"},{"location":"heat-pump/#advanced-mode","text":"In the advanced heat pump configuration mode, there are two settings referring to its Capacity and Profile and the Trading Strategy as shown in the figure below: Figure 2.24 : Heat pump advanced mode configuration options in the Grid Singularity Exchange web-based interface (Singularity Map) Under the Capacity and Profile tab, the following parameters can be defined, described in Table 2.1 below: Heat pump type Minimum and maximum temperature Heat pump tank volume Heat pump consumption profile Initial temperature External (ambient) temperature profile Maximum power rating for the heat pump Figure 2.25 : Capacity and profile inputs in the advanced mode heat pump configuration in the Grid Singularity Exchange web-based interface (Singularity Map) Under the Trading Strategy tab, the following parameters can be defined, described in the Table 2.1 below: Initial buying rate Final buying rate Preferred buying rate Figure 2.26 : Trading strategy inputs in the advanced mode heat pump configurationin the Grid Singularity Exchange web-based interface Table 2.1: parameter-tableHeat Pump Configuration Parameters in the Grid Singularity Exchange Parameters Description Unit Data Type Mandatory User Input Default Value Name Name of the asset - Text Yes N/A Heat Pump Type Heat pump type specification from drop-down menu: Air-to-Water or Water-to-Water - Category value No N/A Minimum Temperature Minimum water temperature of the heat pump storage (provided by the user based on personal preference; if unavailable, set at 25\u00b0C since this is the comfort temperature setting for underfloor heating) \u00b0C Constant Value No 25 Maximum Temperature Maximum water temperature of the heat pump storage (provided by the user based on personal preference; if unavailable, set at 60\u00b0C based on analysis of specification sheets for several heat pumps where value ranges between 55 and 65\u00b0C) \u00b0C Constant Value No 60 Tank Volume Volume/capacity of the thermal storage tank based on technical sheet (nameplate) of the storage tank (if unavailable average volume of 500l set as default based on analysis of specification sheets for consumer heat pump storages) l Constant Value No 500 Consumption Profile Electricity consumption profile of the heat pump (amount of energy the heat pump consumes in kWh to produce heat), to be added by the user kWh Profile /csv file Yes N/A Initial temperature Initial water temperature of the heat pump storage at the beginning of the simulation (provided by the user based on personal preference; if unavailable, set at the same value as the minimum temperature) \u00baC Constant Value No 25 External Temperature Profile Ambient temperature profile at the community location based on historical weather data (user input, which can be derived from Copernicus Climate Change Service or similar service and resampled to the 15-minute or another market slot resolution) \u00baC Profile /csv file Yes N/A Maximum Power Rating Maximum electricity demand by the heat pump based on technical sheet (nameplate) of the heat pump Note: If unavailable, it can be estimated by using the historical data to calculate the maximum electricity consumption over the coldest month for each heat pump in the community separately, since the heat demand during this month is at the highest level, and then deriving the mean value and setting this value as a standard heat pump capacity. kW Constant value No 3 Initial buying rate Minimum buying price for the heat pump in each time slot (based on user input, can be set to feed-in-tariff or another value; the default is 0 since most heat pump owners prefer maximum storage / self-consumption) cts/kWh Constant value No 0 Final buying rate Maximum buying price for the heat pump in each time slot. The user can choose between \u201cUser Input\u201d and \u201cMarket maker rate\u201d. cts/kWh Constant value No Market-maker-rate Preferred buying rate Set to buy energy at a price that is equal or less than a certain value in each time slot based on a smart trading algorithm or input value that can be (i) Initial buying rate, in case your strategy is just to keep the heat pump operational to satisfy your own demand, or (ii) Feed-in-tariff in case your strategy is intending to maintain a minimum revenue level for another asset like PV, or (iii) Final buying rate, in case your strategy is intending to maximise storage regardless of the cost, or (iv) Average or another value between the feed-in-tariff and the market maker rate to balance cost and supply security preferences. cts/kWh Constant value No 15","title":"Advanced Mode"},{"location":"heat-pump/#heat-pump-asset-trading-strategy","text":"The heat hump places bids for electrical energy ranging from an initial to final buying rate, with prices increasing incrementally within the market slot upon the update interval. Asset owners (or managers) can either set the final rate as a default preferred buying rate or select a preferred buying rate based on a smart trading algorithm. When the heat pump bids are below the preferred buying rate, the heat pump tries to consume as much energy as possible to satisfy the demand, while also charging the thermal storage for future use, thus maximising the benefit from lower electricity prices ( case a ). On the other hand, if the electricity price is higher than the specified buying price, the heat pump only consumes the required energy to maintain the storage at the same temperature level as the one before the energy trade occurs (i.e. consumes only the energy required to satisfy the asset owner\u2019s heat demand), aiming to minimise the costs incurred by the increased energy prices ( case b ).","title":"Heat Pump Asset Trading Strategy"},{"location":"heat-pump/#a-bid-rate-preferred-buying-rate","text":"If the bid price is below the preferred buying rate, the heat pump strategy is to consume the maximum amount of energy. The maximum energy that the heat pump can buy at any point in time is calculated based on the following equation: \\[ E_{to buy} = min(P_{max} * t_{slot}, (T_{max} - T_{curr} + T_{decrease}) * (0.00116 * V_{tank} * \\rho_{water}) / COP) \\] where \\(P_{max}\\) is the maximum power rating \\(t_{slot}\\) is the slot length \\(T_{max}\\) is the maximum temperature of the storage tank \\(T_{curr}\\) is the current temperature of the storage tank \\(T_{decrease}\\) is the temperature decrease of the storage tank due to heat consumption \\(V_{tank}\\) is the volume of the storage tank \\(\\rho_{water}\\) is the density of water \\(COP\\) is the coefficient of performance of the heat pump; depends on the heat pump type, and \\(\\Delta T = T_{curr} - T_{ambient}\\)","title":"a. Bid rate &lt;= Preferred buying rate"},{"location":"heat-pump/#b-bid-rate-preferred-buying-rate","text":"In this situation, the heat pump strategy is to consume the least possible amount of energy in order to keep the temperature at the same level, since the prices are relatively high. Two different situations can arise: \\(T_{curr} > T_{min} + T_{decrease}\\) : In this case, the heat pump does not consume any energy (it\u2019s not commanded to function because the temperature will be within the temperature limits even if some heat is consumed in the market slot). Therefore, \\(E_{tobuy} = 0\\) \\(T_{curr} <= T_{min} + T_{decrease}\\) : In this case the heat pump is forced to function, and it consumes the energy to maintain the temperature at the minimum, taking into account the energy consumption of the user\u2019s premise. In all cases, the maximum power rating is respected, meaning that not more energy is requested than the energy equivalent of the Maximum Power Rating. Figure 2.27 : Graph showing the Initial, Final and Preferred Buying Rate in relation to Minimum and Maximum Energy Consumed Figure 2.28 : Graph showing the heat pump function to maintain temperature within the comfort limits","title":"b. Bid rate &gt; Preferred buying rate"},{"location":"heat-pumps-general/","text":"Heat Pumps and District Heating \u00b6 A heat pump is a device used to heat water and premises by extracting heat from one place (air source, water source, and ground source/geothermal) and moving it to another (some pumps also have a cooling function but only heating is considered here). Depending on the external temperature and the heating needs, a heat pump usually has a coefficient of performance (COP) of around 2-4 , which means that it is able to produce 2-4 kWh of heat by consuming 1 kWh of electricity. In the Grid Singularity Exchange, the heat pump is modelled as a load, which consumes electricity and generates heat (see heat pump configuration options here ). If the heat pump has a storage option (water tank) then this is accounted for by a dedicated Heat Pump Asset Trading Strategy , which facilitates flexibility trading by leveraging the heat storage capabilities of the water tank. For homes (or other energy community participants) that are connected to district heating we have developed a digital twin of a heat pump that mimics and replaces the heat demand currently satisfied by a district heating network, modelled as a virtual heat pump (VHP) with storage and a related trading strategy. This VHP implementation is available exclusively in the backend source code , since it will likely be used exclusively by energy researchers to simulate how district heating could be replaced by a heat pump to compare their respective performance. Inversely, the VHP can also be used to calculate the heat demand of homes or other energy community participants, and consequently enable the simulation of a district heating connection that would satisfy this heat demand as opposed to electricity assets. Finally, for simulations that simply want to account for the district heating connection without considering a potential replacement with heat pumps, the digital twin of the district heating supply for the measured heat demand can be modelled as a \"heat market maker\", i.e. digital trading agent with a specific trading strategy representing the district heating provider, which will only sell heat energy to the heat demand digital twin of the respective community member. The selling price of this market maker will be the district heating price that the heat consumer currently pays, in cents/kWh. The heat demand digital twin, in turn, is modelled as a load with a \u201cconsumption profile\u201d defined by the measured heat demand in kWh. Thus, the \u201cheat market maker\u201d will only be used in order to cover the heat demand of the heat load and accounting for the monetary cost of heating.","title":"Heat Pump & Virtual Heat Pump Overview"},{"location":"heat-pumps-general/#heat-pumps-and-district-heating","text":"A heat pump is a device used to heat water and premises by extracting heat from one place (air source, water source, and ground source/geothermal) and moving it to another (some pumps also have a cooling function but only heating is considered here). Depending on the external temperature and the heating needs, a heat pump usually has a coefficient of performance (COP) of around 2-4 , which means that it is able to produce 2-4 kWh of heat by consuming 1 kWh of electricity. In the Grid Singularity Exchange, the heat pump is modelled as a load, which consumes electricity and generates heat (see heat pump configuration options here ). If the heat pump has a storage option (water tank) then this is accounted for by a dedicated Heat Pump Asset Trading Strategy , which facilitates flexibility trading by leveraging the heat storage capabilities of the water tank. For homes (or other energy community participants) that are connected to district heating we have developed a digital twin of a heat pump that mimics and replaces the heat demand currently satisfied by a district heating network, modelled as a virtual heat pump (VHP) with storage and a related trading strategy. This VHP implementation is available exclusively in the backend source code , since it will likely be used exclusively by energy researchers to simulate how district heating could be replaced by a heat pump to compare their respective performance. Inversely, the VHP can also be used to calculate the heat demand of homes or other energy community participants, and consequently enable the simulation of a district heating connection that would satisfy this heat demand as opposed to electricity assets. Finally, for simulations that simply want to account for the district heating connection without considering a potential replacement with heat pumps, the digital twin of the district heating supply for the measured heat demand can be modelled as a \"heat market maker\", i.e. digital trading agent with a specific trading strategy representing the district heating provider, which will only sell heat energy to the heat demand digital twin of the respective community member. The selling price of this market maker will be the district heating price that the heat consumer currently pays, in cents/kWh. The heat demand digital twin, in turn, is modelled as a load with a \u201cconsumption profile\u201d defined by the measured heat demand in kWh. Thus, the \u201cheat market maker\u201d will only be used in order to cover the heat demand of the heat load and accounting for the monetary cost of heating.","title":"Heat Pumps and District Heating"},{"location":"home/","text":"After clicking on the \u201cAdd a Home\u201d button, users can add homes to represent households or other local energy market (LEM) participants / community members by selecting one of the available template home types, or a custom home. Figure 2.7 : Build Community icon in the Grid Singularity Exchange web-based interface (Singularity Map). The custom home has no assets included initially and it is suited for users who prefer to configure the home\u2019s energy assets manually and/or upload their own energy data. The trading preferences for assets within the custom home can also be edited. The template homes, in turn, have preconfigured assets whose type and number can be seen in the individual listings. All template homes have at least one consumption (load) profile by default, while some others also have PV generation profiles (solar panels) or batteries (storage). For example, a \u201cRetired couple\u201d template home has one asset included (consumption profile), as shown in the figure below. The \u201c6-apartments building + PV\u201d template home has seven assets, including consumption profiles for each of the apartments and a shared PV generation profile. While template homes serve to quickly model an energy community, users can still add, remove or edit assets and their trade pricing preferences in the templates to assess the impact of different configurations. The template homes have been created using data from Load Profile Generator and Energy Data Map to represent the typical consumption and generation for different types of LEM participants. Please note that while the energy production profiles generated from Energy Data Map are location-specific, the consumption profiles are randomly generated. As a default setting, a home functions as a market, where multiple assets can trade with each other, as well as with assets in other homes. An additional feature available in the backend is to group homes together to form a community which can trade with other communities. Home Configuration Options: \u00b6 Express Mode \u00b6 Name: select a unique name for the home; Location: the location selected by the user is automatically uploaded; Preconfigured homes can be added from the template home library and then further edited based on user preferences (e.g. a shared battery can be added to a pre-configured 6-apartment building with one PV). Advanced Mode \u00b6 In the advanced mode, the following settings are available Exchange mechanism: select a market types for clearing bids and offers (note: at the moment only the spot market is available) Grid fees: choose to switch on \u2705 or off \ud83c\udd87. If switched on, users can enter a constant grid fee value expressed in cents/kWh (note: this value will then function as a fee that will be applied to each trade that passes through or is cleared in this market to account for grid cost) Energy peak percentage: choose to switch on \u2705 or off \ud83c\udd87. if switched on, set baseline peak import and export rates to calculate the peak percentage Figure 2.8 : Advanced Home Configuration Options in the Grid Singularity Exchange web-based interface (Singularity Map)","title":"Home"},{"location":"home/#home-configuration-options","text":"","title":"Home Configuration Options:"},{"location":"home/#express-mode","text":"Name: select a unique name for the home; Location: the location selected by the user is automatically uploaded; Preconfigured homes can be added from the template home library and then further edited based on user preferences (e.g. a shared battery can be added to a pre-configured 6-apartment building with one PV).","title":"Express Mode"},{"location":"home/#advanced-mode","text":"In the advanced mode, the following settings are available Exchange mechanism: select a market types for clearing bids and offers (note: at the moment only the spot market is available) Grid fees: choose to switch on \u2705 or off \ud83c\udd87. If switched on, users can enter a constant grid fee value expressed in cents/kWh (note: this value will then function as a fee that will be applied to each trade that passes through or is cleared in this market to account for grid cost) Energy peak percentage: choose to switch on \u2705 or off \ud83c\udd87. if switched on, set baseline peak import and export rates to calculate the peak percentage Figure 2.8 : Advanced Home Configuration Options in the Grid Singularity Exchange web-based interface (Singularity Map)","title":"Advanced Mode"},{"location":"implement-grid-fees-walkthrough/","text":"The Grid Singularity Grid Operator API is designed for grid operators (notably Distribution System Operators or DSOs) to manage congestion and grid constraints in different markets across the grid. The structure is designed so that multiple markets can be managed by a single agent (digital representation of the grid operator preferences), allowing information to be aggregated for integrated grid management. It allows users to create agents that can dynamically change the grid fee in different markets. These agents can request and receive information through the Grid Operator API, feed that information into a tariff model, and submit grid fees through the Exchange SDK to change grid fees on the exchange. For more information, see this article . To actively manage grid congestion by sending new grid fees at every market slot for different markets at different levels of the grid, please follow the following steps: Install the Grid Singularity Exchange SDK on your computer by launching the following commands on your terminal window: Install gsy-e-sdk mkvirtualenv gsy-e-sdk pip install https://github.com/gridsingularity/gsy-e-sdk.git Update gsy-e-sdk (needed when an update is deployed) pip uninstall -y gsy-e-sdk pip install git+https://github.com/gridsingularity/gsy-e-sdk.git Install the following Python packages pip install pandas pip install openpyxl Go to the Registry and Scoreboard section of the Collaboration of your interest and apply to every market that you wish to connect and to actively manage by sending new grid fees for each market slot. Then click on Submit your actions . If you have not already created a Collaboration / Canary Test Network, please follow instructions respectively here or here first. Notify Grid Singularity administration by sending an email to contact@gridsingularity.com to accept your applications) (note: this action will be automated in the future). Edit the Grid Operator SDK Script template to experiment with different grid fee models. Launch the Grid Operator SDK Script to connect with the Grid Singularity Collaboration / Canary Test Network. A video tutorial is also available here . Run the Collaboration or notify the collaboration owner that you are ready.","title":"Grid Singularity Grid Operator API Overview"},{"location":"ios-installation-instructions/","text":"Step 1: Installation prerequisites: \u00b6 make sure the command line compiler tools are installed: \u00b6 xcode-select --install (Select Install in the window that opens) Step 2: Install homebrew \u00b6 /bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\" Step 3: Install other required libraries: \u00b6 brew install automake libtool pkg-config libffi gmp openssl readline xz Step 4: Install pyenv: \u00b6 brew install pyenv echo -e 'if command -v pyenv 1>/dev/null 2>&1; then\\n eval \"$(pyenv init -)\"\\nfi' >> ~/.bash_profile Step 5: Close and re-open the terminal \u00b6 Step 6: Install Python 3.6 and set as default: \u00b6 pyenv install 3.8.6 pyenv global 3.8.6 Step 7: Install virtualenvwrapper: \u00b6 pip3 install virtualenvwrapper echo -e 'export WORKON_HOME=~/Envs\\nsource ~/.pyenv/versions/3.8.6/bin/virtualenvwrapper.sh' >> ~/.bash_profile Step 8: Setup paths for compiling Python libraries: \u00b6 echo -e 'BREW_PREFIX=\"$(brew --prefix openssl)\"\\nexport CFLAGS=\"-I${BREW_PREFIX}/include\"\\nexport LDFLAGS=\"-L${BREW_PREFIX}/lib\"' >> ~/.bash_profile Step 9: Close and re-open the terminal \u00b6 Step 10: Clone gsy-e repository (do this inside the directory where you want the project to be): \u00b6 git clone \"https://github.com/gridsingularity/gsy-e.git\" cd gsy-e Step 11: Create and initialise gsy-e virtualenv \u00b6 brew install npm npm install --global ganache-cli mkvirtualenv gsy-e pip3 install pendulum pip-tools pip3 install -e . You now should have a working gsy-e setup. For help in the terminal ani to test your installation, run gsy-e run -\u2013help .","title":"Mac Installation Instructions"},{"location":"ios-installation-instructions/#step-1-installation-prerequisites","text":"","title":"Step 1: Installation prerequisites:"},{"location":"ios-installation-instructions/#make-sure-the-command-line-compiler-tools-are-installed","text":"xcode-select --install (Select Install in the window that opens)","title":"make sure the command line compiler tools are installed:"},{"location":"ios-installation-instructions/#step-2-install-homebrew","text":"/bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\"","title":"Step 2: Install homebrew"},{"location":"ios-installation-instructions/#step-3-install-other-required-libraries","text":"brew install automake libtool pkg-config libffi gmp openssl readline xz","title":"Step 3: Install other required libraries:"},{"location":"ios-installation-instructions/#step-4-install-pyenv","text":"brew install pyenv echo -e 'if command -v pyenv 1>/dev/null 2>&1; then\\n eval \"$(pyenv init -)\"\\nfi' >> ~/.bash_profile","title":"Step 4: Install pyenv:"},{"location":"ios-installation-instructions/#step-5-close-and-re-open-the-terminal","text":"","title":"Step 5: Close and re-open the terminal"},{"location":"ios-installation-instructions/#step-6-install-python-36-and-set-as-default","text":"pyenv install 3.8.6 pyenv global 3.8.6","title":"Step 6: Install Python 3.6 and set as default:"},{"location":"ios-installation-instructions/#step-7-install-virtualenvwrapper","text":"pip3 install virtualenvwrapper echo -e 'export WORKON_HOME=~/Envs\\nsource ~/.pyenv/versions/3.8.6/bin/virtualenvwrapper.sh' >> ~/.bash_profile","title":"Step 7: Install virtualenvwrapper:"},{"location":"ios-installation-instructions/#step-8-setup-paths-for-compiling-python-libraries","text":"echo -e 'BREW_PREFIX=\"$(brew --prefix openssl)\"\\nexport CFLAGS=\"-I${BREW_PREFIX}/include\"\\nexport LDFLAGS=\"-L${BREW_PREFIX}/lib\"' >> ~/.bash_profile","title":"Step 8: Setup paths for compiling Python libraries:"},{"location":"ios-installation-instructions/#step-9-close-and-re-open-the-terminal","text":"","title":"Step 9: Close and re-open the terminal"},{"location":"ios-installation-instructions/#step-10-clone-gsy-e-repository-do-this-inside-the-directory-where-you-want-the-project-to-be","text":"git clone \"https://github.com/gridsingularity/gsy-e.git\" cd gsy-e","title":"Step 10: Clone gsy-e repository (do this inside the directory where you want the project to be):"},{"location":"ios-installation-instructions/#step-11-create-and-initialise-gsy-e-virtualenv","text":"brew install npm npm install --global ganache-cli mkvirtualenv gsy-e pip3 install pendulum pip-tools pip3 install -e . You now should have a working gsy-e setup. For help in the terminal ani to test your installation, run gsy-e run -\u2013help .","title":"Step 11: Create and initialise gsy-e virtualenv"},{"location":"launch_simulation/","text":"Simulation launch \u00b6 Once the entire market architecture is modelled, including energy assets, the user can launch the trading simulation by running a command line including desired setup features: -d, --duration: simulated duration of simulation [default: 1d] -t, --tick-length: simulated duration of a tick [default: 1s] -s, --slot-length: simulated duration of a market slot [default: 15m] -c, --cloud-coverage: Cloud coverage, 0 for sunny, 1 for partial coverage, 2 for clouds. [default: 0] --slot-length-realtime: Desired duration of slot in realtime [default: 0s] Example simulation call: gsy-e -l ERROR run --duration=1d --tick-length=1s --slot-length=15m --cloud-coverage=0 --setup default_2a Getting help in the command line: gsy-e run --help returns Usage: gsy-e [OPTIONS] COMMAND [ARGS]... Entrypoint for command-line interface interaction. Options: -l, --log-level [CRITICAL|FATAL|ERROR|WARN|WARNING|INFO|DEBUG|NOTSET|TRACE] Log level [default: INFO] --help Show this message and exit. Commands: run* Configure settings and run a simulation. (gsy-e) hannesd@Hannes-MBP gsy-e % gsy-e run --help Usage: gsy-e run [OPTIONS] Configure settings and run a simulation. Options: -d, --duration INTERVAL Duration of simulation [default: 1d] -t, --tick-length INTERVAL Length of a tick [default: 1s] -s, --slot-length INTERVAL Length of a market slot [default: 15m] --slot-length-realtime INTERVAL Desired duration of slot in realtime [default: 0m] -c, --cloud-coverage INTEGER Cloud coverage, 0 for sunny, 1 for partial coverage, 2 for clouds. [default: 0] --setup TEXT Simulation setup module use. Available modules: [1000_houses, api_setup.default_community, area_events.cloud_coverage_event, area_events.disable_interval_event, area_events.disconnect_interval_event, area_events.isolated_connect_event, area_events.isolated_disable_event, area_events.isolated_disconnect_event, area_events.isolated_enable_event, area_events.load_event, area_events.predefined_load_event, area_events.predefined_pv_event, area_events.pv_event, area_events.storage_event, area_events.userprofile_pv_event, balancing_market.default_2a, balancing_market.one_load_one_pv, balancing_market.one_load_one_storage, balancing_market.one_storage_one_pv, balancing_market.test_device_registry, balancing_market.two_sided_one_load_one_pv, config_parameter_test, default_2, default_2a, default_2b, default_3, default_3_pv_only, default_3a, default_3b, default_4, default_5, default_csv, forward, grid_fees.constant_grid_fees, grid_fees.default_2a, grid_fees.no_trades_high_fees, grid_fees.non_compounded_grid_fees, grid_fees.test_grid_fees, jira.d3asim_1024, jira.d3asim_1139, jira.d3asim_1525, jira.d3asim_1531, jira.d3asim_1535, jira.d3asim_1862, jira.d3asim_1896, jira.d3asim_2034, jira.d3asim_2244, jira.d3asim_2303, jira.d3asim_2420, jira.d3asim_2421, jira.d3asim_2422, jira.d3asim_2948, jira.d3asim_778, jira.d3asim_780, jira.d3asim_871, jira.d3asim_895, jira.d3asim_962, jira.default_2off_d3asim_1475, jira.default_595, jira.default_645, jira.default_737, json_arg, json_file, kpi.d3asim_2103, kpi.d3asim_2103_2_sided_pab, kpi.d3asim_2103_nopv1, kpi.d3asim_2103_nopv1_2_sided_pab, kpi.d3asim_2262, kpi.d3asim_3464_family_with_pv, kpi.d3asim_3464_family_with_pv_ess, kpi.d3asim_3464_young_couple, kpi.gsye_1_savings_kpi_test_setup, kpi.house_fully_self_sufficient, kpi.house_not_self_sufficient, kpi.house_partially_self_sufficient, kpi.house_self_sufficient_with_ess, kpi.infinitebus_pv_load, kpi.market_maker_and_load, kpi.penalty_load, kpi.penalty_pv, kpi.root_area_self_sufficient_with_infinitebus, matching_engine_setup.external_matching_engine, power_flow.baseline_peak_energy, power_flow.net_energy_flow, power_flow.test_power_flow, redis_communication_default_2a, sam_config, sam_config_const_load, sam_config_small, scm.default_2a, scm.external, settlement_market.default_2a_settlement, settlement_market.settlement_market, settlement_market.simple, settlement_market.simple_load_cell_tower, sonnenplatz, strategy_tests.commercial_producer_market_maker_rate, strategy_tests.ess_capacity_based_sell_offer, strategy_tests.ess_sell_offer_decrease_rate, strategy_tests.external_devices, strategy_tests.external_devices_grid_fees, strategy_tests.external_devices_send_forecasts, strategy_tests.external_devices_settlement_market, strategy_tests.external_ess_bids, strategy_tests.external_ess_offers, strategy_tests.external_market_stats, strategy_tests.external_smart_meter, strategy_tests.finite_power_plant, strategy_tests.finite_power_plant_profile, strategy_tests.future_market_strategy, strategy_tests.heat_pump, strategy_tests.home_cp_ess_load, strategy_tests.home_hybrid_pv_ess_load, strategy_tests.infinite_bus, strategy_tests.market_maker_not_grid_connected, strategy_tests.market_maker_strategy, strategy_tests.predefined_pv_test, strategy_tests.pv_const_price_decrease, strategy_tests.pv_final_selling_rate, strategy_tests.pv_max_panel_output, strategy_tests.pv_max_panel_power_global, strategy_tests.smart_meter_setup, strategy_tests.storage_buys_and_offers, strategy_tests.storage_strategy_break_even_hourly, strategy_tests.user_profile_load_csv, strategy_tests.user_profile_load_csv_multiday, strategy_tests.user_profile_load_dict, strategy_tests.user_profile_pv_csv, strategy_tests.user_profile_pv_dict, strategy_tests.user_profile_wind_csv, strategy_tests.user_rate_profile_load_dict, test_hp, tobalaba.one_producer_load, two_sided_market.default_2a, two_sided_market.default_2a_high_res_graph, two_sided_market.infinite_bus, two_sided_market.jira_d3asim-1675, two_sided_market.load_fitlimits_match, two_sided_market.offer_reposted_at_old_offer_rate, two_sided_market.one_cep_one_load, two_sided_market.one_cep_one_load_immediate_match, two_sided_market.one_load_5_pv_partial, two_sided_market.one_load_one_storage, two_sided_market.one_pv_one_load, two_sided_market.one_pv_one_storage, two_sided_market.one_storage_5_pv_partial, two_sided_market.user_min_rate_profile_load_dict, two_sided_market.with_balancing_market, two_sided_pay_as_clear.default_2a, two_sided_pay_as_clear.jira_d3asim_1690, two_sided_pay_as_clear.multiple_offers_one_bid, two_sided_pay_as_clear.one_offer_multiple_bids, two_sided_pay_as_clear.one_offer_one_bid, two_sided_pay_as_clear.test_clearing_energy] -g, --settings-file TEXT Settings file path --seed TEXT Manually specify random seed --paused Start simulation in paused state --pause-at TEXT Automatically pause at a certain time. Accepted Input formats: (YYYY-MM-DD, HH:mm) [default: disabled] --incremental Pause the simulation at the end of each time slot. --repl / --no-repl Start REPL after simulation run. [default: no-repl] --no-export Skip export of simulation data --export-path TEXT Specify a path for the csv export files (default: ~/gsy-e-simulation) --enable-bc Run simulation on Blockchain --enable-external-connection External Agents interaction to simulation during runtime --start-date DATE Start date of the Simulation (YYYY-MM-DD) [default: 2023-10-04] --enable-dof / --disable-dof Enable or disable Degrees of Freedom (orders can't contain attributes/requirements). -m, --market-type INTEGER Market type. 1 for one-sided market, 2 for two-sided market, 3 for coefficient-based trading. [default: 1] --help Show this message and exit.","title":"Launching Simulation"},{"location":"launch_simulation/#simulation-launch","text":"Once the entire market architecture is modelled, including energy assets, the user can launch the trading simulation by running a command line including desired setup features: -d, --duration: simulated duration of simulation [default: 1d] -t, --tick-length: simulated duration of a tick [default: 1s] -s, --slot-length: simulated duration of a market slot [default: 15m] -c, --cloud-coverage: Cloud coverage, 0 for sunny, 1 for partial coverage, 2 for clouds. [default: 0] --slot-length-realtime: Desired duration of slot in realtime [default: 0s] Example simulation call: gsy-e -l ERROR run --duration=1d --tick-length=1s --slot-length=15m --cloud-coverage=0 --setup default_2a Getting help in the command line: gsy-e run --help returns Usage: gsy-e [OPTIONS] COMMAND [ARGS]... Entrypoint for command-line interface interaction. Options: -l, --log-level [CRITICAL|FATAL|ERROR|WARN|WARNING|INFO|DEBUG|NOTSET|TRACE] Log level [default: INFO] --help Show this message and exit. Commands: run* Configure settings and run a simulation. (gsy-e) hannesd@Hannes-MBP gsy-e % gsy-e run --help Usage: gsy-e run [OPTIONS] Configure settings and run a simulation. Options: -d, --duration INTERVAL Duration of simulation [default: 1d] -t, --tick-length INTERVAL Length of a tick [default: 1s] -s, --slot-length INTERVAL Length of a market slot [default: 15m] --slot-length-realtime INTERVAL Desired duration of slot in realtime [default: 0m] -c, --cloud-coverage INTEGER Cloud coverage, 0 for sunny, 1 for partial coverage, 2 for clouds. [default: 0] --setup TEXT Simulation setup module use. Available modules: [1000_houses, api_setup.default_community, area_events.cloud_coverage_event, area_events.disable_interval_event, area_events.disconnect_interval_event, area_events.isolated_connect_event, area_events.isolated_disable_event, area_events.isolated_disconnect_event, area_events.isolated_enable_event, area_events.load_event, area_events.predefined_load_event, area_events.predefined_pv_event, area_events.pv_event, area_events.storage_event, area_events.userprofile_pv_event, balancing_market.default_2a, balancing_market.one_load_one_pv, balancing_market.one_load_one_storage, balancing_market.one_storage_one_pv, balancing_market.test_device_registry, balancing_market.two_sided_one_load_one_pv, config_parameter_test, default_2, default_2a, default_2b, default_3, default_3_pv_only, default_3a, default_3b, default_4, default_5, default_csv, forward, grid_fees.constant_grid_fees, grid_fees.default_2a, grid_fees.no_trades_high_fees, grid_fees.non_compounded_grid_fees, grid_fees.test_grid_fees, jira.d3asim_1024, jira.d3asim_1139, jira.d3asim_1525, jira.d3asim_1531, jira.d3asim_1535, jira.d3asim_1862, jira.d3asim_1896, jira.d3asim_2034, jira.d3asim_2244, jira.d3asim_2303, jira.d3asim_2420, jira.d3asim_2421, jira.d3asim_2422, jira.d3asim_2948, jira.d3asim_778, jira.d3asim_780, jira.d3asim_871, jira.d3asim_895, jira.d3asim_962, jira.default_2off_d3asim_1475, jira.default_595, jira.default_645, jira.default_737, json_arg, json_file, kpi.d3asim_2103, kpi.d3asim_2103_2_sided_pab, kpi.d3asim_2103_nopv1, kpi.d3asim_2103_nopv1_2_sided_pab, kpi.d3asim_2262, kpi.d3asim_3464_family_with_pv, kpi.d3asim_3464_family_with_pv_ess, kpi.d3asim_3464_young_couple, kpi.gsye_1_savings_kpi_test_setup, kpi.house_fully_self_sufficient, kpi.house_not_self_sufficient, kpi.house_partially_self_sufficient, kpi.house_self_sufficient_with_ess, kpi.infinitebus_pv_load, kpi.market_maker_and_load, kpi.penalty_load, kpi.penalty_pv, kpi.root_area_self_sufficient_with_infinitebus, matching_engine_setup.external_matching_engine, power_flow.baseline_peak_energy, power_flow.net_energy_flow, power_flow.test_power_flow, redis_communication_default_2a, sam_config, sam_config_const_load, sam_config_small, scm.default_2a, scm.external, settlement_market.default_2a_settlement, settlement_market.settlement_market, settlement_market.simple, settlement_market.simple_load_cell_tower, sonnenplatz, strategy_tests.commercial_producer_market_maker_rate, strategy_tests.ess_capacity_based_sell_offer, strategy_tests.ess_sell_offer_decrease_rate, strategy_tests.external_devices, strategy_tests.external_devices_grid_fees, strategy_tests.external_devices_send_forecasts, strategy_tests.external_devices_settlement_market, strategy_tests.external_ess_bids, strategy_tests.external_ess_offers, strategy_tests.external_market_stats, strategy_tests.external_smart_meter, strategy_tests.finite_power_plant, strategy_tests.finite_power_plant_profile, strategy_tests.future_market_strategy, strategy_tests.heat_pump, strategy_tests.home_cp_ess_load, strategy_tests.home_hybrid_pv_ess_load, strategy_tests.infinite_bus, strategy_tests.market_maker_not_grid_connected, strategy_tests.market_maker_strategy, strategy_tests.predefined_pv_test, strategy_tests.pv_const_price_decrease, strategy_tests.pv_final_selling_rate, strategy_tests.pv_max_panel_output, strategy_tests.pv_max_panel_power_global, strategy_tests.smart_meter_setup, strategy_tests.storage_buys_and_offers, strategy_tests.storage_strategy_break_even_hourly, strategy_tests.user_profile_load_csv, strategy_tests.user_profile_load_csv_multiday, strategy_tests.user_profile_load_dict, strategy_tests.user_profile_pv_csv, strategy_tests.user_profile_pv_dict, strategy_tests.user_profile_wind_csv, strategy_tests.user_rate_profile_load_dict, test_hp, tobalaba.one_producer_load, two_sided_market.default_2a, two_sided_market.default_2a_high_res_graph, two_sided_market.infinite_bus, two_sided_market.jira_d3asim-1675, two_sided_market.load_fitlimits_match, two_sided_market.offer_reposted_at_old_offer_rate, two_sided_market.one_cep_one_load, two_sided_market.one_cep_one_load_immediate_match, two_sided_market.one_load_5_pv_partial, two_sided_market.one_load_one_storage, two_sided_market.one_pv_one_load, two_sided_market.one_pv_one_storage, two_sided_market.one_storage_5_pv_partial, two_sided_market.user_min_rate_profile_load_dict, two_sided_market.with_balancing_market, two_sided_pay_as_clear.default_2a, two_sided_pay_as_clear.jira_d3asim_1690, two_sided_pay_as_clear.multiple_offers_one_bid, two_sided_pay_as_clear.one_offer_multiple_bids, two_sided_pay_as_clear.one_offer_one_bid, two_sided_pay_as_clear.test_clearing_energy] -g, --settings-file TEXT Settings file path --seed TEXT Manually specify random seed --paused Start simulation in paused state --pause-at TEXT Automatically pause at a certain time. Accepted Input formats: (YYYY-MM-DD, HH:mm) [default: disabled] --incremental Pause the simulation at the end of each time slot. --repl / --no-repl Start REPL after simulation run. [default: no-repl] --no-export Skip export of simulation data --export-path TEXT Specify a path for the csv export files (default: ~/gsy-e-simulation) --enable-bc Run simulation on Blockchain --enable-external-connection External Agents interaction to simulation during runtime --start-date DATE Start date of the Simulation (YYYY-MM-DD) [default: 2023-10-04] --enable-dof / --disable-dof Enable or disable Degrees of Freedom (orders can't contain attributes/requirements). -m, --market-type INTEGER Market type. 1 for one-sided market, 2 for two-sided market, 3 for coefficient-based trading. [default: 1] --help Show this message and exit.","title":"Simulation launch"},{"location":"library/","text":"Libraries contain preconfigured energy assets, markets, and even small grids that can be reused in different simulations (e.g. loads, PVs, houses and even entire communities). The list of libraries is paginated. You can either click through the pages by pressing the Prev or Next button in the bottom right corner or use the search field in the top right corner to filter the list by the library names. The following buttons and labels can be seen in the Library page: Denotes public libraries (other users can see the Library and the uploaded profiles): & (in the search bar) Quicklook labels for showing type and number of assets and the number of markets in the library: With this button the user can edit library content or view public libraries: With this button the user can rename, duplicate or delete an existing library (only user\u2019s own library may be deleted): The user can also create a new library (button redirects to Grid setup ):","title":"Library"},{"location":"licensing/","text":"Grid Singularity\u2019s software is available under an open source GNU General Public License . We believe that disruptive innovation yields new solutions to bring about the energy transition and can only be achieved by an open source community. The GPLv.3 license protects our code in a way that anyone who wishes to pursue proprietary commercialisation of the software would need to apply for a license, while open source applications supporting sustainable development continue to be free.","title":"Licensing and Open Source Ethos"},{"location":"linux-installation-instructions/","text":"Installing Grid Singularity Exchange on Linux Ubuntu 18.04 \u00b6 Step 1: In case you have not already installed git, Python 3.8 and pip (otherwise please go directly to step 2): \u00b6 sudo apt-get update sudo apt-get install git-core software-properties-common -y sudo add-apt-repository ppa:deadsnakes/ppa sudo apt-get update sudo apt-get install python3.8 -y sudo apt-get install git-core -y sudo apt-get install python3-pip -y Step 2: Install virtualenv and create a Python virtual environment \u00b6 pip3 install virtualenv mkdir envs cd envs virtualenv -p /usr/bin/python3.8 gsy-e How to activate the environment: \u00b6 source gsy-e/bin/activate How to deactivate the environment: \u00b6 deactivate Step 3: Please add the following lines to your .bashrc and reopen the shell: \u00b6 export LC_ALL=C.UTF-8 export LANG=C.UTF-8 Step 4: Clone the Grid Singularity Exchange repository, gsy-e, to a directory of your choice: \u00b6 git clone https://github.com/gridsingularity/gsy-e.git Step 5: Install \u00b6 Activate your virtual environment and go into the d3a repository \u00b6 source gsy-e/bin/activate Install pip-tools \u00b6 pip3 install pendulum pip-tools Install dependencies \u00b6 pip install -e. Now, if you run gsy-e run -\u2013help , the help of gsy-e should be shown. Installing Grid Singularity Exchange on Linux Ubuntu 20.04 \u00b6 Please follow the installation instructions for Ubuntu 18.04. In case you encounter the following error: error: command 'x86_64-linux-gnu-gcc' failed with exit status 1 please install the following package: sudo apt-get install build-essential python3.8-dev -y","title":"Linux Installation Instructions"},{"location":"linux-installation-instructions/#installing-grid-singularity-exchange-on-linux-ubuntu-1804","text":"","title":"Installing Grid Singularity Exchange on Linux Ubuntu 18.04"},{"location":"linux-installation-instructions/#step-1-in-case-you-have-not-already-installed-git-python-38-and-pip-otherwise-please-go-directly-to-step-2","text":"sudo apt-get update sudo apt-get install git-core software-properties-common -y sudo add-apt-repository ppa:deadsnakes/ppa sudo apt-get update sudo apt-get install python3.8 -y sudo apt-get install git-core -y sudo apt-get install python3-pip -y","title":"Step 1: In case you have not already installed git, Python 3.8 and pip (otherwise please go directly to step 2):"},{"location":"linux-installation-instructions/#step-2-install-virtualenv-and-create-a-python-virtual-environment","text":"pip3 install virtualenv mkdir envs cd envs virtualenv -p /usr/bin/python3.8 gsy-e","title":"Step 2: Install virtualenv and create a Python virtual environment"},{"location":"linux-installation-instructions/#how-to-activate-the-environment","text":"source gsy-e/bin/activate","title":"How to activate the environment:"},{"location":"linux-installation-instructions/#how-to-deactivate-the-environment","text":"deactivate","title":"How to deactivate the environment:"},{"location":"linux-installation-instructions/#step-3-please-add-the-following-lines-to-your-bashrc-and-reopen-the-shell","text":"export LC_ALL=C.UTF-8 export LANG=C.UTF-8","title":"Step 3: Please add the following lines to your .bashrc and reopen the shell:"},{"location":"linux-installation-instructions/#step-4-clone-the-grid-singularity-exchange-repository-gsy-e-to-a-directory-of-your-choice","text":"git clone https://github.com/gridsingularity/gsy-e.git","title":"Step 4: Clone the Grid Singularity Exchange repository, gsy-e, to a directory of your choice:"},{"location":"linux-installation-instructions/#step-5-install","text":"","title":"Step 5: Install"},{"location":"linux-installation-instructions/#activate-your-virtual-environment-and-go-into-the-d3a-repository","text":"source gsy-e/bin/activate","title":"Activate your virtual environment and go into the d3a repository"},{"location":"linux-installation-instructions/#install-pip-tools","text":"pip3 install pendulum pip-tools","title":"Install pip-tools"},{"location":"linux-installation-instructions/#install-dependencies","text":"pip install -e. Now, if you run gsy-e run -\u2013help , the help of gsy-e should be shown.","title":"Install dependencies"},{"location":"linux-installation-instructions/#installing-grid-singularity-exchange-on-linux-ubuntu-2004","text":"Please follow the installation instructions for Ubuntu 18.04. In case you encounter the following error: error: command 'x86_64-linux-gnu-gcc' failed with exit status 1 please install the following package: sudo apt-get install build-essential python3.8-dev -y","title":"Installing Grid Singularity Exchange on Linux Ubuntu 20.04"},{"location":"map/","text":"In the User Interface , each energy asset and market can be pinned on a map with geographic coordinates in the form of a geotag, linked to a physical address . If a geotag is set at the market level, all submarkets and their assets are tied to these coordinates. In this example, Neuk\u00f6ln market includes all submarkets and assets under the same geotag (House 1, House 2, PV 4, Market and PV 5). If a market geo-tag type is set to location , the market can be pinned on the map and all of its submarkets and assets will inherit the same location: In this example, House 2\u2019s assets are assigned the same location as the House 2 submarket. Once the user has added locations via geotags for its markets and energy assets, the simulation will be shown on the Grid Singularity\u2019s public map, which will disclose the location of the simulation\u2019s highest market and the total number of markets and energy assets. For a video tutorial on the map feature, please follow this link .","title":"Map"},{"location":"market-agent/","text":"The MarketAgent (MA) plays a crucial role in the communication architecture of Grid Singularity\u2019s exchange, allowing different markets in the hierarchy to interact and trade with each other. The MarketAgent is created for each market (households/buildings, streets, etc. that do not have preset trading strategies) and mainly deals with forwarding bids and offers markets of different hierarchy levels. The following illustration shows a sample grid setup and the role of the MarketAgent in the market hierarchy during one time slot: Figure 4.12 : The MarketAgent and bids / offers propagation in the Grid Singularity Exchange. The MA is responsible for modelling hierarchical market operations, as follows: Forwarding bids and offers from a lower hierarchy (market) to an upper hierarchy. Reacting to bids, offers and trades reported by MAs in connected markets, in order to propagate the event for an offer/bid that has been forwarded from this MA. Triggering the matching of bids and offers for the two-sided market. To prioritize local trades, MAs forward bids and offers to higher/lower markets with a two-tick delay.","title":"Bids/Offers Process and Hierarchical Market Structure"},{"location":"market-backend-configuration/","text":"These parameters can be set in the backend in the Market class : Market('Market', [ ... \"some assets here\" ], grid_fee_constant=2, throughput=ThroughputParameters(import_capacity_kVA=2.0, export_capacity_kVA=2.0, baseline_peak_energy_import_kWh=0.4, baseline_peak_energy_export_kWh=0.4))","title":"Market Backend Configuration"},{"location":"market-types/","text":"The main goal of an electricity market exchange is to balance the grid in terms of demand and supply. Since efficient storage of large quantities of energy is currently not economically feasible and electrical current varies within seconds, a market mechanism that efficiently accounts for the physical energy production and consumption is required. Generally, trading occurs in three types of markets with different time intervals: Spot market : short-term trades for immediate or near-term delivery. Energy transactions are divided into small time blocks (typically 15 minute slots) that can either be traded on the Day-ahead or in the Intraday market. Balancing market : balancing capacity and reserves purchased by the balancing responsible parties (BRP) or other local balancing agents to be deployed for future grid imbalances. Settlement market : post-delivery trades of deviations between energy physically produced/consumed and energy purchased in the spot or futures market to settle imbalances locally before BRP billing. Futures market : Trades for the longer term future consumption and production of energy are agreed in advance. This market is currently in development of Grid Singularity energy exchange implementation. Figure 4.1 : Market Types implemented in Grid Singularity Exchange. Market Slots \u00b6 The energy spot market is broken into time slots, with the default set to 15 minutes of simulated time. For a one-day simulation, 96 market slots would occur with the default setting. Learn how to adjust market slot length here . Depending on the market type, bids and offers are either matched within or at the end of each slot. Bids and offers that remain unmatched at the end of a market slot are annulled, and assets may be penalised for any energy they physically produce or consume that is not transacted for. Market Ticks \u00b6 Each slot is further segmented into ticks. The default setting for a tick is 15 seconds of simulated time (simulated time is the time unit within a simulation as opposed to real-time which is the real-life time that the simulation takes; e.g. a simulation can simulate 7 days of trading in minutes or hours), and this configuration may be changed. The default 15 minute market slot is made up of 60 15-second ticks. In a pay-as-bid market, for instance, the market is cleared at the end of each tick. If an order is not matched, it is propagated to all adjacent markets by a MarketAgent after two ticks (explained in more detail below ). If an order is not matched at the end of two next ticks, it is further propagated to connected markets in the subsequent ticks following the same logic. The current implementation of Grid Singularity exchange currently focuses on the spot and balancing markets. Balancing markets take place immediately after each spot market slot (if enabled). The duration of the markets can be configured.","title":"Market Types Overview"},{"location":"market-types/#market-slots","text":"The energy spot market is broken into time slots, with the default set to 15 minutes of simulated time. For a one-day simulation, 96 market slots would occur with the default setting. Learn how to adjust market slot length here . Depending on the market type, bids and offers are either matched within or at the end of each slot. Bids and offers that remain unmatched at the end of a market slot are annulled, and assets may be penalised for any energy they physically produce or consume that is not transacted for.","title":"Market Slots"},{"location":"market-types/#market-ticks","text":"Each slot is further segmented into ticks. The default setting for a tick is 15 seconds of simulated time (simulated time is the time unit within a simulation as opposed to real-time which is the real-life time that the simulation takes; e.g. a simulation can simulate 7 days of trading in minutes or hours), and this configuration may be changed. The default 15 minute market slot is made up of 60 15-second ticks. In a pay-as-bid market, for instance, the market is cleared at the end of each tick. If an order is not matched, it is propagated to all adjacent markets by a MarketAgent after two ticks (explained in more detail below ). If an order is not matched at the end of two next ticks, it is further propagated to connected markets in the subsequent ticks following the same logic. The current implementation of Grid Singularity exchange currently focuses on the spot and balancing markets. Balancing markets take place immediately after each spot market slot (if enabled). The duration of the markets can be configured.","title":"Market Ticks"},{"location":"markets-rotation/","text":"If ConstSettings.SettlementMarketSettings.ENABLE_SETTLEMENT_MARKETS is set to True, settlement markets are created on each market cycle. For each past spot market, there is always a respective settlement market. The settlement markets are kept open for placing bids and offers for the amount of hours the user sets with Const.Settings.SettlementMarketSettings.MAX_AGE_SETTLEMENT_MARKET_HOURS . In contrast to a normal simulation run, the past slot markets are also kept in memory for the same amount of time in order to generate live results including past markets and the settlement markets. Only one past settlement market is kept in memory. This is also only for keeping track of the statistics, no offers and bids can be placed there. Figure 4.9 : Example of settlement markets available for each market slot and their rotation.","title":"Markets and rotation"},{"location":"markets/","text":"The main goal of an electricity market exchange is to balance the grid in terms of demand and supply. Since efficient storage of large quantities of energy is currently not economically feasible and electrical current varies within seconds, a market mechanism that efficiently accounts for the physical energy production and consumption is required. Generally, trading occurs in three types of markets with different time intervals: Spot market : short-term trades for immediate or near-term delivery. Energy transactions are divided into small time blocks (typically 15 minute slots) that can either be traded on the Day-ahead or in the Intraday market. Balancing market : imbalances that occur due to deviations between energy traded in the spot market and actual energy consumption and production are absorbed by balance responsible parties (BRP) that are reimbursed for their service with a fee based on the energy deviation. Futures market : trades for the longer term future consumption and production of energy are agreed in advance. This market is currently outside the scope of Grid Singularity energy exchange implementation. The current implementation of Grid Singularity software focuses on the spot and balancing markets. Balancing markets take place immediately after each spot market slot (if enabled). The duration of the markets can be configured. Currently, three spot market types are implemented: One-sided Pay-as-Offer Two-sided Pay-as-Bid Two-sided Pay-as-Clear Market Slots \u00b6 The energy spot market is broken into time slots, with the default set to 15 minutes of simulated time. For a one-day simulation, 96 market slots would occur with the default setting. Learn how to adjust market slot length here . Depending on the market type, bids and offers are either matched within or at the end of each slot. Bids and offers that remain unmatched at the end of a market slot are annulled, and assets may be penalised for any energy they physically produce or consume that is not transacted for. Market Ticks \u00b6 Each slot is further segmented into ticks. The default setting for a tick is 15 seconds of simulated time (simulated time is the time unit within a simulation as opposed to real-time which is the real-life time that the simulation takes; e.g. a simulation can simulate 7 days of trading in minutes or hours), and this configuration may be changed. The default 15 minute market slot is made up of 60 15-second ticks. In a pay-as-bid market, the market is cleared at the end of each tick. If an order is not matched, it is propagated to all adjacent markets by an Inter-Area Agent after two ticks. If an order is not matched at the end of two next ticks, it is further propagated to connected markets in the subsequent ticks following the same logic.","title":"Markets"},{"location":"markets/#market-slots","text":"The energy spot market is broken into time slots, with the default set to 15 minutes of simulated time. For a one-day simulation, 96 market slots would occur with the default setting. Learn how to adjust market slot length here . Depending on the market type, bids and offers are either matched within or at the end of each slot. Bids and offers that remain unmatched at the end of a market slot are annulled, and assets may be penalised for any energy they physically produce or consume that is not transacted for.","title":"Market Slots"},{"location":"markets/#market-ticks","text":"Each slot is further segmented into ticks. The default setting for a tick is 15 seconds of simulated time (simulated time is the time unit within a simulation as opposed to real-time which is the real-life time that the simulation takes; e.g. a simulation can simulate 7 days of trading in minutes or hours), and this configuration may be changed. The default 15 minute market slot is made up of 60 15-second ticks. In a pay-as-bid market, the market is cleared at the end of each tick. If an order is not matched, it is propagated to all adjacent markets by an Inter-Area Agent after two ticks. If an order is not matched at the end of two next ticks, it is further propagated to connected markets in the subsequent ticks following the same logic.","title":"Market Ticks"},{"location":"matching-api-commands/","text":"The Matching API is responsible for communicating with a running Grid Singularity Exchange. The client uses the Matching API to dynamically connect to the simulated electrical grid and query the open bids/offers and post-trading recommendations back to Grid Singularity Exchange. request_offers_bids() \u00b6 This command is used to request bids and offers from a specific market or family of markets, that can be specified through the filters dictionary and it is the output of the on_area_map_response method. self.request_offers_bids(filters={\u201cmarkets: self.id_list})","title":"Matching API Commands"},{"location":"matching-api-commands/#request_offers_bids","text":"This command is used to request bids and offers from a specific market or family of markets, that can be specified through the filters dictionary and it is the output of the on_area_map_response method. self.request_offers_bids(filters={\u201cmarkets: self.id_list})","title":"request_offers_bids()"},{"location":"matching-api-events/","text":"In the Matching API, seven event types are triggered while a simulation is running. To facilitate offer and bid requests and clearing, the client will get notified via events. It is possible to capture these events and react to them by overriding the corresponding methods. Each new market slot \u00b6 def on_market_cycle(self, data): The method on_market_cycle is triggered at the start of every market slot. On % of market completion \u00b6 def on_tick(self, data): The method on_tick is called when a new tick is started, at each 1-2% of the market slot completion. It performs an HTTP request to get all open bids and offers posted on the exchange. The response can be received in the method named on_offers_bids_response . On offers bids response \u00b6 def on_offers_bids_response(self, data): The method on_offers_bids_response is triggered when open offers/bids responses are returned. The data dictionary received from the exchange contains information on all open bids/offers posted. The structure is shown below: {'8f7b7e7b-0f4a-490b-853f-6017af84ef60': {\u20182021-12-20T00:00\u2019: {'bids': [{'type': 'Bid', 'id': '5934bfff-43c6-4870-8f1f-52bb8374a1f9', 'energy': 0.05, 'energy_rate': 2.5, 'original_price': 0.125, \u2018creation_time\u2019: \u20182021-12-20T00.00:25\u2019, \u2018time_slot\u2019: \u20182021-12-20T00:00\u2019, \u2018attributes\u2019: None, \u2018requirements\u2019: None, 'buyer_origin': 'load', 'buyer_origin_id': 'fcbe2390-5bcf-4cbd-b4f4-7c6d44fda34f', 'buyer_id': 'fcbe2390-5bcf-4cbd-b4f4-7c6d44fda34f', 'buyer': 'load'}], 'offers': [{'type': 'Offer', 'id': 'c4b10dd5-eb5f-4807-859a-9b6a0592a21c', 'energy': 1.25, 'energy_rate': 29.64285714288, 'original_price': 37.0535714286, \u2018creation_time\u2019: \u20182021-12-20T00.00:25\u2019, \u2018time_slot\u2019: \u20182021-12-20T00:00\u2019, \u2018attributes\u2019: None, \u2018requirements\u2019: None, 'seller': 'IAA House 2', 'seller_origin': 'H1 Storage1', 'seller_origin_id': 'e9faeda1-ce20-4789-b61c-61559a95f9fb', 'seller_id': 'a4403967-3e47-4d47-8c63-b5145d6c1e42'} ]}]}} where '8f7b7e7b-0f4a-490b-853f-6017af84ef60' refers to a unique identifier of both the market slot and the market in which the corresponding bids / offers have been posted. On matched recommendations response \u00b6 def on_matched_recommendations_response(self, data): When the matching engine client sends trades recommendations, this function is triggered and a response is passed through the data dictionary. On area map response \u00b6 def on_area_map_response(self, data): This method is triggered once at the beginning of the simulation and it is used to build the list of market IDs from which the user wants to request bids and offers from through the request_offers_bids command. On event or response \u00b6 def on_event_or_response(self, data): Each time an event arrives or any response (from sending a batch of recommendations) is triggered, this information is passed through on_event_or_response . On finish \u00b6 def on_finish(self, data): This executes when the simulation ends and can be used to trigger exporting data, training a model or exiting the code.","title":"Matching API Events"},{"location":"matching-api-events/#each-new-market-slot","text":"def on_market_cycle(self, data): The method on_market_cycle is triggered at the start of every market slot.","title":"Each new market slot"},{"location":"matching-api-events/#on-of-market-completion","text":"def on_tick(self, data): The method on_tick is called when a new tick is started, at each 1-2% of the market slot completion. It performs an HTTP request to get all open bids and offers posted on the exchange. The response can be received in the method named on_offers_bids_response .","title":"On % of market completion"},{"location":"matching-api-events/#on-offers-bids-response","text":"def on_offers_bids_response(self, data): The method on_offers_bids_response is triggered when open offers/bids responses are returned. The data dictionary received from the exchange contains information on all open bids/offers posted. The structure is shown below: {'8f7b7e7b-0f4a-490b-853f-6017af84ef60': {\u20182021-12-20T00:00\u2019: {'bids': [{'type': 'Bid', 'id': '5934bfff-43c6-4870-8f1f-52bb8374a1f9', 'energy': 0.05, 'energy_rate': 2.5, 'original_price': 0.125, \u2018creation_time\u2019: \u20182021-12-20T00.00:25\u2019, \u2018time_slot\u2019: \u20182021-12-20T00:00\u2019, \u2018attributes\u2019: None, \u2018requirements\u2019: None, 'buyer_origin': 'load', 'buyer_origin_id': 'fcbe2390-5bcf-4cbd-b4f4-7c6d44fda34f', 'buyer_id': 'fcbe2390-5bcf-4cbd-b4f4-7c6d44fda34f', 'buyer': 'load'}], 'offers': [{'type': 'Offer', 'id': 'c4b10dd5-eb5f-4807-859a-9b6a0592a21c', 'energy': 1.25, 'energy_rate': 29.64285714288, 'original_price': 37.0535714286, \u2018creation_time\u2019: \u20182021-12-20T00.00:25\u2019, \u2018time_slot\u2019: \u20182021-12-20T00:00\u2019, \u2018attributes\u2019: None, \u2018requirements\u2019: None, 'seller': 'IAA House 2', 'seller_origin': 'H1 Storage1', 'seller_origin_id': 'e9faeda1-ce20-4789-b61c-61559a95f9fb', 'seller_id': 'a4403967-3e47-4d47-8c63-b5145d6c1e42'} ]}]}} where '8f7b7e7b-0f4a-490b-853f-6017af84ef60' refers to a unique identifier of both the market slot and the market in which the corresponding bids / offers have been posted.","title":"On offers bids response"},{"location":"matching-api-events/#on-matched-recommendations-response","text":"def on_matched_recommendations_response(self, data): When the matching engine client sends trades recommendations, this function is triggered and a response is passed through the data dictionary.","title":"On matched recommendations response"},{"location":"matching-api-events/#on-area-map-response","text":"def on_area_map_response(self, data): This method is triggered once at the beginning of the simulation and it is used to build the list of market IDs from which the user wants to request bids and offers from through the request_offers_bids command.","title":"On area map response"},{"location":"matching-api-events/#on-event-or-response","text":"def on_event_or_response(self, data): Each time an event arrives or any response (from sending a batch of recommendations) is triggered, this information is passed through on_event_or_response .","title":"On event or response"},{"location":"matching-api-events/#on-finish","text":"def on_finish(self, data): This executes when the simulation ends and can be used to trigger exporting data, training a model or exiting the code.","title":"On finish"},{"location":"matching-api-template-script/","text":"A Matching API template script is available here . See the TODO flags there connect to your preferred customized clearing algorithm and to request, if desired, bids and offers from specific markets. At the beginning of the Matching API script, the MatchingEngineMatcher class is defined as well as the on_area_map_response method, which allows the users to define the list of markets from which they want to request bids and offers from. class MatchingEngineMatcher(base_matcher): def __init__(self, *args, **kwargs): super().__init__(*args, **kwargs) self.is_finished = False self.request_area_id_name_map() def on_area_map_response(self, data): self.id_list = [] market_list = [\"Community\"] for market in market_list: for market_id, name in data[\"area_mapping\"].items(): if name == market: self.id_list.append(market_id) Right after, the on_market_cycle and the on_tick methods are triggered. In the latter, the user requests bids / offers from the market. def on_market_cycle(self, data): pass def on_tick(self, data): self.request_offers_bids(filters={}) In the next section, the bids/offers that had been previously requested from the market are stored in the matching_data variable. The matching algorithm ( AttributedMatchingAlgorithm in the example here) takes those data as input and outputs a list of recommendations. Each recommendation is a nested dictionary with the following structure: [{'market_id': '0fd481d9-98af-43cd-9e98-196c1fe9877f', 'time_slot': '2021-12-20T00:15', 'bids': [{'type': 'Bid', 'id': '6d71f933-0474-4cd8-baa4-97a1f01553c5', 'energy': 0.05, 'energy_rate': 22.5, 'original_price': 1.125, 'creation_time': '2021-12-20T00:24:00', 'time_slot': '2021-12-20T00:15:00', 'attributes': None, 'requirements': None, 'buyer_origin': 'H2 General Load1', 'buyer_origin_id': 'd5133b0b-5c06-4cc8-aaaa-317756659695', 'buyer_id': 'd5133b0b-5c06-4cc8-aaaa-317756659695', 'buyer': 'H2 General Load1'}], 'offers': [{'type': 'Offer', 'id': '7760bf1d-ddad-47bb-a2ea-7067ea177c07', 'energy': 9223372036854775807, 'energy_rate': 22.0, 'original_price': 2.0291418481080507e+20, 'creation_time': '2021-12-20T00:15:25', 'time_slot': '2021-12-20T00:15:00', 'attributes': None, 'requirements': None, 'seller': 'MA House 2', 'seller_origin': 'Market Maker', 'seller_origin_id': '4493f3ce-eece-4386-8fc1-e715cf32b85f', 'seller_id': '0fd481d9-98af-43cd-9e98-196c1fe9877f'}], 'selected_energy': 0.05, 'trade_rate': 22.5, 'matching_requirements': None}] The matching algorithm can be written as a separate class file and can be referenced in the on_offers_bids_response function as: recommendations = YourMatchingAlgorithm.get_matches_recommendations( matching_data) At the moment, there are 3 default matching algorithms available to use and to build upon: Pay as Bid algorithm - this clears markets continuously during the market slot following this strategy ; Pay as Clear algorithm - this clears markets by ordering bids and offers and defining a single clearing price, following this strategy ; Attributed matching algorithm - this follows the same logic as the Pay-as-Bid clearing but takes into account degrees of freedom such as attributes and requirements (listed as dictionaries for bids and offers): Attributes - \u201cenergy type\u201d, currently implemented only for offers (e.g. \u201cgreen\u201d energy) Requirements - \u201ctrading partners\u201d implemented for offers and \u201cenergy type\u201d, \u201ctrading partners\u201d, \u201cenergy\u201d, and \u201cprice\u201d implemented for bids. def on_offers_bids_response(self, data): matching_data = data.get(\"bids_offers\") if not matching_data: return recommendations = AttributedMatchingAlgorithm.get_matches_recommendations( matching_data) if recommendations: logging.info(\"Submitting %s recommendations.\", len(recommendations)) self.submit_matches(recommendations) Later in the script, the on_matched_recommendations_response is triggered and useful information about the recommendation posted, such as seller, buyer, trading price and energy as well as the status, if successful or not, are printed in the terminal window of the user. Later, the on_event_or_response is overwritten. By default we do not perform any operation in this event but the user could add some if needed. def on_matched_recommendations_response(self, data): pass def on_event_or_response(self, data): logging.debug(\"Event arrived %s\", data) Lastly, the Matching API Script overwrites the on_finish event so that whenever the function is triggered the script stops. If the user wishes to save some information recorded within the Matching Engine SDK this would be the opportunity to export them to external files. def on_finish(self, data): self.is_finished = True","title":"Matching API Template Script"},{"location":"matching-api-walkthrough/","text":"The Grid Singularity Matching Application Programming Interface (or Matching API) allows custom matching algorithms to be used to clear orders in local or other energy markets. The Matching API decouples the matching process from the exchange, allowing algorithm providers (also termed matching engines here) to read the exchange\u2019s order book, run custom matching algorithms and send the resulting energy transactions to be verified and executed by the exchange, as shown in Figure and explained below. Figure . Flow diagram of the role of matching engines (third party matching algorithm providers) in the Grid Singularity Exchange. Trading process through the Matching API: Bids and Offers creation - Bids and Offers are created on behalf of the energy assets (either by using the default GSy trading strategy or through the Asset API ) and sent to the exchange. Order book - The exchange gathers the bids and offers for all the different markets, which are currently organized in a hierarchical structure . Request Bids and Offers - The Matching API requests bids and offers for specific markets , and receives a dictionary containing all bids and offers posted in the chosen markets. Matching - The Matching API pairs bids and offers together according to an external matching algorithm provided by a third-party matching algorithm provider and sends the proposed bid/offer pairs (technically called recommendations ) back to the exchange. Verification function - Each recommendation is submitted to the exchange\u2019s verification function, a mechanism that checks whether the clearing rate and the energy to be traded proposed by the recommendation respect the bids and offers\u2019 attributes and requirements . Transactions and rejections - Recommended matches that pass the verification function\u2019s check will be submitted as transactions in the Grid Singularity exchange. Recommendations rejected by the verification function will trigger a notification through the Matching API and not be sent to the exchange for clearing. It is important to note that the Matching API is asynchronous towards the exchange, meaning that it can request bids and offers and send recommendations at any time during the market slots . The GSy Matching API code is currently available in Python, with Rust implementation in development.","title":"Walkthrough"},{"location":"model-load/","text":"The load is an energy asset that consumes energy over time. It is possible to use a single load to represent an entire consuming building, as well as to configure multiple loads to represent different assets within a building (e.g. washing machine, air-conditioner, etc.). User Interface Configuration \u00b6 The following parameters can be configured: Load name : Must be unique Load profile : The user can choose between two options: User upload profile (a load profile can be uploaded when compliant with Upload File Formats) User configure profile (the user provides the load average power) Average power : average consuming power of the load in Watts. Hours per day : The number of hours the load operates per day. Hours of day : The time range in which the load operates. Initial buying rate : Initial energy buying rate at the beginning of each market slot in cents/kWh. Final buying rate : Final energy buying rate at the end of each market slot in cents/kWh. It can either be a user-defined value or equal to the Market Maker + Grid Fee. Rate increase : Explicit rate increase increment per update interval in cents/kWh Fit to limits : Derive bidding behavior from a linear fitted curve of a buying rate between initial_buying_rate and final_buying_rate within the bidding interval. If activated, energy rate_increase = (final_buying_rate - initial_buying_rate) / max(int((slot_length / update_interval) -1), 1) Update interval : The frequency at which the rate is updated. The Load configuration interface is shown below: Backend Configuration \u00b6 To implement the load in a backend simulation, two options are available : User configure Profile Market('Load', strategy=LoadHoursStrategy(avg_power_W=200, hrs_per_day=6,hrs_of_day=list(range(12, 18)), initial_buying_rate=0, final_buying_rate=35)) User upload Profile user_profile_path = os.path.join(gsye_root_path,\"assets/load.csv\") Market('Load', strategy=LoadProfileStrategy(daily_load_profile=user_profile_path, initial_buying_rate=0, final_buying_rate=35)) Addendum: hrs_of_day and hrs_per_day \u00b6 hrs_of_day defines the allowed time-window in which the load has to consume for a time defined by hrs_per_day. For example, a user can input 5 hrs_per_day and give a wider range for hrs_of_day like (2,18). The Load will try to consume as fast as possible during this time if there is any offered energy to purchase within the limits of initial_buying_rate and final_buying_rate set parameters. If there is sufficient energy at affordable rates, the load will consume in the first 5 hours, i.e. from 02:00 until 07:00, with no energy demand unmatched. In case energy prices are too high during the time-interval from 04:00 to 16:00, the load will consume from 02:00 until 04:00, turn off, and consume from 16:00 until 18:00, resulting in one hour of energy demand unmatched. For information on changes in buying and selling rates, please see: Trading strategies","title":"Model load"},{"location":"model-load/#user-interface-configuration","text":"The following parameters can be configured: Load name : Must be unique Load profile : The user can choose between two options: User upload profile (a load profile can be uploaded when compliant with Upload File Formats) User configure profile (the user provides the load average power) Average power : average consuming power of the load in Watts. Hours per day : The number of hours the load operates per day. Hours of day : The time range in which the load operates. Initial buying rate : Initial energy buying rate at the beginning of each market slot in cents/kWh. Final buying rate : Final energy buying rate at the end of each market slot in cents/kWh. It can either be a user-defined value or equal to the Market Maker + Grid Fee. Rate increase : Explicit rate increase increment per update interval in cents/kWh Fit to limits : Derive bidding behavior from a linear fitted curve of a buying rate between initial_buying_rate and final_buying_rate within the bidding interval. If activated, energy rate_increase = (final_buying_rate - initial_buying_rate) / max(int((slot_length / update_interval) -1), 1) Update interval : The frequency at which the rate is updated. The Load configuration interface is shown below:","title":"User Interface Configuration"},{"location":"model-load/#backend-configuration","text":"To implement the load in a backend simulation, two options are available : User configure Profile Market('Load', strategy=LoadHoursStrategy(avg_power_W=200, hrs_per_day=6,hrs_of_day=list(range(12, 18)), initial_buying_rate=0, final_buying_rate=35)) User upload Profile user_profile_path = os.path.join(gsye_root_path,\"assets/load.csv\") Market('Load', strategy=LoadProfileStrategy(daily_load_profile=user_profile_path, initial_buying_rate=0, final_buying_rate=35))","title":"Backend Configuration"},{"location":"model-load/#addendum-hrs_of_day-and-hrs_per_day","text":"hrs_of_day defines the allowed time-window in which the load has to consume for a time defined by hrs_per_day. For example, a user can input 5 hrs_per_day and give a wider range for hrs_of_day like (2,18). The Load will try to consume as fast as possible during this time if there is any offered energy to purchase within the limits of initial_buying_rate and final_buying_rate set parameters. If there is sufficient energy at affordable rates, the load will consume in the first 5 hours, i.e. from 02:00 until 07:00, with no energy demand unmatched. In case energy prices are too high during the time-interval from 04:00 to 16:00, the load will consume from 02:00 until 04:00, turn off, and consume from 16:00 until 18:00, resulting in one hour of energy demand unmatched. For information on changes in buying and selling rates, please see: Trading strategies","title":"Addendum: hrs_of_day and hrs_per_day"},{"location":"model-market-maker/","text":"The Market Maker mimics the behaviour of a typical energy utility and is used as a price reference point. Only one Market Maker can be set per simulation. The Market Maker can be configured to sell an infinite amount of energy as well as to buy an infinite amount of energy to simulate a Feed-in Tariff. User Interface Configuration \u00b6 The following parameters can be set: Name : The name of the Market Maker. Mode : The user has two options: Infinite power plant: In this mode, it has the ability to meet the infinite energy demand of consumers at the highest rate possible in that grid. Infinite bus: In this mode, the Market Maker has not only the ability to meet the infinite energy demand of the consumer but can also absorb the infinite generation surplus of prosumers/producers at the lowest rate possible in that grid. Role : The user has two options: Grid connected : In this mode, the Market Maker is connected to the grid and thus can fulfil the energy demand of any consumer and absorb surplus generation (if infinite bus mode selected) Islanded : In this mode, the Market Maker would only be used as a reference point for the highest possible energy_rate in that grid. Selling rate type : The user can either select User Input to define a fixed selling rate or upload their custom selling rate profile. Selling rate : The fixed rate the Market Maker will enforce, if User Input is chosen for the selling rate type. Buying rate type (infinite bus only) : The user can either select User Input to define a fixed buying rate or upload their custom buying rate profile. Buying rate (infinite bus only) : The fixed rate the Market Maker will enforce, if User Input is chosen for the buying rate type. The Market Maker configuration interface is shown below: Backend Configuration \u00b6 To implement a market maker in a backend simulation, two methods are available : infinite power plant : Market ('Market Maker', strategy=MarketMakerStrategy(energy_rate=selling_rate, grid_connected=True)) infinite bus : Market ('Market Maker', strategy=InfiniteBusStrategy(energy_buy_rate=22, energy_sell_rate=22))","title":"Model market maker"},{"location":"model-market-maker/#user-interface-configuration","text":"The following parameters can be set: Name : The name of the Market Maker. Mode : The user has two options: Infinite power plant: In this mode, it has the ability to meet the infinite energy demand of consumers at the highest rate possible in that grid. Infinite bus: In this mode, the Market Maker has not only the ability to meet the infinite energy demand of the consumer but can also absorb the infinite generation surplus of prosumers/producers at the lowest rate possible in that grid. Role : The user has two options: Grid connected : In this mode, the Market Maker is connected to the grid and thus can fulfil the energy demand of any consumer and absorb surplus generation (if infinite bus mode selected) Islanded : In this mode, the Market Maker would only be used as a reference point for the highest possible energy_rate in that grid. Selling rate type : The user can either select User Input to define a fixed selling rate or upload their custom selling rate profile. Selling rate : The fixed rate the Market Maker will enforce, if User Input is chosen for the selling rate type. Buying rate type (infinite bus only) : The user can either select User Input to define a fixed buying rate or upload their custom buying rate profile. Buying rate (infinite bus only) : The fixed rate the Market Maker will enforce, if User Input is chosen for the buying rate type. The Market Maker configuration interface is shown below:","title":"User Interface Configuration"},{"location":"model-market-maker/#backend-configuration","text":"To implement a market maker in a backend simulation, two methods are available : infinite power plant : Market ('Market Maker', strategy=MarketMakerStrategy(energy_rate=selling_rate, grid_connected=True)) infinite bus : Market ('Market Maker', strategy=InfiniteBusStrategy(energy_buy_rate=22, energy_sell_rate=22))","title":"Backend Configuration"},{"location":"model-markets/","text":"Markets contain submarkets and energy assets. Energy assets can post bids and offers in their market. Markets are interconnected by inter-area agents in a hierarchical network, which pass bids and offers between markets until they are matched, following a select market clearing mechanism . User Interface configuration \u00b6 The following market parameters can be set: Name : Must be unique Grid fee : If set to yes and with a non-None value, a fee will be applied to each trade that passes through or is cleared in this market. The grid fee is either constant , expressed in cents/kWh, or variable , expressed as a share of total price in percentage terms (%) depending on the parameters set in the simulation general settings . Transformers capacity : Import and export limits of the transformer in kVA. In the current implementation these limits are purely visual indicators and do not limit actual import/export of the market. Baseline import/export : Allows the user to compare the current simulation imports/exports to a baseline, set in kWh. These values are used in the calculation of the Peak Percentage KPI . The simulation configuration interface is shown below: Backend configuration \u00b6 These parameters can be set in the backend in the Area / Market class : Area('Market', [ ... \"some assets here\" ], grid_fee_constant=2, throughput=ThroughputParameters(import_capacity_kVA=2.0, export_capacity_kVA=2.0, baseline_peak_energy_import_kWh=0.4, baseline_peak_energy_export_kWh=0.4))","title":"Model markets"},{"location":"model-markets/#user-interface-configuration","text":"The following market parameters can be set: Name : Must be unique Grid fee : If set to yes and with a non-None value, a fee will be applied to each trade that passes through or is cleared in this market. The grid fee is either constant , expressed in cents/kWh, or variable , expressed as a share of total price in percentage terms (%) depending on the parameters set in the simulation general settings . Transformers capacity : Import and export limits of the transformer in kVA. In the current implementation these limits are purely visual indicators and do not limit actual import/export of the market. Baseline import/export : Allows the user to compare the current simulation imports/exports to a baseline, set in kWh. These values are used in the calculation of the Peak Percentage KPI . The simulation configuration interface is shown below:","title":"User Interface configuration"},{"location":"model-markets/#backend-configuration","text":"These parameters can be set in the backend in the Area / Market class : Area('Market', [ ... \"some assets here\" ], grid_fee_constant=2, throughput=ThroughputParameters(import_capacity_kVA=2.0, export_capacity_kVA=2.0, baseline_peak_energy_import_kWh=0.4, baseline_peak_energy_export_kWh=0.4))","title":"Backend configuration"},{"location":"model-power-plant/","text":"A finite power plant is an energy supplier that offers a configurable amount of power per time slot at a set rate. User Interface Configuration \u00b6 The following parameters can be configured: Name : Must be unique. Energy rate : Selling price of the power plant in cents/kWh. Maximum available power : Maximum power that the power plant can supply in kW (in the backend this parameter can also be set based on an uploaded profile). The configuration interface is shown below: Backend Configuration \u00b6 To implement the power plant in a backend simulation one option is available: Finite Power Plant profile_kW = { 0: 0.1, 8: 0.15, 12: 0.2, 19: 0.15, 22: 0.1 } Market (\"Power Plant', strategy=FinitePowerPlant(energy_rate=31.3, max_available_power_kW=profile_kW))","title":"Model power plant"},{"location":"model-power-plant/#user-interface-configuration","text":"The following parameters can be configured: Name : Must be unique. Energy rate : Selling price of the power plant in cents/kWh. Maximum available power : Maximum power that the power plant can supply in kW (in the backend this parameter can also be set based on an uploaded profile). The configuration interface is shown below:","title":"User Interface Configuration"},{"location":"model-power-plant/#backend-configuration","text":"To implement the power plant in a backend simulation one option is available: Finite Power Plant profile_kW = { 0: 0.1, 8: 0.15, 12: 0.2, 19: 0.15, 22: 0.1 } Market (\"Power Plant', strategy=FinitePowerPlant(energy_rate=31.3, max_available_power_kW=profile_kW))","title":"Backend Configuration"},{"location":"model-pv/","text":"A photovoltaic (PV) is an energy asset that converts solar irradiation into electricity. In our software, each PV component can represent a single panel, array of panels or an entire PV park. User Interface Configuration \u00b6 The following parameters can be configured: Name : Must be unique Panel count : Number of PV panels, each with a power of 250W. Solar Profile : The user can choose among multiple template solar profiles (sunny, partially cloudy or cloudy). The usery can also create a custom Gaussian curve or upload their own generation profile. Initial selling rate : Initial (and maximum) energy rate that the PV offers at the beginning of each market slot in cents/kWh. Final selling rate : Final energy rate that the PV offers at the end of each market slot in cents/kWh. Rate decrease : Explicit rate decrease increment in cents/kWh. Fit to limits : Derive bidding behavior from a linear fitted curve of a selling rate ranging from initial_selling_rate to final_selling_rate within the bidding interval. If activated, energy_rate_decrease_per_update = (initial_selling_rate - final_selling_rate) / max(int((slot_length / update_interval) -1), 1) Update interval : The frequency at which the rate is updated. The PV configuration interface is shown in the figure below: Backend Configuration \u00b6 There are two options to implement a PV in a backend: Solar Profile (for template generation profile) Market ('H2 PV', strategy=PVStrategy(panel_count=4, initial_selling_rate=30, final_selling_rate=5, fit_to_limit=True, update_interval=duration(minutes=5))) User Profile (for uploaded generation profile) user_profile_path = os.path.join(gsye_root_path, \"assets/Solar_Curve_W_sunny.csv\") Market ('H1 PV', strategy=PVUserProfileStrategy(power_profile=user_profile_path, panel_count=))","title":"Model pv"},{"location":"model-pv/#user-interface-configuration","text":"The following parameters can be configured: Name : Must be unique Panel count : Number of PV panels, each with a power of 250W. Solar Profile : The user can choose among multiple template solar profiles (sunny, partially cloudy or cloudy). The usery can also create a custom Gaussian curve or upload their own generation profile. Initial selling rate : Initial (and maximum) energy rate that the PV offers at the beginning of each market slot in cents/kWh. Final selling rate : Final energy rate that the PV offers at the end of each market slot in cents/kWh. Rate decrease : Explicit rate decrease increment in cents/kWh. Fit to limits : Derive bidding behavior from a linear fitted curve of a selling rate ranging from initial_selling_rate to final_selling_rate within the bidding interval. If activated, energy_rate_decrease_per_update = (initial_selling_rate - final_selling_rate) / max(int((slot_length / update_interval) -1), 1) Update interval : The frequency at which the rate is updated. The PV configuration interface is shown in the figure below:","title":"User Interface Configuration"},{"location":"model-pv/#backend-configuration","text":"There are two options to implement a PV in a backend: Solar Profile (for template generation profile) Market ('H2 PV', strategy=PVStrategy(panel_count=4, initial_selling_rate=30, final_selling_rate=5, fit_to_limit=True, update_interval=duration(minutes=5))) User Profile (for uploaded generation profile) user_profile_path = os.path.join(gsye_root_path, \"assets/Solar_Curve_W_sunny.csv\") Market ('H1 PV', strategy=PVUserProfileStrategy(power_profile=user_profile_path, panel_count=))","title":"Backend Configuration"},{"location":"model-storage/","text":"The storage simulates energy assets capable of storing or discharging energy (e.g. Lithium batteries, compressed air energy storage). User Interface Configuration \u00b6 The following parameters can be configured: Name : Must be unique Battery capacity : Total energy capacity. Initial capacity : Can be set in two ways: Initial State of Charge - SOC (in %) Initial Energy (in kWh) Minimum SOC : Minimum energy to leave in the storage. Max power rating for battery : Power limit for each market slot for sold and bought energy. Initial selling rate : Initial energy rate for selling energy at the beginning of each market slot in cents/kWh. Final selling rate : Final energy rate for selling energy at the end of each market slot in cents/kWh. Rate decrease : Explicit rate decrease increment in cents/kWh. Initial buying rate : Initial energy rate for buying energy at the beginning of each market slot in cents/kWh. Final buying rate : Final energy rate for buying energy at the end of each market slot in cents/kWh. Rate increase : Explicit rate increase increment in cents/kWh. Fit to limits : Derive bidding behavior from a linear fitted curve of a buying rate between initial_buying_rate and final_buying_rate and a selling rate between initial_selling_rate and final_selling_rate within the bidding interval. If activated: energy_rate_increase = (final_buying_rate - initial_buying_rate) / max(int((slot_length / update_interval) -1), 1) energy_rate_decrease_per_update = (initial_selling_rate - final_selling_rate) / max(int((slot_length / update_interval) -1), 1) Update interval : The frequency at which the rate is updated. Capacity based method : The storage can trade energy based on a capacity dependent sell price (see addendum). Note: For the time being, the storage component has a 100% electric-to-electric efficiency by default. Changing this characteristic is not possible at the moment but it will be possible in the near future. Users are welcome to add additional features to our open source code base on GitHub. The storage configuration interface is shown below: Backend Configuration \u00b6 To implement the storage in a backend simulation one option is available: Energy Storage System Market('Storage', strategy=StorageStrategy(initial_soc=50, energy_rate_decrease_per_update=3, battery_capacity_kWh=1.2, max_abs_battery_power_kW=5, final_buying_rate=16.99, final_selling_rate= 17.01))) Addendum: Storage Capacity Based Method \u00b6 This method was created to sell energy at lower prices during high state of charge - SOC (when the battery has more energy stored) and at higher prices during low SOC (when the battery can afford to sell its stored energy for less). If the cap_price_strategy is True , the offer price for the storage is calculated according to: offer_rate = initial_selling_rate - ((initial_selling_rate - final_selling_rate)\\*soc/100) As an example, considering an initial_selling_rate of 30 cents/kWh and a final_selling_rate of 20 cents/kWh, a storage with an SOC of 1% would sell its energy at 29.9 cents/kWh, and a battery at 100% SOC would sell its energy at 20 cents/kWh. Storage Behaviour in Local Energy Markets \u00b6 In general all bids and offers follow the physical constraint of the set max_abs_battery_power_kW value. The accumulated energy per market slot cannot exceed this power value times the length of the market slot. Energy sold and bought cancel each other out, meaning that if 2kWh are both sold and bought in the same market slot, the relative power remains 0kW. For the buying rate increase and selling rate decrease behaviour, please see the Trading Strategies page . Buying Energy in One-Sided Market : \u00b6 On each tick, the storage scans the connected market for affordable offers* if there is storage space to be filled (if the current SOC is lower than 100%). Once an offer is found, it is either fully or partially accepted, depending on the demand. The storage always seeks 100% SOC when buying energy. = affordable offers are offers that have a price lower or equal to the current acceptable energy rate. The acceptable energy rate changes during a market slot depending on the initial_buying_rate , final_buying_rate , energy_rate_decrease_per_update and update_interval setting. Buying Energy in Two-Sided Market : \u00b6 On each tick, the storage either places a bid for the quantity of energy it needs to reach 100% SOC or updates the price of an existing bid in the market where the bid rate depends on the initial_buying_rate , final_buying_rate , energy_rate_decrease_per_update and update_interval setting. Selling Energy \u00b6 At the beginning of each market slot, the storage places an offer for all the energy it has stored (not including the energy that is needed to keep the storage at least at min_allowed_soc). This offer is updated at each update_interval pursuant to the rate decrease settings. This mechanism applies in both one and two-sided market types. Consequently, it is possible for the storage to have both an offer and a bid placed in the same market.","title":"Model storage"},{"location":"model-storage/#user-interface-configuration","text":"The following parameters can be configured: Name : Must be unique Battery capacity : Total energy capacity. Initial capacity : Can be set in two ways: Initial State of Charge - SOC (in %) Initial Energy (in kWh) Minimum SOC : Minimum energy to leave in the storage. Max power rating for battery : Power limit for each market slot for sold and bought energy. Initial selling rate : Initial energy rate for selling energy at the beginning of each market slot in cents/kWh. Final selling rate : Final energy rate for selling energy at the end of each market slot in cents/kWh. Rate decrease : Explicit rate decrease increment in cents/kWh. Initial buying rate : Initial energy rate for buying energy at the beginning of each market slot in cents/kWh. Final buying rate : Final energy rate for buying energy at the end of each market slot in cents/kWh. Rate increase : Explicit rate increase increment in cents/kWh. Fit to limits : Derive bidding behavior from a linear fitted curve of a buying rate between initial_buying_rate and final_buying_rate and a selling rate between initial_selling_rate and final_selling_rate within the bidding interval. If activated: energy_rate_increase = (final_buying_rate - initial_buying_rate) / max(int((slot_length / update_interval) -1), 1) energy_rate_decrease_per_update = (initial_selling_rate - final_selling_rate) / max(int((slot_length / update_interval) -1), 1) Update interval : The frequency at which the rate is updated. Capacity based method : The storage can trade energy based on a capacity dependent sell price (see addendum). Note: For the time being, the storage component has a 100% electric-to-electric efficiency by default. Changing this characteristic is not possible at the moment but it will be possible in the near future. Users are welcome to add additional features to our open source code base on GitHub. The storage configuration interface is shown below:","title":"User Interface Configuration"},{"location":"model-storage/#backend-configuration","text":"To implement the storage in a backend simulation one option is available: Energy Storage System Market('Storage', strategy=StorageStrategy(initial_soc=50, energy_rate_decrease_per_update=3, battery_capacity_kWh=1.2, max_abs_battery_power_kW=5, final_buying_rate=16.99, final_selling_rate= 17.01)))","title":"Backend Configuration"},{"location":"model-storage/#addendum-storage-capacity-based-method","text":"This method was created to sell energy at lower prices during high state of charge - SOC (when the battery has more energy stored) and at higher prices during low SOC (when the battery can afford to sell its stored energy for less). If the cap_price_strategy is True , the offer price for the storage is calculated according to: offer_rate = initial_selling_rate - ((initial_selling_rate - final_selling_rate)\\*soc/100) As an example, considering an initial_selling_rate of 30 cents/kWh and a final_selling_rate of 20 cents/kWh, a storage with an SOC of 1% would sell its energy at 29.9 cents/kWh, and a battery at 100% SOC would sell its energy at 20 cents/kWh.","title":"Addendum: Storage Capacity Based Method"},{"location":"model-storage/#storage-behaviour-in-local-energy-markets","text":"In general all bids and offers follow the physical constraint of the set max_abs_battery_power_kW value. The accumulated energy per market slot cannot exceed this power value times the length of the market slot. Energy sold and bought cancel each other out, meaning that if 2kWh are both sold and bought in the same market slot, the relative power remains 0kW. For the buying rate increase and selling rate decrease behaviour, please see the Trading Strategies page .","title":"Storage Behaviour in Local Energy Markets"},{"location":"model-storage/#buying-energy-in-one-sided-market","text":"On each tick, the storage scans the connected market for affordable offers* if there is storage space to be filled (if the current SOC is lower than 100%). Once an offer is found, it is either fully or partially accepted, depending on the demand. The storage always seeks 100% SOC when buying energy. = affordable offers are offers that have a price lower or equal to the current acceptable energy rate. The acceptable energy rate changes during a market slot depending on the initial_buying_rate , final_buying_rate , energy_rate_decrease_per_update and update_interval setting.","title":"Buying Energy in One-Sided Market:"},{"location":"model-storage/#buying-energy-in-two-sided-market","text":"On each tick, the storage either places a bid for the quantity of energy it needs to reach 100% SOC or updates the price of an existing bid in the market where the bid rate depends on the initial_buying_rate , final_buying_rate , energy_rate_decrease_per_update and update_interval setting.","title":"Buying Energy in Two-Sided Market:"},{"location":"model-storage/#selling-energy","text":"At the beginning of each market slot, the storage places an offer for all the energy it has stored (not including the energy that is needed to keep the storage at least at min_allowed_soc). This offer is updated at each update_interval pursuant to the rate decrease settings. This mechanism applies in both one and two-sided market types. Consequently, it is possible for the storage to have both an offer and a bid placed in the same market.","title":"Selling Energy"},{"location":"one-sided-pay-as-offer/","text":"In the One-Sided Pay-as-Offer market, agents representing energy producers, including prosumers ( sellers ) post offers in the market with an energy price determined by the assets' trading strategy . Agents representing consumers ( buyers ) can see the offers available in their local market, filter affordable offers and then select the most favorable offer. The energy rate on which the seller and buyer settle is the price of the offer (pay-as-offer). Consequently, the trade rate may differ for trades settled in the same slot. The auction is continuous , meaning that once an offer is posted, it can be accepted right away, even before the end of each market slot .","title":"One-Sided Pay-as-Offer Market"},{"location":"peak-percentage/","text":"The energy peak imports/exports is the maximum value of the aggregate imports/exports of each asset inside a market. The user has the possibility to set a baseline_peak_energy_import_kWh and a baseline_peak_energy_export_kWh that they may have gotten from another simulation in order to calculate the energy peak percentage, a tool used to measure how much the peak imports or exports have changed between a defined baseline and the current simulation. The user may be interested in the Energy Peak Percentage value to assess the impact of applied grid fees or different energy storage strategies on the peak imports and exports of a market. The Energy Peak Percentage can be calculated as follows : Import_peak_percentage = import_peak_energy_kWh / import_baseline_peak_energy_kWh * 100 Export_peak_percentage = export_peak_energy_kWh / export_baseline_peak_energy_kWh * 100 If the energy peak percentage is below 100% , the peak was reduced vs. the baseline. The energy peak was increased if the energy peak percentage value is above 100% .","title":"Peak percentage"},{"location":"percentage-fees/","text":"The percentage grid fee is a market based fee, defined as a ratio (%) of the clearing price that is added to each trade that is cleared, as shown in the figure below. Figure 4.18 : Percentage grid fee calculation in the Grid Singularity Exchange. The price of a bid or offer changes as it is propagated into different markets to account for market fees. This way, a trading agent posting an offer will never receive less than offered and an agent making a bid will never pay more than bid. Example Calculation in One-Sided Pay-as-Offer Market \u00b6 Figure 4.19 : Percentage Grid Fee Example Calculation in One-Sided Pay-as-Offer Market. In the One-Sided Pay-as-Offer market , there are no bids, only offers. The offers are propagated throughout the markets in the hierarchy. The grid fees are taken into account when an offer is forwarded to the higher market, by the higher market itself. Therefore the agent is not responsible for adapting the offer price to include the grid fees. The grid fees' unit is a ratio of the original offer price, therefore the formula to calculate the new offer price when placing an offer to a market is the following: offer_price_after_fees = offer_price + original_price * grid_fee_ratio If the offer is not purchased after two ticks, it is moved into the next market, where the price is increased by that market\u2019s grid fee. In the provided example, the PV offer of 0.10\u20ac is first placed in the House 2 Market where it gains zero fees. Then it propagates into the Neighborhood 2 Market, gaining the market\u2019s fee of 5% of the original offer price 0.10*0.05+0.10=0.105\u20ac . If unmatched, it propagates into the Grid Market, with an additional 10% fee of the original offer is applied: 0.10*0.10+0.105=0.115\u20ac . Continuing into the Neighborhood 1 Market, the offer gains another fee of 5% of the original price 0.10*0.05+0.115=0.12\u20ac . Continuing into the House 1 Market, the offer gains zero additional fees as there is no fee in that market. The Load buys the offer in the House 1 Market at the Clearing Price of 0.12\u20ac. Starting with the initial offer price, the total fees are calculated 0.10*(1+0.05+0.10+0.05)=0.02 to yield the Trade Price of 0.12\u20ac. The Load pays the Trade Price of 0.12\u20ac, which includes 0.10\u20ac revenue for the PV, 0.005\u20ac fees for the Neighborhood Market 1, 0.01\u20ac fees for the Grid Market, and 0.005\u20ac fees for the Neighborhood Market 2. Since the market type is pay-as-offer, the offer rates are used as Clearing Rates. The trade price is then calculated by multiplying the clearing rate with the energy volume. For each market trade, the market grid fee is calculated based on the original offer rate and it is subtracted from the trade_price, in order to calculate the trade price after fees (and thus the revenue for the seller). The following formula is used: market_fees = grid_fee_ratio * original_rate * energy_portion trade_price_after_fees = energy * trade_rate - market_fees trade_price = energy * trade_rate Example Calculation in Two-Sided Pay-as-Bid Market \u00b6 Figure 4.20 : Percentage Grid Fee Example Calculation in Two-Sided Pay-as-Bid Market. In the Two-Sided Pay-as-Bid market , both bids and offers are propagated through the markets in the hierarchy. If a bid or offer is not purchased after two ticks , it propagates into the next market. In order to prevent double accounting of a market's grid fee when a bid and an offer are matched in that market, market fees are added to offers when they enter that market (target market) and subtracted from bids when they leave that market and enter another (source market). The formula for propagating the offers is the same as for the one-sided market: offer_price_after_fees = offer_price + original_price * grid_fee_ratio The Market Agent (MA) subtracts the fees from the bid before propagating it to a higher market. The formula for an area to update the bid to include grid fees is the following: bid_price_after_fees = bid_price - original_price * grid_fee_ratio In the case of the Two-Sided Pay-as-Bid market, the offer has moved into the Grid Market by the same mechanism as for the One-Sided Pay-as-Offer market. The bid of 0.30\u20ac follows a similar mechanism and is placed into the House 1 Market where there are zero fees. If the bid is not purchased after two ticks, it is moved into the Neighborhood 1 Market. As explained above, only the fees from the source market are added, which are zero in this case. Hence the bid remains at 0.30\u20ac. Next, the bid is moved to the Grid Market, and incurs the fees of the source market, the Neighborhood 1 Market of 5% to 0.30-0.30*0.05=0.285\u20ac . In the example above, the bid and offer are matched in the Grid Market. When the offer entered the Grid Market, its price was immediately updated to account for the Grid Market's fees 0.10*0.10+0.105=0.115\u20ac . The bid, however, did not add the 10% fee as only the fees from the source markets are added. In the case that the bid was not matched in the Grid Market and moved into the Neighborhood 2 Market, the 10% fee from the Grid Market would be added to the bid. In this case, the bid would become 0.285-0.30*0.10=0.255\u20ac . In the Grid Market, the Load bid is listed as 0.285\u20ac and the PV offer is listed as 0.115\u20ac. As the bid rate is greater than the offer rate, a trade can be scheduled. The trade clears at the bid rate, resulting in a Clearing Price of 0.285\u20ac. The algorithm to calculate the final grid fees for each trade is decentralised, allowing the markets to act more independently without having to share information regarding their fees with other markets. In order to calculate the fee correctly based on the original price, the algorithm needs to be able to calculate the supply side and demand side fee. It is easily calculated using the most recent forwarded rate and the original bid or offer rate: demand_side_fee = 1 - (forwarded_bid_rate / original_bid_rate) supply_side_fee = (forwarded_offer_rate / original_offer_rate) - 1 The provided example has the following values: supply_side_fee=(0.115/0.1)-1=0.15 demand_side_fee=1-(0.285/0.3)=0.05 After calculating the supply and the demand side fee, the trade revenue can be determined. Note the original_trade_rate is the amount that the original buyer (in our case the Load) will need to pay, and therefore the original bid price in a Pay-as-Bid market. The formula is the following: total_fee_ratio = supply_side_fee + demand_side_fee revenue = original_trade_rate / (1 + total_fee_ratio) In the provided example, revenue = 0.30/(1+0.15+0.05)=0.25 The grid fees are then calculated based on the revenue and the individual market fees: fees = revenue * grid_fee_ratio For the Grid Market in the provided example, the fees are 0.25*0.1=0.025 , and for each Neighborhood market, the fees are 0.25*0.05=0.0125 . Finally, the trade rate is adapted according to include the supply side grid fee, in order to include the fees of the current market: trade_rate = revenue * (1 + supply_side_fee) trade_price = energy * trade_rate In the provided example, the trade price for each market is: Grid Market = 0.25 * (1 + 0.15) = 0.2875 Neighborhood 2 Market = 0.25 * (1 + 0.05) = 0.2625 Neighborhood 1 Market = 0.25 * (1 + 0.2) = 0.3 House 1 Market = 0.25 * (1 + 0.2) = 0.3 House 2 Market = 0.25 * (1 + 0) = 0.25 The Load pays the Trade Price of 0.30\u20ac, which includes 0.25\u20ac revenue for the PV, 0.0125\u20ac fees for the Neighborhood Market 1, 0.025\u20ac fees for the Grid Market, and 0.0125\u20ac fees for the Neighborhood Market 2.","title":"Percentage Grid Fee Calculation"},{"location":"percentage-fees/#example-calculation-in-one-sided-pay-as-offer-market","text":"Figure 4.19 : Percentage Grid Fee Example Calculation in One-Sided Pay-as-Offer Market. In the One-Sided Pay-as-Offer market , there are no bids, only offers. The offers are propagated throughout the markets in the hierarchy. The grid fees are taken into account when an offer is forwarded to the higher market, by the higher market itself. Therefore the agent is not responsible for adapting the offer price to include the grid fees. The grid fees' unit is a ratio of the original offer price, therefore the formula to calculate the new offer price when placing an offer to a market is the following: offer_price_after_fees = offer_price + original_price * grid_fee_ratio If the offer is not purchased after two ticks, it is moved into the next market, where the price is increased by that market\u2019s grid fee. In the provided example, the PV offer of 0.10\u20ac is first placed in the House 2 Market where it gains zero fees. Then it propagates into the Neighborhood 2 Market, gaining the market\u2019s fee of 5% of the original offer price 0.10*0.05+0.10=0.105\u20ac . If unmatched, it propagates into the Grid Market, with an additional 10% fee of the original offer is applied: 0.10*0.10+0.105=0.115\u20ac . Continuing into the Neighborhood 1 Market, the offer gains another fee of 5% of the original price 0.10*0.05+0.115=0.12\u20ac . Continuing into the House 1 Market, the offer gains zero additional fees as there is no fee in that market. The Load buys the offer in the House 1 Market at the Clearing Price of 0.12\u20ac. Starting with the initial offer price, the total fees are calculated 0.10*(1+0.05+0.10+0.05)=0.02 to yield the Trade Price of 0.12\u20ac. The Load pays the Trade Price of 0.12\u20ac, which includes 0.10\u20ac revenue for the PV, 0.005\u20ac fees for the Neighborhood Market 1, 0.01\u20ac fees for the Grid Market, and 0.005\u20ac fees for the Neighborhood Market 2. Since the market type is pay-as-offer, the offer rates are used as Clearing Rates. The trade price is then calculated by multiplying the clearing rate with the energy volume. For each market trade, the market grid fee is calculated based on the original offer rate and it is subtracted from the trade_price, in order to calculate the trade price after fees (and thus the revenue for the seller). The following formula is used: market_fees = grid_fee_ratio * original_rate * energy_portion trade_price_after_fees = energy * trade_rate - market_fees trade_price = energy * trade_rate","title":"Example Calculation in One-Sided Pay-as-Offer Market"},{"location":"percentage-fees/#example-calculation-in-two-sided-pay-as-bid-market","text":"Figure 4.20 : Percentage Grid Fee Example Calculation in Two-Sided Pay-as-Bid Market. In the Two-Sided Pay-as-Bid market , both bids and offers are propagated through the markets in the hierarchy. If a bid or offer is not purchased after two ticks , it propagates into the next market. In order to prevent double accounting of a market's grid fee when a bid and an offer are matched in that market, market fees are added to offers when they enter that market (target market) and subtracted from bids when they leave that market and enter another (source market). The formula for propagating the offers is the same as for the one-sided market: offer_price_after_fees = offer_price + original_price * grid_fee_ratio The Market Agent (MA) subtracts the fees from the bid before propagating it to a higher market. The formula for an area to update the bid to include grid fees is the following: bid_price_after_fees = bid_price - original_price * grid_fee_ratio In the case of the Two-Sided Pay-as-Bid market, the offer has moved into the Grid Market by the same mechanism as for the One-Sided Pay-as-Offer market. The bid of 0.30\u20ac follows a similar mechanism and is placed into the House 1 Market where there are zero fees. If the bid is not purchased after two ticks, it is moved into the Neighborhood 1 Market. As explained above, only the fees from the source market are added, which are zero in this case. Hence the bid remains at 0.30\u20ac. Next, the bid is moved to the Grid Market, and incurs the fees of the source market, the Neighborhood 1 Market of 5% to 0.30-0.30*0.05=0.285\u20ac . In the example above, the bid and offer are matched in the Grid Market. When the offer entered the Grid Market, its price was immediately updated to account for the Grid Market's fees 0.10*0.10+0.105=0.115\u20ac . The bid, however, did not add the 10% fee as only the fees from the source markets are added. In the case that the bid was not matched in the Grid Market and moved into the Neighborhood 2 Market, the 10% fee from the Grid Market would be added to the bid. In this case, the bid would become 0.285-0.30*0.10=0.255\u20ac . In the Grid Market, the Load bid is listed as 0.285\u20ac and the PV offer is listed as 0.115\u20ac. As the bid rate is greater than the offer rate, a trade can be scheduled. The trade clears at the bid rate, resulting in a Clearing Price of 0.285\u20ac. The algorithm to calculate the final grid fees for each trade is decentralised, allowing the markets to act more independently without having to share information regarding their fees with other markets. In order to calculate the fee correctly based on the original price, the algorithm needs to be able to calculate the supply side and demand side fee. It is easily calculated using the most recent forwarded rate and the original bid or offer rate: demand_side_fee = 1 - (forwarded_bid_rate / original_bid_rate) supply_side_fee = (forwarded_offer_rate / original_offer_rate) - 1 The provided example has the following values: supply_side_fee=(0.115/0.1)-1=0.15 demand_side_fee=1-(0.285/0.3)=0.05 After calculating the supply and the demand side fee, the trade revenue can be determined. Note the original_trade_rate is the amount that the original buyer (in our case the Load) will need to pay, and therefore the original bid price in a Pay-as-Bid market. The formula is the following: total_fee_ratio = supply_side_fee + demand_side_fee revenue = original_trade_rate / (1 + total_fee_ratio) In the provided example, revenue = 0.30/(1+0.15+0.05)=0.25 The grid fees are then calculated based on the revenue and the individual market fees: fees = revenue * grid_fee_ratio For the Grid Market in the provided example, the fees are 0.25*0.1=0.025 , and for each Neighborhood market, the fees are 0.25*0.05=0.0125 . Finally, the trade rate is adapted according to include the supply side grid fee, in order to include the fees of the current market: trade_rate = revenue * (1 + supply_side_fee) trade_price = energy * trade_rate In the provided example, the trade price for each market is: Grid Market = 0.25 * (1 + 0.15) = 0.2875 Neighborhood 2 Market = 0.25 * (1 + 0.05) = 0.2625 Neighborhood 1 Market = 0.25 * (1 + 0.2) = 0.3 House 1 Market = 0.25 * (1 + 0.2) = 0.3 House 2 Market = 0.25 * (1 + 0) = 0.25 The Load pays the Trade Price of 0.30\u20ac, which includes 0.25\u20ac revenue for the PV, 0.0125\u20ac fees for the Neighborhood Market 1, 0.025\u20ac fees for the Grid Market, and 0.0125\u20ac fees for the Neighborhood Market 2.","title":"Example Calculation in Two-Sided Pay-as-Bid Market"},{"location":"power-plant/","text":"A finite power plant is an energy supplier that offers a configurable amount of power per time slot at a set rate. This energy asset is currently available to users running simulations based on our backend source code , while users of the Grid Singularity interface Singularity Map can apply Grid market settings to integrate a power plant as an external supplier of the simulated local energy market.","title":"Power Plant"},{"location":"price/","text":"The price graph shows the minimum, the maximum and the average price of energy in \u20ac/kWh for each 15-minute market slot in a market. The grid fee is also shown if applied. If no trade occurred during a certain market interval, no lines are plotted. If grid fees are set in that market as a constant value, a fourth line is plotted to reflect its price. Figure 3.13 : Graph showing the evolution of the prices during the simulation period in the Grid Singularity\u2019s simulation interface (Singularity Map)","title":"Price Graph"},{"location":"references/","text":"Grid Singularity Medium articles \u00b6 Grid Singularity. (February 2, 2022). Medell\u00edn Colombia Local Energy Market Trial: Demonstrating Benefits of Enabling Peer-to-Peer Trading , https://gridsingularity.medium.com/medell%C3%ADn-colombia-local-energy-market-trial-demonstrating-benefits-of-enabling-peer-to-peer-e7db62f76d81 Grid Singularity. (November 10, 2021). Discussion Paper: Grid Singularity\u2019s Implementation of Symbiotic Energy Markets , https://gridsingularity.medium.com/discussion-paper-grid-singularitys-implementation-of-symbiotic-energy-markets-bd3954af43c8 Grid Singularity. (October 28, 2021). You are energy. , https://gridsingularity.medium.com/you-are-energy-db950f94fca9 Grid Singularity. (May 3, 2021). Grid Singularity and Rebase Energy Awarded 2021 AI4Cities Grant , https://gridsingularity.medium.com/grid-singularity-and-rebase-energy-awarded-2021-ai4cities-grant-4e0aa1cf3240 Grid Singularity. (December 10, 2020). Energy Singularity Challenge 2020: Testing Novel Grid Fee Models and Intelligent Peer-to-Peer Trading Strategies , https://gridsingularity.medium.com/energy-singularity-challenge-2020-testing-novel-grid-fee-models-and-intelligent-peer-to-peer-6a0d715a9063 Grid Singularity. (November 25, 2020). Energy Singularity Challenge 2020: Social Energy Networks , https://gridsingularity.medium.com/energy-singularity-challenge-2020-social-energy-networks-157b390e5f39 Grid Singularity. (September 10, 2020). En Route to Energy Singularity Odyssey Momentum: Learnings from the 2020 Chaos Experiment , https://gridsingularity.medium.com/en-route-to-energy-singularity-odyssey-momentum-learnings-from-the-2020-chaos-experiment-8dc38ff26869 Grid Singularity. (August 27, 2020). Modelling study to assess the potential benefits of trading in and between local energy communities in Germany , https://gridsingularity.medium.com/modelling-study-to-assess-the-potential-benefits-of-trading-in-and-between-local-energy-d721395ddd4b Grid Singularity. (June 18, 2020). Analysis of Local Electricity Markets as a Platform to Modernise Consumer and Grid Interaction , https://gridsingularity.medium.com/analysis-of-local-electricity-markets-as-a-platform-to-modernise-consumer-and-grid-interaction-3fff63ef74e7 Grid Singularity. (April 14, 2020). Deploying Local Electricity Markets to Optimise PV Integration; A Study of Three LEM Scenarios in Germany , https://gridsingularity.medium.com/deploying-local-electricity-markets-to-optimise-pv-integration-a-study-of-three-lem-scenarios-in-cf125b26f4dc Grid Singularity. (April 1, 2020). Energy Communities: a Game Changer for the European Electricity Grid , https://gridsingularity.medium.com/energy-communities-a-game-changer-for-the-european-electricity-grid-fd588a3063b0 Grid Singularity. (February 21, 2020). A Case for Flexibility Markets Enabled by Local Peer-to-Peer Exchanges , https://gridsingularity.medium.com/a-case-for-flexibility-markets-enabled-by-local-peer-to-peer-exchanges-43300b625cb5 Grid Singularity. (February 17, 2020). Stakeholders\u2019 Interest in Energy Market Design Innovation; Key Takeaways from the Odyssey Connect Energy Singularity Panel , https://gridsingularity.medium.com/stakeholders-interest-in-energy-market-design-innovation-key-takeaways-from-the-odyssey-connect-a6d18056ab34 Grid Singularity. (September 23, 2019). An Energy Exchange Engine for Local Energy Marketplaces , https://gridsingularity.medium.com/an-energy-exchange-engine-for-local-energy-marketplaces-28d5be23705e Books on Grid Singularity Energy Exchange (formerly D3A) \u00b6 Ana Trbovich, Sarah Hambridge, Dirk van den Biggelaar, Ewald Hesse, Fereidoon Sioshansi, Chapter 13 - D3A energy exchange for a transactive grid , Editor(s): Fereidoon Sioshansi, Behind and Beyond the Meter, Academic Press, 2020, Pages 267-284, ISBN 9780128199510, https://doi.org/10.1016/B978-0-12-819951-0.00013-X . (http://www.sciencedirect.com/science/article/pii/B978012819951000013X) Scientific articles and studies referencing Grid Singularity (formerly D3A) \u00b6 Karystinos, C.; Vasilakis, A.; Kotsampopoulos, P.; Hatziargyriou, N. Local Energy Exchange Market for Community Off-Grid Microgrids: Case Study Los Molinos del Rio Aguas. Energies 2022, 15, 703. https://doi.org/10.3390/en15030703 Okwuibe, Godwin C., Amin S. Gazafroudi, Sarah Hambridge, Christopher Dietrich, Ana Trbovich, Miadreza Shafie-khah, Peter Tzscheutschler, and Thomas Hamacher, Evaluation of Hierarchical, Multi-Agent, Community-Based, Local Energy Markets Based on Key Performance Indicators , Energies 15, no. 10: 3575, 2022. https://doi.org/10.3390/en15103575 Fatuma Ali, Juan Pablo C\u00e1rdenas \u00c1lvarez, Ana Trbovich, Andrea Bertolini, Juan Manuel Espa\u00f1a, and Santigo Ortega, Advancing From Community to Peer-To-Peer Energy Trading in the Medell\u00edn-Colombia Local Energy Market Trial , IEEE Smart Cities Newsletter, January 2022, https://smartcities.ieee.org/newsletter/january-2022/advancing-from-community-to-peer-to-peer-energy-trading-in-the-medellin-colombia-local-energy-market-trial A. S. Gazafroudi et al., Mathematical Model for Agent-based Local Energy Exchange Engine (D3A) , 2021 International Conference on Smart Energy Systems and Technologies (SEST), 2021. https://ieeexplore.ieee.org/abstract/document/9543262 G. C. Okwuibe, M. Wadhwa, T. Brenner, P. Tzscheutschler and T. Hamacher, Analysis of Key Performance Indicators for Local Electricity Markets' Design Analyse des indicateurs cl\u00e9s de performance pour la conception des march\u00e9s locaux de l'\u00e9lectricit\u00e9 , in IEEE Canadian Journal of Electrical and Computer Engineering, 2021. https://ieeexplore.ieee.org/abstract/document/9501942?casa_token=RetCo9BilxsAAAAA:Roi3KX5rUbYYveEnE8MFlIrRsX7RKjsv7DHOTaUNg7E3v0weSWAM_M04ebYC4bDsp6MJH2GKfw Kartikey Garg Tumul Vyas, Integration Of Smart Grid And Blockchain , 2021. https://scholar.archive.org/work/h4qouafhnrfifcqzppsrwilgwa/access/wayback/https://s3-eu-west-1.amazonaws.com/pstorage-techrxiv-6044451694/28501059/IntegrationOfSmartGridAndBlockchain.pdf M. Wadhwa, G. C. Okwuibe, T. Brenner, P. Tzscheutschler and T. Hamacher, Key Performance Indicator Based Design Guidelines for Local Electricity Markets , IEEE Electric Power and Energy Conference (EPEC), 2020. https://ieeexplore.ieee.org/abstract/document/9320047 BBEn, 100 prozent erneuerbar stiftung, Grid Singularity, Neue Kraft mit der Nachbarschaft , October 2020, https://www.buendnis-buergerenergie.de/fileadmin/nkmdn_Lokale_Strommaerkte.pdf Trbovich, Ana S. In Pursuit of Good Governance for the Energy Industry Blockchain . Journal of Energy Markets, May 2019, https://www.risk.net/node/6637136 . Danzi, P. Hambridge,S. Stefanovi\u0107, \u010c. Popovski,P. Blockchain-Based and Multi-Layered Electricity Imbalance Settlement Architecture . IEEE, December 27,2018. https://ieeexplore.ieee.org/abstract/document/8587577/references#references Graduate theses referencing Grid Singularity (formerly D3A) \u00b6 Sridharan, Srinidhi. Development of deterministic trading strategy for Peer-to-Peer (P2P) trading based on user-preferences , 11 January 2022, Master thesis, Technical University Chemnitz, Germany. Kement, Sanem. Designing a local electricity market using blockchain technology , 2020 https://www.researchgate.net/publication/344567774_Designing_a_local_electricity_market_using_blockchain_technology Wadhwa, Mukund. Analysis of local electricity markets in Germany using simulation , 2020 https://www.researchgate.net/publication/344567698_Analysis_of_local_electricity_markets_in_Germany_using_simulation Kalny, Laurin. Blockchain & Energy: How the technology behind Bitcoin can reinvent the way of doing business for utility providers , 2018. https://www.researchgate.net/publication/332471608_Blockchain_Energy_How_the_technology_behind_Bitcoin_can_reinvent_the_way_of_doing_business_for_utility_providers Meinardi, Bob. Opening up the innovation process: How energy companies acquire external knowledge for creating innovations with blockchain , 2022. Tavares, Tiago Manuel Massano. Development and Analysis of A Local Energy Market Using Blockchain , 2022 https://repositorio-aberto.up.pt/bitstream/10216/142867/2/572522.pdf","title":"References"},{"location":"references/#grid-singularity-medium-articles","text":"Grid Singularity. (February 2, 2022). Medell\u00edn Colombia Local Energy Market Trial: Demonstrating Benefits of Enabling Peer-to-Peer Trading , https://gridsingularity.medium.com/medell%C3%ADn-colombia-local-energy-market-trial-demonstrating-benefits-of-enabling-peer-to-peer-e7db62f76d81 Grid Singularity. (November 10, 2021). Discussion Paper: Grid Singularity\u2019s Implementation of Symbiotic Energy Markets , https://gridsingularity.medium.com/discussion-paper-grid-singularitys-implementation-of-symbiotic-energy-markets-bd3954af43c8 Grid Singularity. (October 28, 2021). You are energy. , https://gridsingularity.medium.com/you-are-energy-db950f94fca9 Grid Singularity. (May 3, 2021). Grid Singularity and Rebase Energy Awarded 2021 AI4Cities Grant , https://gridsingularity.medium.com/grid-singularity-and-rebase-energy-awarded-2021-ai4cities-grant-4e0aa1cf3240 Grid Singularity. (December 10, 2020). Energy Singularity Challenge 2020: Testing Novel Grid Fee Models and Intelligent Peer-to-Peer Trading Strategies , https://gridsingularity.medium.com/energy-singularity-challenge-2020-testing-novel-grid-fee-models-and-intelligent-peer-to-peer-6a0d715a9063 Grid Singularity. (November 25, 2020). Energy Singularity Challenge 2020: Social Energy Networks , https://gridsingularity.medium.com/energy-singularity-challenge-2020-social-energy-networks-157b390e5f39 Grid Singularity. (September 10, 2020). En Route to Energy Singularity Odyssey Momentum: Learnings from the 2020 Chaos Experiment , https://gridsingularity.medium.com/en-route-to-energy-singularity-odyssey-momentum-learnings-from-the-2020-chaos-experiment-8dc38ff26869 Grid Singularity. (August 27, 2020). Modelling study to assess the potential benefits of trading in and between local energy communities in Germany , https://gridsingularity.medium.com/modelling-study-to-assess-the-potential-benefits-of-trading-in-and-between-local-energy-d721395ddd4b Grid Singularity. (June 18, 2020). Analysis of Local Electricity Markets as a Platform to Modernise Consumer and Grid Interaction , https://gridsingularity.medium.com/analysis-of-local-electricity-markets-as-a-platform-to-modernise-consumer-and-grid-interaction-3fff63ef74e7 Grid Singularity. (April 14, 2020). Deploying Local Electricity Markets to Optimise PV Integration; A Study of Three LEM Scenarios in Germany , https://gridsingularity.medium.com/deploying-local-electricity-markets-to-optimise-pv-integration-a-study-of-three-lem-scenarios-in-cf125b26f4dc Grid Singularity. (April 1, 2020). Energy Communities: a Game Changer for the European Electricity Grid , https://gridsingularity.medium.com/energy-communities-a-game-changer-for-the-european-electricity-grid-fd588a3063b0 Grid Singularity. (February 21, 2020). A Case for Flexibility Markets Enabled by Local Peer-to-Peer Exchanges , https://gridsingularity.medium.com/a-case-for-flexibility-markets-enabled-by-local-peer-to-peer-exchanges-43300b625cb5 Grid Singularity. (February 17, 2020). Stakeholders\u2019 Interest in Energy Market Design Innovation; Key Takeaways from the Odyssey Connect Energy Singularity Panel , https://gridsingularity.medium.com/stakeholders-interest-in-energy-market-design-innovation-key-takeaways-from-the-odyssey-connect-a6d18056ab34 Grid Singularity. (September 23, 2019). An Energy Exchange Engine for Local Energy Marketplaces , https://gridsingularity.medium.com/an-energy-exchange-engine-for-local-energy-marketplaces-28d5be23705e","title":"Grid Singularity Medium articles"},{"location":"references/#books-on-grid-singularity-energy-exchange-formerly-d3a","text":"Ana Trbovich, Sarah Hambridge, Dirk van den Biggelaar, Ewald Hesse, Fereidoon Sioshansi, Chapter 13 - D3A energy exchange for a transactive grid , Editor(s): Fereidoon Sioshansi, Behind and Beyond the Meter, Academic Press, 2020, Pages 267-284, ISBN 9780128199510, https://doi.org/10.1016/B978-0-12-819951-0.00013-X . (http://www.sciencedirect.com/science/article/pii/B978012819951000013X)","title":"Books on Grid Singularity Energy Exchange (formerly D3A)"},{"location":"references/#scientific-articles-and-studies-referencing-grid-singularity-formerly-d3a","text":"Karystinos, C.; Vasilakis, A.; Kotsampopoulos, P.; Hatziargyriou, N. Local Energy Exchange Market for Community Off-Grid Microgrids: Case Study Los Molinos del Rio Aguas. Energies 2022, 15, 703. https://doi.org/10.3390/en15030703 Okwuibe, Godwin C., Amin S. Gazafroudi, Sarah Hambridge, Christopher Dietrich, Ana Trbovich, Miadreza Shafie-khah, Peter Tzscheutschler, and Thomas Hamacher, Evaluation of Hierarchical, Multi-Agent, Community-Based, Local Energy Markets Based on Key Performance Indicators , Energies 15, no. 10: 3575, 2022. https://doi.org/10.3390/en15103575 Fatuma Ali, Juan Pablo C\u00e1rdenas \u00c1lvarez, Ana Trbovich, Andrea Bertolini, Juan Manuel Espa\u00f1a, and Santigo Ortega, Advancing From Community to Peer-To-Peer Energy Trading in the Medell\u00edn-Colombia Local Energy Market Trial , IEEE Smart Cities Newsletter, January 2022, https://smartcities.ieee.org/newsletter/january-2022/advancing-from-community-to-peer-to-peer-energy-trading-in-the-medellin-colombia-local-energy-market-trial A. S. Gazafroudi et al., Mathematical Model for Agent-based Local Energy Exchange Engine (D3A) , 2021 International Conference on Smart Energy Systems and Technologies (SEST), 2021. https://ieeexplore.ieee.org/abstract/document/9543262 G. C. Okwuibe, M. Wadhwa, T. Brenner, P. Tzscheutschler and T. Hamacher, Analysis of Key Performance Indicators for Local Electricity Markets' Design Analyse des indicateurs cl\u00e9s de performance pour la conception des march\u00e9s locaux de l'\u00e9lectricit\u00e9 , in IEEE Canadian Journal of Electrical and Computer Engineering, 2021. https://ieeexplore.ieee.org/abstract/document/9501942?casa_token=RetCo9BilxsAAAAA:Roi3KX5rUbYYveEnE8MFlIrRsX7RKjsv7DHOTaUNg7E3v0weSWAM_M04ebYC4bDsp6MJH2GKfw Kartikey Garg Tumul Vyas, Integration Of Smart Grid And Blockchain , 2021. https://scholar.archive.org/work/h4qouafhnrfifcqzppsrwilgwa/access/wayback/https://s3-eu-west-1.amazonaws.com/pstorage-techrxiv-6044451694/28501059/IntegrationOfSmartGridAndBlockchain.pdf M. Wadhwa, G. C. Okwuibe, T. Brenner, P. Tzscheutschler and T. Hamacher, Key Performance Indicator Based Design Guidelines for Local Electricity Markets , IEEE Electric Power and Energy Conference (EPEC), 2020. https://ieeexplore.ieee.org/abstract/document/9320047 BBEn, 100 prozent erneuerbar stiftung, Grid Singularity, Neue Kraft mit der Nachbarschaft , October 2020, https://www.buendnis-buergerenergie.de/fileadmin/nkmdn_Lokale_Strommaerkte.pdf Trbovich, Ana S. In Pursuit of Good Governance for the Energy Industry Blockchain . Journal of Energy Markets, May 2019, https://www.risk.net/node/6637136 . Danzi, P. Hambridge,S. Stefanovi\u0107, \u010c. Popovski,P. Blockchain-Based and Multi-Layered Electricity Imbalance Settlement Architecture . IEEE, December 27,2018. https://ieeexplore.ieee.org/abstract/document/8587577/references#references","title":"Scientific articles and studies referencing Grid Singularity (formerly D3A)"},{"location":"references/#graduate-theses-referencing-grid-singularity-formerly-d3a","text":"Sridharan, Srinidhi. Development of deterministic trading strategy for Peer-to-Peer (P2P) trading based on user-preferences , 11 January 2022, Master thesis, Technical University Chemnitz, Germany. Kement, Sanem. Designing a local electricity market using blockchain technology , 2020 https://www.researchgate.net/publication/344567774_Designing_a_local_electricity_market_using_blockchain_technology Wadhwa, Mukund. Analysis of local electricity markets in Germany using simulation , 2020 https://www.researchgate.net/publication/344567698_Analysis_of_local_electricity_markets_in_Germany_using_simulation Kalny, Laurin. Blockchain & Energy: How the technology behind Bitcoin can reinvent the way of doing business for utility providers , 2018. https://www.researchgate.net/publication/332471608_Blockchain_Energy_How_the_technology_behind_Bitcoin_can_reinvent_the_way_of_doing_business_for_utility_providers Meinardi, Bob. Opening up the innovation process: How energy companies acquire external knowledge for creating innovations with blockchain , 2022. Tavares, Tiago Manuel Massano. Development and Analysis of A Local Energy Market Using Blockchain , 2022 https://repositorio-aberto.up.pt/bitstream/10216/142867/2/572522.pdf","title":"Graduate theses referencing Grid Singularity (formerly D3A)"},{"location":"registration-asset-api-backend/","text":"Note: If you are running the Grid Singularity exchange (previously callled D3A) using a virtual machine and vagrant , the latest GSy-e SDK is already installed on your computer and you can skip to the Launch Simulation section below. If you are running the exchange software locally, please follow the following instructions. Start Redis server \u00b6 To use the API locally, your script interacts with the simulation using a local Redis instance. To start the redis instance, open a new terminal and run the following command : redis-server /usr/local/etc/redis.conf To install redis in Ubuntu follow the instructions in this link . Open external connection to API for Assets \u00b6 In the setup file (template available here ), an asset must be designated as open to external connection via the API. This is controlled when setting up the simulation in the setup file by designating the ExternalStrategy for each relevant energy assets : Market('Family 3 children+PV+Batt', [ Asset('Load 3 L17', strategy=LoadProfileExternalStrategy( daily_load_profile=os.path.join(current_dir, \"resources/CHR41 Family with 3 children, both at work HH1.csv\"), initial_buying_rate=Load_initial_buying_rate, final_buying_rate=Load_final_buying_rate), ), Asset('PV 3 (5kW)', strategy=PVUserProfileExternalStrategy( power_profile=os.path.join(current_dir, \"resources/Berlin_pv.csv\"), panel_count=5, initial_selling_rate=30, final_selling_rate=11), ), Asset('Tesla Powerwall 3', strategy=StorageExternalStrategy(initial_soc=10, 54min_allowed_soc=10, battery_capacity_kWh=14, max_abs_battery_power_kW=5, initial_buying_rate=0, final_buying_rate=25, initial_selling_rate=30, final_selling_rate=25.1), ), ]), By default, trading strategies do not allow API connections unless the ExternalStrategy is used. Please also ensure that the appropriate libraries are imported to use the API. Launch simulation \u00b6 This requires you to have the backend codebase installed on your machine to run simulations (see Installation Instructions ). First, navigate to the Grid Singularity folder (gsy) in a new terminal, then activate the Grid Singularity (gsy-env) environment with the command: workon gsy-env An template setup is already available in github and ready to be run here (data available for the July 2021). To run this simulation and wait for the API template script to execute: gsy-env -l INFO run -t 15s -s 15m --setup api_setup.default_community --slot-length-realtime 5 --start-date 2021-07-01 --enable-external-connection --paused After few seconds, the simulation should begin, waiting for the API template as mentioned in the figure below: Here you can find more information on launching a simulation on the backend. Initialise and start the API : \u00b6 Before launching the SDK Script, users need to adapt the following information in their script: Oracle name \u00b6 This parameter is only relevant when using the API on the User-Interface. This defines the name of the aggregator / API name that manages the markets and energy assets. Once the name is set it cannot be changed within the same running collaboration. oracle_name = 'oracle' Assets list \u00b6 The list of assets needs to be updated to include the assets registered to user through the registration process, in arrays as follows : load_names = ['Load 1 L13', 'Load 2 L21', 'Load 3 L17'] pv_names = ['PV 1 (4kW)', 'PV 3 (5kW)'] storage_names = ['Tesla Powerwall 3'] market_names = [\"Grid\", \"Community\"] The SDK Script has an \u201cautomatic\u201d connection process to manage energy assets. If the function automatic is True, the Exchange SDK will automatically connect to all energy assets that it is registered to. This option is only available for simulations running on the User-Interface. Interact with local simulations \u00b6 To interact with a locally running simulation (backend simulation), username, passwords, domain and websocket names and simulation_id are not necessary. There is only an additional flag required in the CLI command : --run-on-redis. gsy-e-sdk --log-level INFO run --setup asset_api_template --run-on-redis Log levels: \u00b6 The API CLI command can receive a --log-level argument. Adjusting this parameter will increase or reduce the level of information displayed in the terminal, while the agent is running. There are 4 levels (classed from low detailed to high: ERROR \u00b6 Display only critical errors from the Exchange SDK or the Grid Singularity Exchange (for instance, if Grid Singularity Exchange responds with an error in a command that the Exchange SDK is sending, the error log should include it) WARNING \u00b6 Display non-critical error messages (for instance if the API agent is over bidding its energy requirement) INFO \u00b6 Display critical and non-critical errors messages and general information such as market progression and trades DEBUG \u00b6 Display full information on the agent (for instance all command and response, such as placing bids and offers on the market) For a video tutorial on the Asset API, please follow this link . We recommend that the users experiment with trading strategies, verify their data and familiarize themselves with the Grid Singularity user interface and APIs in a Collaboration environment before initiating a Canary Test Network.","title":"Registration - Simulations run on the Backend"},{"location":"registration-asset-api-backend/#start-redis-server","text":"To use the API locally, your script interacts with the simulation using a local Redis instance. To start the redis instance, open a new terminal and run the following command : redis-server /usr/local/etc/redis.conf To install redis in Ubuntu follow the instructions in this link .","title":"Start Redis server"},{"location":"registration-asset-api-backend/#open-external-connection-to-api-for-assets","text":"In the setup file (template available here ), an asset must be designated as open to external connection via the API. This is controlled when setting up the simulation in the setup file by designating the ExternalStrategy for each relevant energy assets : Market('Family 3 children+PV+Batt', [ Asset('Load 3 L17', strategy=LoadProfileExternalStrategy( daily_load_profile=os.path.join(current_dir, \"resources/CHR41 Family with 3 children, both at work HH1.csv\"), initial_buying_rate=Load_initial_buying_rate, final_buying_rate=Load_final_buying_rate), ), Asset('PV 3 (5kW)', strategy=PVUserProfileExternalStrategy( power_profile=os.path.join(current_dir, \"resources/Berlin_pv.csv\"), panel_count=5, initial_selling_rate=30, final_selling_rate=11), ), Asset('Tesla Powerwall 3', strategy=StorageExternalStrategy(initial_soc=10, 54min_allowed_soc=10, battery_capacity_kWh=14, max_abs_battery_power_kW=5, initial_buying_rate=0, final_buying_rate=25, initial_selling_rate=30, final_selling_rate=25.1), ), ]), By default, trading strategies do not allow API connections unless the ExternalStrategy is used. Please also ensure that the appropriate libraries are imported to use the API.","title":"Open external connection to API for Assets"},{"location":"registration-asset-api-backend/#launch-simulation","text":"This requires you to have the backend codebase installed on your machine to run simulations (see Installation Instructions ). First, navigate to the Grid Singularity folder (gsy) in a new terminal, then activate the Grid Singularity (gsy-env) environment with the command: workon gsy-env An template setup is already available in github and ready to be run here (data available for the July 2021). To run this simulation and wait for the API template script to execute: gsy-env -l INFO run -t 15s -s 15m --setup api_setup.default_community --slot-length-realtime 5 --start-date 2021-07-01 --enable-external-connection --paused After few seconds, the simulation should begin, waiting for the API template as mentioned in the figure below: Here you can find more information on launching a simulation on the backend.","title":"Launch simulation"},{"location":"registration-asset-api-backend/#initialise-and-start-the-api","text":"Before launching the SDK Script, users need to adapt the following information in their script:","title":"Initialise and start the API :"},{"location":"registration-asset-api-backend/#oracle-name","text":"This parameter is only relevant when using the API on the User-Interface. This defines the name of the aggregator / API name that manages the markets and energy assets. Once the name is set it cannot be changed within the same running collaboration. oracle_name = 'oracle'","title":"Oracle name"},{"location":"registration-asset-api-backend/#assets-list","text":"The list of assets needs to be updated to include the assets registered to user through the registration process, in arrays as follows : load_names = ['Load 1 L13', 'Load 2 L21', 'Load 3 L17'] pv_names = ['PV 1 (4kW)', 'PV 3 (5kW)'] storage_names = ['Tesla Powerwall 3'] market_names = [\"Grid\", \"Community\"] The SDK Script has an \u201cautomatic\u201d connection process to manage energy assets. If the function automatic is True, the Exchange SDK will automatically connect to all energy assets that it is registered to. This option is only available for simulations running on the User-Interface.","title":"Assets list"},{"location":"registration-asset-api-backend/#interact-with-local-simulations","text":"To interact with a locally running simulation (backend simulation), username, passwords, domain and websocket names and simulation_id are not necessary. There is only an additional flag required in the CLI command : --run-on-redis. gsy-e-sdk --log-level INFO run --setup asset_api_template --run-on-redis","title":"Interact with local simulations"},{"location":"registration-asset-api-backend/#log-levels","text":"The API CLI command can receive a --log-level argument. Adjusting this parameter will increase or reduce the level of information displayed in the terminal, while the agent is running. There are 4 levels (classed from low detailed to high:","title":"Log levels:"},{"location":"registration-asset-api-backend/#error","text":"Display only critical errors from the Exchange SDK or the Grid Singularity Exchange (for instance, if Grid Singularity Exchange responds with an error in a command that the Exchange SDK is sending, the error log should include it)","title":"ERROR"},{"location":"registration-asset-api-backend/#warning","text":"Display non-critical error messages (for instance if the API agent is over bidding its energy requirement)","title":"WARNING"},{"location":"registration-asset-api-backend/#info","text":"Display critical and non-critical errors messages and general information such as market progression and trades","title":"INFO"},{"location":"registration-asset-api-backend/#debug","text":"Display full information on the agent (for instance all command and response, such as placing bids and offers on the market) For a video tutorial on the Asset API, please follow this link . We recommend that the users experiment with trading strategies, verify their data and familiarize themselves with the Grid Singularity user interface and APIs in a Collaboration environment before initiating a Canary Test Network.","title":"DEBUG"},{"location":"registration-asset-api-user-interface/","text":"Note: The following instructions serve as a guide to launch the Grid Operator API as well. The Asset API is launched with a cli command. To launch the Asset API, the user needs to open a new terminal and activate the gsy-e-sdk environment (Grid Singularity Exchange SDK). workon gsy-e-sdk And go to the GSy Exchange SDK repository cd path_to_repository/gsy-e-sdk The API launch CLI command takes several arguments that can be listed with: gsy-e-sdk run --help The arguments are : base-setup-path --> Set the base path where the user's client script resides, otherwise gsy-e-sdk/setups is taken as default for the user's client scripts. Users can provide either an absolute or a relative file path. setup --> Name of user's SDK module/script. username --> Username of agent authorised to communicate with respective collaboration/CN. password --> Password of respective agent domain-name --> Grid Singularity Exchange domain name web-socket --> Grid Singularity Exchange websocket URI simulation-id --> UUID of the collaboration or Canary Test Network simulation-config-path --> Path to the JSON file that contains the user's collaboration/CN information. run-on-redis --> This flag targets the local testing of the SDK, where no user authentication is required. A locally running redis server and a running Grid Singularity CLI simulation are needed here. The API agent can interface with a local simulation ( backend ) or a collaboration / Canary Network ( User-Interface ). There are 3 methods to parse the required information when launching the API to connect to the UI, as thoroughly explained in the text below: Simulation configuration file CLI command Environment variables Simulation configuration file: \u00b6 The simulation configuration file is a JSON format file downloadable on the User-Interface . It contains all the information about the simulation setup (username, simulation name and UUID, domain name, websocket domain name, global settings of the simulation and the registry, consisting of all the grid hierarchy including markets and assets and whether or not the user is connected to those). To download this file the user needs to go to the Registry page of the relevant collaboration/Canary Test Network and click on the top right edit icon and Download Exchange SDK Summary. To run the Asset API, you can run the following command by adapting the arguments to your case: gsy-e-sdk --log-level INFO run --setup asset_api_template -u username -p password -i absolute_path/my_simulation_config.json CLI command: \u00b6 Instead of passing the JSON file, the user can directly pass the relevant variables as arguments in the CLI commands. For that to work, the user needs to pass the domain name and websocket name (both are optional parameters and only relevant when connecting to specific domains) and the simulation_id. The simulation_id corresponds to the Universally Unique Identifier. This token can be found in the URL of a collaboration or a Canary Test Network in the User Interface. To run the Asset API, users can run the following command by adapting the arguments to their case: gsy-e-sdk --log-level INFO run --setup asset_api_template -u username -p password --simulation-id UUID Environnement variables: \u00b6 The last method to launch the API is send the set the required variable in the environment. To do that users can simply define those parameters at the top of their script as follows: os.environ[\"API_CLIENT_USERNAME\"] = \"username\" os.environ[\"API_CLIENT_PASSWORD\"] = \"password\" os.environ[\"API_CLIENT_SIMULATION_ID\"] = \"simulation_uuid\" To run the Asset API, you can run the following command by adapting the arguments to your case: gsy-e-sdk --log-level INFO run --setup asset_api_template Local simulation: \u00b6 To interact with a locally running simulation (backend simulation), username, passwords, domain and websocket names and simulation_id are not necessary. There is only an additional flag required in the CLI command : --run-on-redis . gsy-e-sdk --log-level INFO run --setup asset_api_template --run-on-redis Once the Asset SDK Script has been launched, you can click on \u201cRun\u201d in the Results page of your Collaboration in the User-Interface.","title":"Registration - Simulations run on the User-Interface"},{"location":"registration-asset-api-user-interface/#simulation-configuration-file","text":"The simulation configuration file is a JSON format file downloadable on the User-Interface . It contains all the information about the simulation setup (username, simulation name and UUID, domain name, websocket domain name, global settings of the simulation and the registry, consisting of all the grid hierarchy including markets and assets and whether or not the user is connected to those). To download this file the user needs to go to the Registry page of the relevant collaboration/Canary Test Network and click on the top right edit icon and Download Exchange SDK Summary. To run the Asset API, you can run the following command by adapting the arguments to your case: gsy-e-sdk --log-level INFO run --setup asset_api_template -u username -p password -i absolute_path/my_simulation_config.json","title":"Simulation configuration file:"},{"location":"registration-asset-api-user-interface/#cli-command","text":"Instead of passing the JSON file, the user can directly pass the relevant variables as arguments in the CLI commands. For that to work, the user needs to pass the domain name and websocket name (both are optional parameters and only relevant when connecting to specific domains) and the simulation_id. The simulation_id corresponds to the Universally Unique Identifier. This token can be found in the URL of a collaboration or a Canary Test Network in the User Interface. To run the Asset API, users can run the following command by adapting the arguments to their case: gsy-e-sdk --log-level INFO run --setup asset_api_template -u username -p password --simulation-id UUID","title":"CLI command:"},{"location":"registration-asset-api-user-interface/#environnement-variables","text":"The last method to launch the API is send the set the required variable in the environment. To do that users can simply define those parameters at the top of their script as follows: os.environ[\"API_CLIENT_USERNAME\"] = \"username\" os.environ[\"API_CLIENT_PASSWORD\"] = \"password\" os.environ[\"API_CLIENT_SIMULATION_ID\"] = \"simulation_uuid\" To run the Asset API, you can run the following command by adapting the arguments to your case: gsy-e-sdk --log-level INFO run --setup asset_api_template","title":"Environnement variables:"},{"location":"registration-asset-api-user-interface/#local-simulation","text":"To interact with a locally running simulation (backend simulation), username, passwords, domain and websocket names and simulation_id are not necessary. There is only an additional flag required in the CLI command : --run-on-redis . gsy-e-sdk --log-level INFO run --setup asset_api_template --run-on-redis Once the Asset SDK Script has been launched, you can click on \u201cRun\u201d in the Results page of your Collaboration in the User-Interface.","title":"Local simulation:"},{"location":"registration-grid-operator-api-backend/","text":"Start Redis server \u00b6 To use the API locally, your script interacts with the simulation using a local Redis instance. To start the redis instance, open a new terminal and run the following command : redis-server /usr/local/etc/redis.conf To install redis in Ubuntu follow the instructions in this link . Open Markets for external cnnection \u00b6 The API supports multiple markets managed with the Grid Operator API. Access is controlled when setting up the simulation, using the Market and Asset classes\u2019 boolean argument called external_connection_available: Market( 'Community', [ ... ], grid_fee_constant=4, external_connection_available=True), If set to True , the market allows all the Grid Operator API to connect to that market, receive statistics and change grid fees. By default, this external_connection_available is set to False . Launch simulation \u00b6 This requires you to have the backend codebase installed on your machine to run simulations (see Installation Instructions ). First, navigate to the Grid Singularity folder (gsy) in a new terminal, then activate the Grid Singularity (gsy-env) environment with the command: workon gsy-env Then, launch the simulation by running the following command and adapting the arguments to your case and wait for the SDK Script to execute: gsy-env -l INFO run -t 15s -s 15m --setup api_setup.default_community --slot-length-realtime 5 --start-date 2021-07-01 --enable-external-connection --paused After few seconds, the simulation should begin, waiting for the API template as mentioned in the figure below: Here you can find more information on launching a simulation on the backend . Initialise and start the API : \u00b6 Before launching the SDK Script, users need to adapt the following information in their script: Oracle name \u00b6 This parameter is only relevant when using the API on the User-Interface. This defines the name of the aggregator / API name that manages the markets and energy assets. Once the name is set it cannot be changed within the same running collaboration. oracle_name = 'dso' Markets list \u00b6 The list of markets needs to be updated to include the assets registered to user through the registration process, in arrays as follows : market_names = [\"Grid\", \"Community\"] market_names = [\"Grid\", \"Community\"] The SDK Script has an \u201cautomatic\u201d connection process to manage energy assets. If the function automatic is True, the Exchange SDK will automatically connect to all energy assets that it is registered to. This option is only available for simulations running on the User-Interface. Interact with local simulations \u00b6 To interact with a locally running simulation (backend simulation), username, passwords, domain and websocket names and simulation_id are not necessary. There is only an additional flag required in the CLI command : --run-on-redis. gsy-e-sdk --log-level INFO run --setup gird_operator_api_template --run-on-redis Log levels: \u00b6 The API CLI command can receive a --log-level argument. Adjusting this parameter will increase or reduce the level of information displayed in the terminal, while the agent is running. There are 4 levels (classed from low detailed to high: ERROR \u00b6 Display only critical errors from the Exchange SDK or the Grid Singularity Exchange (for instance, if Grid Singularity Exchange responds with an error in a command that the Exchange SDK is sending, the error log should include it) WARNING \u00b6 Display non-critical error messages (for instance if the API agent is over bidding its energy requirement) INFO \u00b6 Display critical and non-critical errors messages and general information such as market progression and trades DEBUG \u00b6 Display full information on the agent (for instance all command and response, such as placing bids and offers on the market) For a video tutorial on the Asset API, please follow this link . We recommend that the users experiment with trading strategies, verify their data and familiarize themselves with the Grid Singularity user interface and APIs in a Collaboration environment before initiating a Canary Test Network.","title":"Registration - Simulations run on the Backend"},{"location":"registration-grid-operator-api-backend/#start-redis-server","text":"To use the API locally, your script interacts with the simulation using a local Redis instance. To start the redis instance, open a new terminal and run the following command : redis-server /usr/local/etc/redis.conf To install redis in Ubuntu follow the instructions in this link .","title":"Start Redis server"},{"location":"registration-grid-operator-api-backend/#open-markets-for-external-cnnection","text":"The API supports multiple markets managed with the Grid Operator API. Access is controlled when setting up the simulation, using the Market and Asset classes\u2019 boolean argument called external_connection_available: Market( 'Community', [ ... ], grid_fee_constant=4, external_connection_available=True), If set to True , the market allows all the Grid Operator API to connect to that market, receive statistics and change grid fees. By default, this external_connection_available is set to False .","title":"Open Markets for external cnnection"},{"location":"registration-grid-operator-api-backend/#launch-simulation","text":"This requires you to have the backend codebase installed on your machine to run simulations (see Installation Instructions ). First, navigate to the Grid Singularity folder (gsy) in a new terminal, then activate the Grid Singularity (gsy-env) environment with the command: workon gsy-env Then, launch the simulation by running the following command and adapting the arguments to your case and wait for the SDK Script to execute: gsy-env -l INFO run -t 15s -s 15m --setup api_setup.default_community --slot-length-realtime 5 --start-date 2021-07-01 --enable-external-connection --paused After few seconds, the simulation should begin, waiting for the API template as mentioned in the figure below: Here you can find more information on launching a simulation on the backend .","title":"Launch simulation"},{"location":"registration-grid-operator-api-backend/#initialise-and-start-the-api","text":"Before launching the SDK Script, users need to adapt the following information in their script:","title":"Initialise and start the API :"},{"location":"registration-grid-operator-api-backend/#oracle-name","text":"This parameter is only relevant when using the API on the User-Interface. This defines the name of the aggregator / API name that manages the markets and energy assets. Once the name is set it cannot be changed within the same running collaboration. oracle_name = 'dso'","title":"Oracle name"},{"location":"registration-grid-operator-api-backend/#markets-list","text":"The list of markets needs to be updated to include the assets registered to user through the registration process, in arrays as follows : market_names = [\"Grid\", \"Community\"] market_names = [\"Grid\", \"Community\"] The SDK Script has an \u201cautomatic\u201d connection process to manage energy assets. If the function automatic is True, the Exchange SDK will automatically connect to all energy assets that it is registered to. This option is only available for simulations running on the User-Interface.","title":"Markets list"},{"location":"registration-grid-operator-api-backend/#interact-with-local-simulations","text":"To interact with a locally running simulation (backend simulation), username, passwords, domain and websocket names and simulation_id are not necessary. There is only an additional flag required in the CLI command : --run-on-redis. gsy-e-sdk --log-level INFO run --setup gird_operator_api_template --run-on-redis","title":"Interact with local simulations"},{"location":"registration-grid-operator-api-backend/#log-levels","text":"The API CLI command can receive a --log-level argument. Adjusting this parameter will increase or reduce the level of information displayed in the terminal, while the agent is running. There are 4 levels (classed from low detailed to high:","title":"Log levels:"},{"location":"registration-grid-operator-api-backend/#error","text":"Display only critical errors from the Exchange SDK or the Grid Singularity Exchange (for instance, if Grid Singularity Exchange responds with an error in a command that the Exchange SDK is sending, the error log should include it)","title":"ERROR"},{"location":"registration-grid-operator-api-backend/#warning","text":"Display non-critical error messages (for instance if the API agent is over bidding its energy requirement)","title":"WARNING"},{"location":"registration-grid-operator-api-backend/#info","text":"Display critical and non-critical errors messages and general information such as market progression and trades","title":"INFO"},{"location":"registration-grid-operator-api-backend/#debug","text":"Display full information on the agent (for instance all command and response, such as placing bids and offers on the market) For a video tutorial on the Asset API, please follow this link . We recommend that the users experiment with trading strategies, verify their data and familiarize themselves with the Grid Singularity user interface and APIs in a Collaboration environment before initiating a Canary Test Network.","title":"DEBUG"},{"location":"registration-grid-operator-api-user-interface/","text":"To Launch the Grid Operator API from the User-Interface, please follow the same instructions given for the Asset API here .","title":"Registration - Simulations run on the User-Interface"},{"location":"registration-matching-api-backend/","text":"For local test runs of Grid Singularity Exchange (backend simulation), redis is used as a communication protocol. Install Redis server \u00b6 To install the Redis server, open a new terminal window and type: brew install redis To install redis in Ubuntu follow the instructions in this link . To start the redis instance, open a new terminal and run the following command: redis-server /usr/local/etc/redis.conf The path for the Redis server would be the location where the Redis is installed in your system. Install the matching-engine-api-client \u00b6 Make a new virtual environment for the Matching API client: mkvirtualenv gsy-matching-engine-sdk Clone the GitHub directory of the Matching Engine client: pip clone git+https://github.com/gridsingularity/gsy-matching-engine-sdk.git Install the requirements: pip install - e. Enabling external connection for clearing the market \u00b6 To register an asset through API and to use an external matching algorithm it is required to specify the following line in the exchange setup file: ConstSettings.MASettings.MARKET_TYPE = 2 ConstSettings.MASettings.BID_OFFER_MATCH_TYPE = (BidOfferMatchAlgoEnum.EXTERNAL.value) An example simulation setup can be found here. For more information on how to build this setup and add more markets and assets please visit this page. Launch Simulation \u00b6 Once the entire grid architecture is modeled, including energy assets, the user can launch the simulation by running a command-line including desired setup features: gsy-e -l INFO run -t 10s -s 15m --setup matching_engine_setup.external_matching_engine --enable-external-connection --paused --slot-length-realtime 12 After a few seconds, the simulation should begin, waiting for the API template as mentioned in the figure below: Initialise and start the API: \u00b6 The Matching API is launched with a cli command. To launch the Matching API, the user needs to open a new terminal and activate the MatchingEngine-SDK environment: workon gsy-matching-engine-sdk Now, go to the MatchingEngine-SDK directory: cd path_to_directory/gsy-matching-engine-sdk The api launch CLI command takes several arguments that can be listed with: gsy-matching-engine-sdk run --help The arguments are: base-setup-path --> Set the base path where the user's client script resides, otherwise, gsy_matching_engine_sdk/setups are taken as default for the user's client scripts. Users can provide either an absolute or a relative file path. setup --> Name of user's Matching API module/script. username --> Username of the agent authorized to communicate with respective collaboration/CN. password --> Password of the respective agent domain-name --> GSy-e domain name web-socket --> GSy-e WebSocket URI simulation-id --> UUID of the collaboration or Canary Network (CN) run-on-redis --> This flag targets the local testing of the Matching Engine SDK, where no user authentication is required. A locally running redis server and gsy-e simulation are needed here. Interact with local simulations \u00b6 To interact with a locally running simulation (backend simulation), username, passwords, domain and websocket names and simulation_id are not necessary. There is only an additional flag required in the CLI command : --run-on-redis. gsy-matching-engine-sdk --log-level INFO run --setup matching_api_template --run-on-redis Log levels: \u00b6 The API CLI command can receive a --log-level argument. Adjusting this parameter will increase or reduce the level of information displayed in the terminal, while the agent is running. There are 4 levels (classed from low detailed to high: ERROR \u00b6 Display only critical errors from the Exchange SDK or the Grid Singularity Exchange (for instance, if Grid Singularity Exchange responds with an error in a command that the Exchange SDK is sending, the error log should include it) WARNING \u00b6 Display non-critical error messages (for instance if the API agent is over bidding its energy requirement) INFO \u00b6 Display critical and non-critical errors messages and general information such as market progression and trades DEBUG \u00b6 Display full information on the agent (for instance all command and response, such as placing bids and offers on the market)","title":"Registration - Simulations run on the Backend"},{"location":"registration-matching-api-backend/#install-redis-server","text":"To install the Redis server, open a new terminal window and type: brew install redis To install redis in Ubuntu follow the instructions in this link . To start the redis instance, open a new terminal and run the following command: redis-server /usr/local/etc/redis.conf The path for the Redis server would be the location where the Redis is installed in your system.","title":"Install Redis server"},{"location":"registration-matching-api-backend/#install-the-matching-engine-api-client","text":"Make a new virtual environment for the Matching API client: mkvirtualenv gsy-matching-engine-sdk Clone the GitHub directory of the Matching Engine client: pip clone git+https://github.com/gridsingularity/gsy-matching-engine-sdk.git Install the requirements: pip install - e.","title":"Install the matching-engine-api-client"},{"location":"registration-matching-api-backend/#enabling-external-connection-for-clearing-the-market","text":"To register an asset through API and to use an external matching algorithm it is required to specify the following line in the exchange setup file: ConstSettings.MASettings.MARKET_TYPE = 2 ConstSettings.MASettings.BID_OFFER_MATCH_TYPE = (BidOfferMatchAlgoEnum.EXTERNAL.value) An example simulation setup can be found here. For more information on how to build this setup and add more markets and assets please visit this page.","title":"Enabling external connection for clearing the market"},{"location":"registration-matching-api-backend/#launch-simulation","text":"Once the entire grid architecture is modeled, including energy assets, the user can launch the simulation by running a command-line including desired setup features: gsy-e -l INFO run -t 10s -s 15m --setup matching_engine_setup.external_matching_engine --enable-external-connection --paused --slot-length-realtime 12 After a few seconds, the simulation should begin, waiting for the API template as mentioned in the figure below:","title":"Launch Simulation"},{"location":"registration-matching-api-backend/#initialise-and-start-the-api","text":"The Matching API is launched with a cli command. To launch the Matching API, the user needs to open a new terminal and activate the MatchingEngine-SDK environment: workon gsy-matching-engine-sdk Now, go to the MatchingEngine-SDK directory: cd path_to_directory/gsy-matching-engine-sdk The api launch CLI command takes several arguments that can be listed with: gsy-matching-engine-sdk run --help The arguments are: base-setup-path --> Set the base path where the user's client script resides, otherwise, gsy_matching_engine_sdk/setups are taken as default for the user's client scripts. Users can provide either an absolute or a relative file path. setup --> Name of user's Matching API module/script. username --> Username of the agent authorized to communicate with respective collaboration/CN. password --> Password of the respective agent domain-name --> GSy-e domain name web-socket --> GSy-e WebSocket URI simulation-id --> UUID of the collaboration or Canary Network (CN) run-on-redis --> This flag targets the local testing of the Matching Engine SDK, where no user authentication is required. A locally running redis server and gsy-e simulation are needed here.","title":"Initialise and start the API:"},{"location":"registration-matching-api-backend/#interact-with-local-simulations","text":"To interact with a locally running simulation (backend simulation), username, passwords, domain and websocket names and simulation_id are not necessary. There is only an additional flag required in the CLI command : --run-on-redis. gsy-matching-engine-sdk --log-level INFO run --setup matching_api_template --run-on-redis","title":"Interact with local simulations"},{"location":"registration-matching-api-backend/#log-levels","text":"The API CLI command can receive a --log-level argument. Adjusting this parameter will increase or reduce the level of information displayed in the terminal, while the agent is running. There are 4 levels (classed from low detailed to high:","title":"Log levels:"},{"location":"registration-matching-api-backend/#error","text":"Display only critical errors from the Exchange SDK or the Grid Singularity Exchange (for instance, if Grid Singularity Exchange responds with an error in a command that the Exchange SDK is sending, the error log should include it)","title":"ERROR"},{"location":"registration-matching-api-backend/#warning","text":"Display non-critical error messages (for instance if the API agent is over bidding its energy requirement)","title":"WARNING"},{"location":"registration-matching-api-backend/#info","text":"Display critical and non-critical errors messages and general information such as market progression and trades","title":"INFO"},{"location":"registration-matching-api-backend/#debug","text":"Display full information on the agent (for instance all command and response, such as placing bids and offers on the market)","title":"DEBUG"},{"location":"registration-matching-api-user-interface/","text":"Currently, it is not possible to connect to the Matching API through the User-Interface .","title":"Registration - Simulations run on the User-Interface"},{"location":"releases/","text":"Version 1.5 \u00b6 The following features were implemented: An updated energy bills table shows the amount of energy communities or homes are buying and selling in the market Simulation results can be filtered by week to view the results for individual weeks Users can request a Grid Singularity Canary Test Network , a real-time test network version of a local energy market that uses real asset data when available. Requesting a Canary Network will give information about the process and requirements to set up a local energy community in your region, within regulation. A first step to setting up a Canary Network is connecting asset data sources to the simulation. Individual users can apply to participate in Canary Networks through a registry , where the exchange operator grants or denies access. Users can be invited to register through an invitation tool, and can see a list of Canary Networks to which they have been invited. Aggregators can apply through the registry to manage (i.e. run trading algorithms on behalf of) assets through the Asset API Assets can be configured to read live or uploaded data that has been sent through a live data API . The details of setting up live asset data through the API can be found here. Template scripts are available for aggregators or advanced users to trade energy through the Asset trading API. The scripts, documentation and additional information can be found here. Grid operators can also run scripts that set and change grid fees for the exchange. Both template scripts include readable text outputs from the trading or grid fee strategy Canary network results are viewable real-time, with data and trading results populated in 15 minute intervals. Results for previous weeks are available by selecting the week at the top of results. Users can view and duplicate public simulations on the map, allowing experimentation and rapid prototyping. Grid Singularity v1.5 Tutorial Version 1.4 \u00b6 The following features were implemented: A map legend has been added to clarify how colors on the map represent the exporting or importing of energy Users can add a profile picture to personalize their account by clicking on their name Custom assets can be added to a home with configurable production / consumption quantity or storage capacity through the advanced menu. Custom PVs can be added which use the energydatamap.com API, allowing a production forecast to be used for the simulation\u2019s geographical location. Advanced custom PV settings allow users to set the orientation of the PV (e.g. flat, tilted, facade) and azimuth and tilt. A list view navigation shows all assets in a home and community. Clicking on an asset allows further configuration. Key results have been simplified for easier reference, including community self-sufficiency and self-consumption with information about what the metrics mean. A Savings KPI has been introduced for each home in the community, showing if and how much a home has been saving compared to buying from the local utility. The total bill including amount owed or earned is shown, along with a graph of the daily savings. Asset result highlights the total amount spent or earnt by each asset, including an average price per kWh of energy. Batteries also show their current state of charge and average buying and selling price. Grid Singularity v1.4 Tutorial Version 1.0.0 \u00b6 The following features were implemented : Our new user interface (UI), found at Grid Singularity map will replace the old one at d3a.io . This new UI is intended to make creating and running simulations much easier for users who might be new to thinking about their energy use and simulating their own energy community. Additional features in the map include a search bar , which facilitates searching for an address or town on the map. After running the simulation, highlighted results displayed directly above each home and community in the map. There are standard (template) homes and profiles that can be used by users who do not have information about actual energy consumption and/or production, generated from loadprofilegenerator.de and energydatamap.com . We provide additional information on the Canary Test Network for live data simulations, which is the next step in building an energy community Animated color visuals in the map view assist analysis, with a color assigned to each home and community on the map when the simulation is running: green for net exports, blue for neutral, and red for net imports We also provide Map 3D view, where users can view their simulations and homes in 3-Dimensions Side navigation bar summarizes the contents of a users\u2019 energy community to additionally aid optimal energy community configuration Smart meter asset, a new asset type which can be configured directly in the codebase simulation file to allow users to upload smart meter net consumption and production profiles Version 0.12.0 \u00b6 The following features were implemented : Market slot length realtime: This can be set to simulations and collaborations. It slows down the running pace with a constant value (speed can go from the fasted as possible up until real-time. Public library is updated: New loads and PVs profiles were added to the public library. A total of 24 loads, representing various types of households was generated using loadprofilegenerator.de . PV production profiles were taken from energydatamap.com for different cities. These new loads and PVs have profiles of a full year (2021). Users can now download the registry page as a JSON file, to facilitate the connection with the API to a collaboration/Canary Network. Version 0.11.0 \u00b6 The following features were implemented : Time Resolution setting for graphs: Users can choose to view data in the graphs in 2 hour, 1 hour, or 15 minutes time resolution. This allows for faster loading of the graphs as the simulation run time is extended. Users can change the time resolution for the Energy Trade Profile, Energy Pricing, and Asset Profile graphs. Add a Library as an Event : Users can add grid components from the Library into their simulation while it is running. Canary Network Enhancements: Canary Networks are automatically restarted in the event of a software deploy or other system disruption. Users can view previous weeks of Canary Network data and download the results . Canary Network simulations can run for weeks at a time and store all data for future analysis and research. Users can trade through the Grid Singularity Asset and Grid Operator APIs through a cloud web service. This feature allows users to automate their trading algorithms and connect to the API from the cloud instead of hosting and monitoring on a local computer. Version 0.10.0 \u00b6 The following features were implemented : Canary Networks : An admin user can create a Canary Network simulation, which duplicates a collaboration simulation and allows the admin to connect each energy asset in the grid to its live data stream in order to simulate trading on the asset's live metered data readings. The Canary Network runs in real-time , with incoming data collected during each 15 minute market slot. Researcher users can trade on behalf of energy assets using the registry to connect to the live data stream which broadcasts the energy required for each asset through the Asset API . Grid Operator users can change the grid fees and grid parameters of each grid market using the registry which connects them to their markets through the Grid Operator API . Therefore, the Canary Network realizes the digital twin model of an energy asset and enables Researcher users to trade in real-time on behalf of their assets as a proof of concept. Once a Canary Network is established, it continues to run and agents can trade over weeks and months of time, for long term study of energy asset data and agent and market behavior. Previous weeks of data and results are saved in the results page weekly history. Island or Grid-connect a Market Maker as an event: Users can now change the role and mode of the Market Maker as an event, allowing users to simulate blackouts by changing the Market Maker to an islanding role, or simulating other impacts resulting from a change in the Market Maker parameters, such as showing the effect of connecting an islanded Market Maker to the grid. Version 0.9.0 \u00b6 The following features were implemented : Market API , which allows grid operators and researchers to monitor metrics and set grid fees in the select local energy market simulation collaboration Easier registration for researchers and grid operators to manage multiple assets and use market API through the Registry page. Bids and offers are prioritised in their first market by setting a wait time of 2 ticks before allowing them to propagate to higher markets in the grid hierarchy. This wait time is set in the backend as the minimum bid or offer age parameter. Grid fees integrated in the Results page - Energy Pricing graph for each market Total grid fees reported in the Scoreboard page that demonstrates market performance metrics for each collaboration simulation. Net Energy calculation added to Results page - Energy Trade Profile graph in order to calculate the peak energy at a market node in the simulation. The current peak imports and exports were previously calculated based on the cumulative trades, but are now calculated from the net energy consumption, which can be a net import or export. Updated load final selling rate and PV initial buying rate in the template strategies now take the total grid fees into account in addition to the market maker (usually utility) rate. Users can now run three simulations and/or collaborations at once (previous limit was two) Version 0.8.0 \u00b6 The following features were implemented : Simulation Location Map. Users can geo-tag all energy resources and markets in their simulation to make a map view of the simulation and results. A summary of all simulations can be viewed in a global map, to see where Grid Singularity is running simulations all over the world! Version 0.7.0 \u00b6 The following features were implemented : Detailed energy trade profile graph . Zoom in to each 15 minute market slot to view the scheduled trades with 1 minute resolution. Grid Operator user can change grid parameters inside a collaboration and while it is running, like grid fees or the transformer capacity. Allow collaboration participants to register for events while the simulation is running. Allows users to simulate a growing community. Information Aggregator to compile and send average market measurements to assist data scientists in building smart strategies to trade through the API . Version 0.6.0 \u00b6 The following features were implemented : Bid and Offer matching graph Analyze all bids, offers, and trades in a market and see why they match based on their strategies. Simulation events Add, delete, or update areas or energy resources in a simulation while it is running. This allows users to grow their simulations in real-time and analyze the impacts of energy resources coming online and changes to grid parameters such as grid fees. Timeline to view events and zoom in View all events in a timeline and click on each event to view its relevant grid configuration and results. Zoom in to view results for a specific day. Pause or stop a simulation Pause a simulation to freeze it while adding an event. Stop a simulation pre-maturely in order to run another version sooner. Configure an infinite bus as part of the Market Maker Configure an Infinite Bus in order to add a feed-in-tariff to the simulation. Version 0.5.0 \u00b6 The following features were implemented : Constant based Grid Fees Self Sufficiency, Self Consumption , and Energy Peak Percentage KPIs Simulation runtime status indicator Increased node limit to 1000 nodes Collaborations Scoreboard Select visible charts on Results page Colors for Energy Bills Bought and Sold Version 0.4.0 \u00b6 The following features were implemented : Grid fees configuration User roles, including 'Collaborations' feature for multi user testing and Grid Singularity-hosted challenges API connection to energy assets allowing bids and offers to be submitted by external algorithms Version 0.3.0 \u00b6 The following features were implemented : Run simulations with up to 250 nodes Compare results of two simulations side by side New navigation side bar with Home, Projects, and Library easily accessible Version 0.2.0 \u00b6 The following features were implemented : Run simulations for one week Choose your market type: additional access to two-sided pay as bid and two-sided pay as clear market types New user friendly asset strategies Configure your market maker Scrollable graphs on the results page optimized for longer simulations Download simulation results","title":"Releases Archive"},{"location":"releases/#version-15","text":"The following features were implemented: An updated energy bills table shows the amount of energy communities or homes are buying and selling in the market Simulation results can be filtered by week to view the results for individual weeks Users can request a Grid Singularity Canary Test Network , a real-time test network version of a local energy market that uses real asset data when available. Requesting a Canary Network will give information about the process and requirements to set up a local energy community in your region, within regulation. A first step to setting up a Canary Network is connecting asset data sources to the simulation. Individual users can apply to participate in Canary Networks through a registry , where the exchange operator grants or denies access. Users can be invited to register through an invitation tool, and can see a list of Canary Networks to which they have been invited. Aggregators can apply through the registry to manage (i.e. run trading algorithms on behalf of) assets through the Asset API Assets can be configured to read live or uploaded data that has been sent through a live data API . The details of setting up live asset data through the API can be found here. Template scripts are available for aggregators or advanced users to trade energy through the Asset trading API. The scripts, documentation and additional information can be found here. Grid operators can also run scripts that set and change grid fees for the exchange. Both template scripts include readable text outputs from the trading or grid fee strategy Canary network results are viewable real-time, with data and trading results populated in 15 minute intervals. Results for previous weeks are available by selecting the week at the top of results. Users can view and duplicate public simulations on the map, allowing experimentation and rapid prototyping. Grid Singularity v1.5 Tutorial","title":"Version 1.5"},{"location":"releases/#version-14","text":"The following features were implemented: A map legend has been added to clarify how colors on the map represent the exporting or importing of energy Users can add a profile picture to personalize their account by clicking on their name Custom assets can be added to a home with configurable production / consumption quantity or storage capacity through the advanced menu. Custom PVs can be added which use the energydatamap.com API, allowing a production forecast to be used for the simulation\u2019s geographical location. Advanced custom PV settings allow users to set the orientation of the PV (e.g. flat, tilted, facade) and azimuth and tilt. A list view navigation shows all assets in a home and community. Clicking on an asset allows further configuration. Key results have been simplified for easier reference, including community self-sufficiency and self-consumption with information about what the metrics mean. A Savings KPI has been introduced for each home in the community, showing if and how much a home has been saving compared to buying from the local utility. The total bill including amount owed or earned is shown, along with a graph of the daily savings. Asset result highlights the total amount spent or earnt by each asset, including an average price per kWh of energy. Batteries also show their current state of charge and average buying and selling price. Grid Singularity v1.4 Tutorial","title":"Version 1.4"},{"location":"releases/#version-100","text":"The following features were implemented : Our new user interface (UI), found at Grid Singularity map will replace the old one at d3a.io . This new UI is intended to make creating and running simulations much easier for users who might be new to thinking about their energy use and simulating their own energy community. Additional features in the map include a search bar , which facilitates searching for an address or town on the map. After running the simulation, highlighted results displayed directly above each home and community in the map. There are standard (template) homes and profiles that can be used by users who do not have information about actual energy consumption and/or production, generated from loadprofilegenerator.de and energydatamap.com . We provide additional information on the Canary Test Network for live data simulations, which is the next step in building an energy community Animated color visuals in the map view assist analysis, with a color assigned to each home and community on the map when the simulation is running: green for net exports, blue for neutral, and red for net imports We also provide Map 3D view, where users can view their simulations and homes in 3-Dimensions Side navigation bar summarizes the contents of a users\u2019 energy community to additionally aid optimal energy community configuration Smart meter asset, a new asset type which can be configured directly in the codebase simulation file to allow users to upload smart meter net consumption and production profiles","title":"Version 1.0.0"},{"location":"releases/#version-0120","text":"The following features were implemented : Market slot length realtime: This can be set to simulations and collaborations. It slows down the running pace with a constant value (speed can go from the fasted as possible up until real-time. Public library is updated: New loads and PVs profiles were added to the public library. A total of 24 loads, representing various types of households was generated using loadprofilegenerator.de . PV production profiles were taken from energydatamap.com for different cities. These new loads and PVs have profiles of a full year (2021). Users can now download the registry page as a JSON file, to facilitate the connection with the API to a collaboration/Canary Network.","title":"Version 0.12.0"},{"location":"releases/#version-0110","text":"The following features were implemented : Time Resolution setting for graphs: Users can choose to view data in the graphs in 2 hour, 1 hour, or 15 minutes time resolution. This allows for faster loading of the graphs as the simulation run time is extended. Users can change the time resolution for the Energy Trade Profile, Energy Pricing, and Asset Profile graphs. Add a Library as an Event : Users can add grid components from the Library into their simulation while it is running. Canary Network Enhancements: Canary Networks are automatically restarted in the event of a software deploy or other system disruption. Users can view previous weeks of Canary Network data and download the results . Canary Network simulations can run for weeks at a time and store all data for future analysis and research. Users can trade through the Grid Singularity Asset and Grid Operator APIs through a cloud web service. This feature allows users to automate their trading algorithms and connect to the API from the cloud instead of hosting and monitoring on a local computer.","title":"Version 0.11.0"},{"location":"releases/#version-0100","text":"The following features were implemented : Canary Networks : An admin user can create a Canary Network simulation, which duplicates a collaboration simulation and allows the admin to connect each energy asset in the grid to its live data stream in order to simulate trading on the asset's live metered data readings. The Canary Network runs in real-time , with incoming data collected during each 15 minute market slot. Researcher users can trade on behalf of energy assets using the registry to connect to the live data stream which broadcasts the energy required for each asset through the Asset API . Grid Operator users can change the grid fees and grid parameters of each grid market using the registry which connects them to their markets through the Grid Operator API . Therefore, the Canary Network realizes the digital twin model of an energy asset and enables Researcher users to trade in real-time on behalf of their assets as a proof of concept. Once a Canary Network is established, it continues to run and agents can trade over weeks and months of time, for long term study of energy asset data and agent and market behavior. Previous weeks of data and results are saved in the results page weekly history. Island or Grid-connect a Market Maker as an event: Users can now change the role and mode of the Market Maker as an event, allowing users to simulate blackouts by changing the Market Maker to an islanding role, or simulating other impacts resulting from a change in the Market Maker parameters, such as showing the effect of connecting an islanded Market Maker to the grid.","title":"Version 0.10.0"},{"location":"releases/#version-090","text":"The following features were implemented : Market API , which allows grid operators and researchers to monitor metrics and set grid fees in the select local energy market simulation collaboration Easier registration for researchers and grid operators to manage multiple assets and use market API through the Registry page. Bids and offers are prioritised in their first market by setting a wait time of 2 ticks before allowing them to propagate to higher markets in the grid hierarchy. This wait time is set in the backend as the minimum bid or offer age parameter. Grid fees integrated in the Results page - Energy Pricing graph for each market Total grid fees reported in the Scoreboard page that demonstrates market performance metrics for each collaboration simulation. Net Energy calculation added to Results page - Energy Trade Profile graph in order to calculate the peak energy at a market node in the simulation. The current peak imports and exports were previously calculated based on the cumulative trades, but are now calculated from the net energy consumption, which can be a net import or export. Updated load final selling rate and PV initial buying rate in the template strategies now take the total grid fees into account in addition to the market maker (usually utility) rate. Users can now run three simulations and/or collaborations at once (previous limit was two)","title":"Version 0.9.0"},{"location":"releases/#version-080","text":"The following features were implemented : Simulation Location Map. Users can geo-tag all energy resources and markets in their simulation to make a map view of the simulation and results. A summary of all simulations can be viewed in a global map, to see where Grid Singularity is running simulations all over the world!","title":"Version 0.8.0"},{"location":"releases/#version-070","text":"The following features were implemented : Detailed energy trade profile graph . Zoom in to each 15 minute market slot to view the scheduled trades with 1 minute resolution. Grid Operator user can change grid parameters inside a collaboration and while it is running, like grid fees or the transformer capacity. Allow collaboration participants to register for events while the simulation is running. Allows users to simulate a growing community. Information Aggregator to compile and send average market measurements to assist data scientists in building smart strategies to trade through the API .","title":"Version 0.7.0"},{"location":"releases/#version-060","text":"The following features were implemented : Bid and Offer matching graph Analyze all bids, offers, and trades in a market and see why they match based on their strategies. Simulation events Add, delete, or update areas or energy resources in a simulation while it is running. This allows users to grow their simulations in real-time and analyze the impacts of energy resources coming online and changes to grid parameters such as grid fees. Timeline to view events and zoom in View all events in a timeline and click on each event to view its relevant grid configuration and results. Zoom in to view results for a specific day. Pause or stop a simulation Pause a simulation to freeze it while adding an event. Stop a simulation pre-maturely in order to run another version sooner. Configure an infinite bus as part of the Market Maker Configure an Infinite Bus in order to add a feed-in-tariff to the simulation.","title":"Version 0.6.0"},{"location":"releases/#version-050","text":"The following features were implemented : Constant based Grid Fees Self Sufficiency, Self Consumption , and Energy Peak Percentage KPIs Simulation runtime status indicator Increased node limit to 1000 nodes Collaborations Scoreboard Select visible charts on Results page Colors for Energy Bills Bought and Sold","title":"Version 0.5.0"},{"location":"releases/#version-040","text":"The following features were implemented : Grid fees configuration User roles, including 'Collaborations' feature for multi user testing and Grid Singularity-hosted challenges API connection to energy assets allowing bids and offers to be submitted by external algorithms","title":"Version 0.4.0"},{"location":"releases/#version-030","text":"The following features were implemented : Run simulations with up to 250 nodes Compare results of two simulations side by side New navigation side bar with Home, Projects, and Library easily accessible","title":"Version 0.3.0"},{"location":"releases/#version-020","text":"The following features were implemented : Run simulations for one week Choose your market type: additional access to two-sided pay as bid and two-sided pay as clear market types New user friendly asset strategies Configure your market maker Scrollable graphs on the results page optimized for longer simulations Download simulation results","title":"Version 0.2.0"},{"location":"results-community/","text":"Key Results for the community are shown, detailing self-sufficiency and self-consumption. Figure 2.17 . Key results The next results show the total number of energy assets contained within the energy community, categorised according to asset type. Figure 2.18 . Community Assets list. The first graphic in bills and traded energy is the Savings KPI, showing how much money has been saved by trading in the local energy community vs. how much would have been paid buying solely from the local utility. Figure 2.19 . Savings KPI for a home with 2 assets Each asset also has a key results page, showing a summary of the amount of energy bought or sold and the price of energy. Figure 2.20 . Asset key results for a solar panel","title":"Results community"},{"location":"results-dashboard/","text":"The Results Dashboard illustrates the key performance indicators of a simulated local energy market (LEM or energy community). It updates while the simulation is running and the final outcomes are stored for up to 90 days or until the user decides to delete or to rerun the simulation. The following results (key performance indicators) are currently available for the LEM simulations in Grid Singularity\u2019s user interface Singularity Map: Net Energy Traded, Energy Cost (Bill) and Energy Cost Savings Self-Sufficiency and Self-Consumption Trade Profile and Energy Peak Percentage Aggregate Market Summary Price Graph Cumulative trades chart and bids and offers graph Results are generated for the simulated LEM (energy community), its participants (home/building) and all available energy assets. The results load automatically for the community as a whole, while member-specific results can be viewed by clicking on a select home. The home and asset results can also be retrieved by clicking on the list icon in the bottom right corner and then on the community asset icon that will appear, generating a list of all the homes and assets in that community (see picture below). Figure 3.1 : Position of button that shows a list of homes and assets in Grid Singularity\u2019s simulation interface (Singularity Map) The user can also download the results of the simulation for a deeper analysis of the community trading patterns by clicking on the download results icon under the settings tab, as shown in the picture below. For more information about this option, see Results Download . Figure 3.2 : Position of button for downloading results in Grid Singularity\u2019s simulation interface (Singularity Map)","title":"Results Dashboard (Key Performance Indicators)"},{"location":"results-download/","text":"After successfully running a simulation in Grid Singularity\u2019s User Interface, the user can download the results file for a deeper analysis by clicking on \u201cDownload\u201d button on the bottom-right corner of the settings tab as shown below: Figure 3.15 : Settings tab for Grid Singularity\u2019s simulation interface (Singularity Map) An email with a download link is sent to the user's inbox once the results have been compiled in the backend. When the user clicks on the link, they are redirected to the simulation where they click on the \u201cDownload\u201d button again to download the results, which are then saved locally on the user's computer. The downloaded folder is organised into two subfolders with relevant files, as follows: aggregated_results : area_throughput.json : Imported/exported energy for each market slot : Bills.json : Energy bills of all markets and energy assets (more details here ) Cumulative_bills.json : Total energy bills (spent & earned) Cumulative_grid_trades.json : Total energy traded for each market and energy asset and their penalty (for not trading their required energy) asset_statistics.json : asset profiles, energy traded, energy rates (min and max) for each asset each market slot Energy_trade_profile.json : Energy traded in each market Kpi.json : Self-consumption and self-sufficiency (in %), total energy demanded, generated and self-consumed Price_energy_day.json : Min, avg, max and grid fee rates for each market each market slot Progress_info.json : time remaining, simulation duration and percentage completed (if the simulation is complete eta_seconds should report 0 and percentage_completed should report 100) Random_seed.json : Random seed number used in the randomization process for specific events. This can mean the same simulation run multiple times may have slightly different results, as the posting order of bids and offers and matching trades can differ in certain situations (such as when two bids for the same price are randomly selected to be matched with one offer), causing some trades and bills to be different. Simulation_id.json : UUID of the simulation (can also be found in the simulation URL) Status.json : Status of the simulation Unmatched_loads.json : Number of unmatched load per markets reported each market slot bids_offers_trades : The folder structure follows the same logic as the simulation\u2019s grid hierarchy. There are three different csv files : *_bids.csv : Lists every bid posted on the relevant market including their volume, rate and buyer\u2019s name *_offers.csv : Lists every offer posted on the relevant market including their volume, rate and seller\u2019s name *_trades.csv : Lists each traded including their volume, rate, buyer\u2019s and seller\u2019s name","title":"Results Download"},{"location":"results/","text":"User Interface Results \u00b6 Grid Singularity\u2019s UI offers visual representations of simulation results. These are updated while the simulation is running and stored indefinitely until the user decides to delete or to rerun the simulation. The user is able to view Results for each area or asset in the grid configuration. Navigating the grid configuration in the UI \u00b6 As shown in the image above, the user can select a market or an energy asset from a drop down to view specific results for that market or an asset while on the Results page. In the figure above, the Community market is selected. The Results page then displays relevant plots and tables for the selected market or asset. There is also the possibility to select which charts / tables you want to view / hide, as shown in the image above. This section discusses the information available in each chart / table. Energy availability \u00b6 This plot shows whether each consuming energy asset (i.e. load) inside the selected market had access to the energy it needed for each market slot. On the x-axis, the time is given. If the participating asset agent was able to purchase the energy it required for that time slot, the block will be colored green . If not, it will be colored purple . The granularity of the plot is one hour , so if there was a trade interval within the hour in which the agent was not able to buy the demanded energy, the entire block will be colored purple. The user can hover the cursor over a purple block to view a list of the energy assets that were not able to buy energy in that time slot. Self-sufficiency and self-consumption \u00b6 These two pie charts display Self-Sufficiency and Self-Consumption level of the selected area. Please see this page for more information. When the user hovers the cursor over these plots, the following quantitative energy metrics are shown: Self-consumed energy [kWh] Total demanded energy [kWh] Total produced energy [kWh] Cumulative trading \u00b6 This plot shows the total cumulative trade volumes traded among market participants (agents representing assets or markets) in the selected market in the course of the simulation. Each market participant is displayed as a uniquely colored bar that represents the energy sold (shown as negative) or bought (shown as positive). In the example below, the energy sold by House 1 is colored purple, and the House 1 bar is positive, meaning that it bought some of the energy it produced for its own use (self-consumption). The rest of the energy it sold is shown as a thin purple layer appearing in the bars of the other market participants that acted as buyers. This color coding allows the user to visually track the energy trade flows in the selected market. External Trades represent the import/export from/to a higher level market by the Inter-area agent of the selected market, and hence the difference between energy traded amongst the selected market participants and the total accumulated trades. The external trades bar represents energy produced in this market, but sold to an outside market, as well as the energy bought from an external source and sold to a participant in this market. The energy bought externally is teal in this example and the bar is negative for external trades. The energy that was sold to other market participants is indicated by a positive teal colored bar. A negative external trades bar means that the participants within the select market purchased energy externally and a positive external trades bar means that participants sold energy to an external market. Energy bills and net energy \u00b6 In the Community market shown in the figure below, the participating agents are the inter-area agents of the houses that lie within that market. The energy bill table provides information on the cumulative trade volumes of all market participants and the costs associated with trades. For each market and energy asset, the energy bought and sold during the simulation is listed, along with a total net energy consumption. The Totals column can be considered as the net energy consumption and final bill for the listed agent, which may represent an energy asset or a market (e.g. a house). The Totals row represents the total of trades that are made by all participants inside the selected market. Energy trade profile \u00b6 The energy profile shows the supply and demand of trades made inside the selected market for each market slot of the simulation. The negative side of the y-axis represents the energy sold, and the positive y-axis shows the energy bought. The different colors represent the different market participants (energy assets and markets). As all buyers and sellers of each trade are accounted for in a select market, the supply and demand sides are exact mirrors of each other in terms of volume. If peak analysis is switched on, the internal trades are hidden and only the trades including external participants are displayed. This shows how much energy required the use of transmission lines outside of the selected market. On the peak analysis plot, two lines are shown: the current peak imports and the current peak exports , representing the maximum energy imported and exported for the selected market. Another feature of this graph is viewing the Net energy , shown below. When peak analysis is activated, only net external trades of each participant are displayed. The net displays the difference between the total import and export for each market slot, useful in understanding the impact to transmission capacity . Detailed energy trade profile \u00b6 This graph is a market slot level breakdown of the energy trade profile. With this graph, the user can select a specific market slot to see when each trade was cleared during that slot, with a resolution of 30 simulated seconds. The graph's length is the market slot length (15 minutes by default). The market slot can be selected with the drop down (days) and the slider (hours and minutes). Energy pricing \u00b6 In this plot, energy pricing is shown. Depending on market design and grid configuration, there could be different price settlements in the same market slot. In this case, a minimum , maximum , and average of the trade price is shown. If no trade occurred during a certain market interval, no lines are plotted. If grid fees are set in that market as a constant value, a fourth line is plotted to reflect its price. Bids, Offers, and Trades per Market Slot \u00b6 In this plot, each bid, offer and trade posted/cleared in the selected market is shown according to its posting/clearing times, allowing the user to analyse how specific offers/bids were or were not matched and validate or further investigate their trading strategy. The x-axis of this graph is the market slot length (15 minutes by default), and the y-axis shows the bid and offer price. Each market slot of the simulation can be selected and viewed with the drop down (days) and the slider (hours & minutes). Compare results \u00b6 The user has the possibility to compare the results of two separate simulations. The user can also duplicate the simulation setup, download results or delete the configuration by using the appropriate buttons shown below: Backend Results \u00b6 After running a simulation in the backend, the user can export simulation results. This functionality is enabled by default. If you want to disable the export of simulation results, use the --no-export flag for the simulation run. Another useful parameter is: --export-path , used to change the output path of the simulation results. The default path is $HOME/d3a-simulation/ . The simulation results include analytical information about the bids, offers and trades that took place in the course of the simulation. Information about energy characteristics of each asset and market are also included (eg. battery state of charge, energy traded/requested/deficit). A detailed description of these files is available on the data download page. In addition to text files, some graphs that display aggregated market information during the course of the simulation are also exposed. These can be found under the plot directory and are very similar to the ones available in the UI : unmatched_loads_*.html : Plots the volume of energy that loads have not been able to purchase (power outage) energy_profile_*.html : Similar plot to energy trade profile average_trade_price_*.html : Similar plot to energy pricing asset_profile_*.html : each energy asset within the simulation has its own plot showing its profile (consumption, generation, State of Charge), the actual energy traded and energy rates.","title":"Results"},{"location":"results/#user-interface-results","text":"Grid Singularity\u2019s UI offers visual representations of simulation results. These are updated while the simulation is running and stored indefinitely until the user decides to delete or to rerun the simulation. The user is able to view Results for each area or asset in the grid configuration.","title":"User Interface Results"},{"location":"results/#navigating-the-grid-configuration-in-the-ui","text":"As shown in the image above, the user can select a market or an energy asset from a drop down to view specific results for that market or an asset while on the Results page. In the figure above, the Community market is selected. The Results page then displays relevant plots and tables for the selected market or asset. There is also the possibility to select which charts / tables you want to view / hide, as shown in the image above. This section discusses the information available in each chart / table.","title":"Navigating the grid configuration in the UI"},{"location":"results/#energy-availability","text":"This plot shows whether each consuming energy asset (i.e. load) inside the selected market had access to the energy it needed for each market slot. On the x-axis, the time is given. If the participating asset agent was able to purchase the energy it required for that time slot, the block will be colored green . If not, it will be colored purple . The granularity of the plot is one hour , so if there was a trade interval within the hour in which the agent was not able to buy the demanded energy, the entire block will be colored purple. The user can hover the cursor over a purple block to view a list of the energy assets that were not able to buy energy in that time slot.","title":"Energy availability"},{"location":"results/#self-sufficiency-and-self-consumption","text":"These two pie charts display Self-Sufficiency and Self-Consumption level of the selected area. Please see this page for more information. When the user hovers the cursor over these plots, the following quantitative energy metrics are shown: Self-consumed energy [kWh] Total demanded energy [kWh] Total produced energy [kWh]","title":"Self-sufficiency and self-consumption"},{"location":"results/#cumulative-trading","text":"This plot shows the total cumulative trade volumes traded among market participants (agents representing assets or markets) in the selected market in the course of the simulation. Each market participant is displayed as a uniquely colored bar that represents the energy sold (shown as negative) or bought (shown as positive). In the example below, the energy sold by House 1 is colored purple, and the House 1 bar is positive, meaning that it bought some of the energy it produced for its own use (self-consumption). The rest of the energy it sold is shown as a thin purple layer appearing in the bars of the other market participants that acted as buyers. This color coding allows the user to visually track the energy trade flows in the selected market. External Trades represent the import/export from/to a higher level market by the Inter-area agent of the selected market, and hence the difference between energy traded amongst the selected market participants and the total accumulated trades. The external trades bar represents energy produced in this market, but sold to an outside market, as well as the energy bought from an external source and sold to a participant in this market. The energy bought externally is teal in this example and the bar is negative for external trades. The energy that was sold to other market participants is indicated by a positive teal colored bar. A negative external trades bar means that the participants within the select market purchased energy externally and a positive external trades bar means that participants sold energy to an external market.","title":"Cumulative trading"},{"location":"results/#energy-bills-and-net-energy","text":"In the Community market shown in the figure below, the participating agents are the inter-area agents of the houses that lie within that market. The energy bill table provides information on the cumulative trade volumes of all market participants and the costs associated with trades. For each market and energy asset, the energy bought and sold during the simulation is listed, along with a total net energy consumption. The Totals column can be considered as the net energy consumption and final bill for the listed agent, which may represent an energy asset or a market (e.g. a house). The Totals row represents the total of trades that are made by all participants inside the selected market.","title":"Energy bills and net energy"},{"location":"results/#energy-trade-profile","text":"The energy profile shows the supply and demand of trades made inside the selected market for each market slot of the simulation. The negative side of the y-axis represents the energy sold, and the positive y-axis shows the energy bought. The different colors represent the different market participants (energy assets and markets). As all buyers and sellers of each trade are accounted for in a select market, the supply and demand sides are exact mirrors of each other in terms of volume. If peak analysis is switched on, the internal trades are hidden and only the trades including external participants are displayed. This shows how much energy required the use of transmission lines outside of the selected market. On the peak analysis plot, two lines are shown: the current peak imports and the current peak exports , representing the maximum energy imported and exported for the selected market. Another feature of this graph is viewing the Net energy , shown below. When peak analysis is activated, only net external trades of each participant are displayed. The net displays the difference between the total import and export for each market slot, useful in understanding the impact to transmission capacity .","title":"Energy trade profile"},{"location":"results/#detailed-energy-trade-profile","text":"This graph is a market slot level breakdown of the energy trade profile. With this graph, the user can select a specific market slot to see when each trade was cleared during that slot, with a resolution of 30 simulated seconds. The graph's length is the market slot length (15 minutes by default). The market slot can be selected with the drop down (days) and the slider (hours and minutes).","title":"Detailed energy trade profile"},{"location":"results/#energy-pricing","text":"In this plot, energy pricing is shown. Depending on market design and grid configuration, there could be different price settlements in the same market slot. In this case, a minimum , maximum , and average of the trade price is shown. If no trade occurred during a certain market interval, no lines are plotted. If grid fees are set in that market as a constant value, a fourth line is plotted to reflect its price.","title":"Energy pricing"},{"location":"results/#bids-offers-and-trades-per-market-slot","text":"In this plot, each bid, offer and trade posted/cleared in the selected market is shown according to its posting/clearing times, allowing the user to analyse how specific offers/bids were or were not matched and validate or further investigate their trading strategy. The x-axis of this graph is the market slot length (15 minutes by default), and the y-axis shows the bid and offer price. Each market slot of the simulation can be selected and viewed with the drop down (days) and the slider (hours & minutes).","title":"Bids, Offers, and Trades per Market Slot"},{"location":"results/#compare-results","text":"The user has the possibility to compare the results of two separate simulations. The user can also duplicate the simulation setup, download results or delete the configuration by using the appropriate buttons shown below:","title":"Compare results"},{"location":"results/#backend-results","text":"After running a simulation in the backend, the user can export simulation results. This functionality is enabled by default. If you want to disable the export of simulation results, use the --no-export flag for the simulation run. Another useful parameter is: --export-path , used to change the output path of the simulation results. The default path is $HOME/d3a-simulation/ . The simulation results include analytical information about the bids, offers and trades that took place in the course of the simulation. Information about energy characteristics of each asset and market are also included (eg. battery state of charge, energy traded/requested/deficit). A detailed description of these files is available on the data download page. In addition to text files, some graphs that display aggregated market information during the course of the simulation are also exposed. These can be found under the plot directory and are very similar to the ones available in the UI : unmatched_loads_*.html : Plots the volume of energy that loads have not been able to purchase (power outage) energy_profile_*.html : Similar plot to energy trade profile average_trade_price_*.html : Similar plot to energy pricing asset_profile_*.html : each energy asset within the simulation has its own plot showing its profile (consumption, generation, State of Charge), the actual energy traded and energy rates.","title":"Backend Results"},{"location":"self-sufficiency-consumption/","text":"Self-sufficiency : % of energy needs covered by local generation Self-consumption : % of local energy generation consumed locally self_sufficiency(market) = self_consumed_energy / total_energy_demanded self_consumption(market) = self_consumed_energy / total_energy_produced The example provided in the figure below has the following grid architecture: total_house1_pv_production = 10kWh house1_pv \u2192 house1_load = 1kWh house1_pv \u2192 house1_storage = 5kWh house1_pv \u2192 house2_load = 4kWh house1_storage \u2192 house1_load = 2kWh house1_storage \u2192 house2_load = 3kWh house1_self_consumer_energy = ( house1_pv \u2192 house1_load ) + ( house1_pv \u2192 house1_storage \u2192 house1_load ) = 1 + 2 = 3kWh house1_total_energy_demanded (only includes the demanded energy from house1\u2019s load asset) = 3kWh In this example, self-sufficiency of the house 1 is self_sufficiency(house1) = house1_self_consumer_energy / house1_total_energy_demanded self_sufficiency(house1) = 3 / 3 = 1 \u2192 100% Self-consumption of the house 1 is self_consumption(house1) = house1_self_consumer_energy / house1_total_energy_produced self_consumption(house1) = 3 / 10 = 0.3 \u2192 30% In the Grid , the highest level of the hierarchy : self_sufficiency = 10 / 10 = 1 \u2192 100% self_consumption = 10 / 10 = 1 \u2192 100%","title":"Self sufficiency consumption"},{"location":"self-sufficiency-self-consumption/","text":"Self-sufficiency rate refers to the share (expressed in percentage terms) of a home\u2019s or community\u2019s energy demand produced (and self-consumed) locally calculated over a defined time frame (weekly or monthly). Self-sufficiency rate is calculated as follows: self_sufficiency(market) = self_consumed_energy / total_energy_demanded Self-consumption rate refers to the share of energy (expressed in percentage terms) that the home or the community consumes from its own production calculated over a defined time frame (weekly or monthly). Self-consumption rate is calculated as follows: self_consumption(market) = self_consumed_energy / total_energy_produced Figure 3.5 : Example of Self-Sufficiency and Self-Consumption Results in Grid Singularity\u2019s interface (Singularity Map) Here is an example of the self sufficiency and self consumption rate calculation: Figure 3.6 : Example setup showing an energy community consisting of two home markets with diverse assets total_house1_pv_production = 10kWh house1_pv \u2192 house1_load = 1kWh house1_pv \u2192 house1_storage = 5kWh house1_pv \u2192 house2_load = 4kWh house1_storage \u2192 house1_load = 2kWh house1_storage \u2192 house2_load = 3kWh house1_self_consumer_energy = ( house1_pv \u2192 house1_load ) + ( house1_pv \u2192 house1_storage \u2192 house1_load ) = 1 + 2 = 3kWh house1_total_energy_demanded (only includes the demanded energy from house1\u2019s load asset) = 3kWh In this example, self-sufficiency of the house 1 is self_sufficiency(house1) = house1_self_consumer_energy / house1_total_energy_demanded self_sufficiency(house1) = 3 / 3 = 1 \u2192 100% Self-consumption of the house 1 is self_consumption(house1) = house1_self_consumer_energy / house1_total_energy_produced self_consumption(house1) = 3 / 10 = 0.3 \u2192 30% In the Grid , the highest level of the hierarchy : self_sufficiency = 10 / 10 = 1 \u2192 100% self_consumption = 10 / 10 = 1 \u2192 100%","title":"Self-Sufficiency and Self-Consumption"},{"location":"send-data-exchange-sdk/","text":"To send live data streams through the Exchange SDK, please follow these steps: Install the SDK Client by following the steps described here . Since the client is written in Python, the data stream pipeline needs to be written in Python as well. Add the following command in the Grid Singularity Asset SDK Script to set the energy consumption and generation for Load and PV assets for the next market slot: asset_client.set_energy_forecast(<energy_forecast_Wh>) An example of how sending forecasts through the SDK Client could be added into the Asset API script can be found here .","title":"Send live data streams via the Exchange SDK"},{"location":"send-data-rest-api/","text":"To send asset data without using the SDK Client or to set up a data pipeline in another programming language than the SDK Client, the raw REST API can be used instead. An additional authentication step has to be performed first. Authentication with JSON Web Token \u00b6 Authentication is done via JSON Web Token (JWT). In order to retrieve the JWT, the following POST request has to be performed: POST https://gsyweb.gridsingularity.com/api-token-auth/ The body of the request needs to contain the following information (JSON string): {\"username\": \"<your_username>\", \"password\": \"<your_password>\"} The returned JWT needs to be sent via the Authorization HTTP header when sending the forecast data. For that the user needs to add the following key value pair to the header of every POST command: Authorization: JWT . Send energy forecast \u00b6 The POST to send the energy value is (please fill in and ): POST https://gsyweb.gridsingularity.com/external-connection/api/ <Canary Network_UUID>/<Asset UUID>/set_energy_forecast/ The body of the request needs to contain the following information (JSON string): {\"energy_Wh\": <energy_value_for_asset>} Once the connection with the Grid Singularity Canary Test Network is complete, we recommend to verify that the data are sent successfully to the Grid Singularity exchange, by comparing the data visualized on the Grid Singularity user interface with the data in your local database to identify incoherences or mistakes during the connection. Iterate this process until each asset is successfully connected to send the correct data. Warning: Ensure your Internet connection/server is stable and the script persists. Any connection issue/loss on your side will result in inaccurate data reporting and representation in the Grid Singularity Exchange.","title":"Send live data streams via the REST API"},{"location":"send-data-rest-api/#authentication-with-json-web-token","text":"Authentication is done via JSON Web Token (JWT). In order to retrieve the JWT, the following POST request has to be performed: POST https://gsyweb.gridsingularity.com/api-token-auth/ The body of the request needs to contain the following information (JSON string): {\"username\": \"<your_username>\", \"password\": \"<your_password>\"} The returned JWT needs to be sent via the Authorization HTTP header when sending the forecast data. For that the user needs to add the following key value pair to the header of every POST command: Authorization: JWT .","title":"Authentication with JSON Web Token"},{"location":"send-data-rest-api/#send-energy-forecast","text":"The POST to send the energy value is (please fill in and ): POST https://gsyweb.gridsingularity.com/external-connection/api/ <Canary Network_UUID>/<Asset UUID>/set_energy_forecast/ The body of the request needs to contain the following information (JSON string): {\"energy_Wh\": <energy_value_for_asset>} Once the connection with the Grid Singularity Canary Test Network is complete, we recommend to verify that the data are sent successfully to the Grid Singularity exchange, by comparing the data visualized on the Grid Singularity user interface with the data in your local database to identify incoherences or mistakes during the connection. Iterate this process until each asset is successfully connected to send the correct data. Warning: Ensure your Internet connection/server is stable and the script persists. Any connection issue/loss on your side will result in inaccurate data reporting and representation in the Grid Singularity Exchange.","title":"Send energy forecast"},{"location":"setting-configuration-parameters/","text":"The following parameters are part of Simulation Config and are initialised before updating any ConstSettings : sim_duration slot_length tick_length market_maker_rate* grid_fee_pct* grid_fee_const* In order to update some of these parameters (starred in list above), please use update_config_parameters method to update the general configuration parameters in the setup file: from gsy_framework.constants_limits import ConstSettings def get_setup(config): ConstSettings.MASettings.MARKET_TYPE = 2 config.update_config_parameters(grid_fee_pct=5, grid_fee_const=35, market_maker_rate=30) market = Market( 'Grid', [ Asset('General Load', strategy=LoadHoursStrategy(avg_power_W=200, hrs_per_day=4, hrs_of_day=list(range(12, 16)), final_buying_rate=35) ), Asset('PV', strategy=PVStrategy(4, 80) ), ], config=config ) return market","title":"Setting General Configuration Parameters"},{"location":"settlement-market-structure/","text":"Spot and futures trading requires predictions of energy use at both the asset and network level, which are often associated with high prediction errors. Thus, although a balancing mechanism should deal with the energy imbalances on the physical level, financial exchanges might still not be settled, causing a mismatch between physical energy delivery and market accounting. Some market approaches create orders and matches based on the last 15 minute slot\u2019s energy use (post-delivery, read by smart meters) to solve this problem. Others allow the grid operator to set prices or enforce penalties for any deviance. The Netherlands has implemented a final gate closure time one day after delivery, allowing ex-post trading for balance responsible parties to trade imbalances in real-time. Symbiotic Energy Markets concept allows similar post-delivery trading by all market participants. Deviations between energy physically produced/consumed and energy purchased in the spot or futures market can be traded post-delivery by submitting a time slot in the past as a requirement attached to a bid or offer, creating a settlement market (figure 3.8). Bids and offers can be matched with a matching algorithm. This allows local deviations to balance without penalty (e.g. a local solar panel that overproduces matches their deviation to a local load that over-consumed), with the remainder filled at a market rate (likely a premium) by individual assets, balancing groups, or grid operators that provided balancing services during delivery. A specific limit may be introduced to represent the time interval in which post-delivery trading can be conducted. Figure 4.8 : Energy deviations (difference between purchased and delivered energy) can be traded in the settlement market instead of paying a penalty to the grid operator, reducing inefficient accounting. Any remaining deviance can still be penalized by the grid operator.","title":"Settlement Market Structure"},{"location":"setup-configuration/","text":"Backend Simulation Configuration \u00b6 In the backend, the simulation process is slightly different compared to the user interface simulations. There is no need to login to set up a simulation. The user first needs to download the code from our Github Repository (Installation Instructions for Linux , Mac and Windows ). In the setup-file (in Python programming language), general and trading strategy settings can be defined. Examples can be found in the relevant Grid Singularity GitHub folder. This is the most basic skeleton for a setup-file: ```python from gsy_e.models.area import Market def get_setup(config): area = Market(\"Grid\", []) return Market The user can add more nested submarkets recursively by adding more instances of Market to the second parameter (list) of the Market class. To define the strategy of an asset, please use the Asset class and its strategy parameter. The following grid architecture is given: Grid Home 1 H1 General Load H1 Storage 1 H1 Storage 2 Home 2 H2 General Load Bold instances in the outline above are markets. For each of these markets, a market-agent is created in the background to execute offer/bid forwarding and matching. In the following, the corresponding setup-file is shown. ```python from gsy_e.models.area import Area from gsy_e.models.strategy.storage import StorageStrategy from gsy_e.models.strategy.load_hours import LoadHoursStrategy from gsy_e.models.strategy.pv import PVStrategy def get_setup(config): market = Market( 'Grid', [ Market( 'House 1', [ Asset('H1 General Load', strategy=LoadHoursStrategy(avg_power_W=200, hrs_per_day=6, hrs_of_day=list( range(12, 18)), final_buying_rate=35) ), Asset('H1 Storage1', strategy=StorageStrategy(initial_soc=50) ), Asset('H1 Storage2', strategy=StorageStrategy(initial_soc=50) ), ], grid_fee_pct=0, grid_fee_const=0, ), Market( 'House 2', [ Asset('H2 General Load', strategy=LoadHoursStrategy(avg_power_W=200, hrs_per_day=4, hrs_of_day=list( range(12, 16)), final_buying_rate=35) ), Asset('H2 PV', strategy=PVStrategy(panel_count=4, initial_selling_rate=30, final_selling_rate=5) ), ], grid_fee_pct=0, grid_fee_const=0, ), ], config=config ) return market Additionally, the user has the possibility to change the default general settings in two different ways: Setup file (best option) gsy-e-setting.json Setup file (best option): \u00b6 The user can overwrite the configuration settings by changing variables of the ConstSettings class in the setup-file. This class defines the default values for various parameters (general simulation settings, market settings and energy asset configuration). For instance, the user can define multiple configuration parameters in the get_setup function by overwriting the ConstSettings default values. For example, the following parameters can be set : Market_type (if equal to 1: One-Sided Pay-as-Offer , if equal to 2 : Two-Sided Pay-as-Bid , if equal to 3 : Two-Sided Pay-as-Clear ) Grid_fee_type (if equal to 1: Constant grid fee , if equal to 2 : Percentage grid fee ) Here is an example to setup a simulation with the Two-Sided Pay-as-Bid market type, constant grid fee and default min (0cts/kWh) and max to (35cts/kWh) energy rate for all loads : from gsy_framework.constants_limits import ConstSettings def get_setup(config): ConstSettings.MASettings.MARKET_TYPE = 2 ConstSettings.LoadSettings.MIN_ENERGY_RATE = 0 ConstSettings.LoadSettings.MAX_ENERGY_RATE = 35 ConstSettings.MASettings.GRID_FEE_TYPE = 1 gsy-e-settings.json \u00b6 These general settings can also be parsed via a settings file in JSON format, which contains all constants in the advanced_settings branch. An example can be found here: src/gsy-e/setup/gsy-e-settings.json. The settings JSON file can be parsed via the --settings-file keyword","title":"Setup Configuration"},{"location":"setup-configuration/#backend-simulation-configuration","text":"In the backend, the simulation process is slightly different compared to the user interface simulations. There is no need to login to set up a simulation. The user first needs to download the code from our Github Repository (Installation Instructions for Linux , Mac and Windows ). In the setup-file (in Python programming language), general and trading strategy settings can be defined. Examples can be found in the relevant Grid Singularity GitHub folder. This is the most basic skeleton for a setup-file: ```python from gsy_e.models.area import Market def get_setup(config): area = Market(\"Grid\", []) return Market The user can add more nested submarkets recursively by adding more instances of Market to the second parameter (list) of the Market class. To define the strategy of an asset, please use the Asset class and its strategy parameter. The following grid architecture is given: Grid Home 1 H1 General Load H1 Storage 1 H1 Storage 2 Home 2 H2 General Load Bold instances in the outline above are markets. For each of these markets, a market-agent is created in the background to execute offer/bid forwarding and matching. In the following, the corresponding setup-file is shown. ```python from gsy_e.models.area import Area from gsy_e.models.strategy.storage import StorageStrategy from gsy_e.models.strategy.load_hours import LoadHoursStrategy from gsy_e.models.strategy.pv import PVStrategy def get_setup(config): market = Market( 'Grid', [ Market( 'House 1', [ Asset('H1 General Load', strategy=LoadHoursStrategy(avg_power_W=200, hrs_per_day=6, hrs_of_day=list( range(12, 18)), final_buying_rate=35) ), Asset('H1 Storage1', strategy=StorageStrategy(initial_soc=50) ), Asset('H1 Storage2', strategy=StorageStrategy(initial_soc=50) ), ], grid_fee_pct=0, grid_fee_const=0, ), Market( 'House 2', [ Asset('H2 General Load', strategy=LoadHoursStrategy(avg_power_W=200, hrs_per_day=4, hrs_of_day=list( range(12, 16)), final_buying_rate=35) ), Asset('H2 PV', strategy=PVStrategy(panel_count=4, initial_selling_rate=30, final_selling_rate=5) ), ], grid_fee_pct=0, grid_fee_const=0, ), ], config=config ) return market Additionally, the user has the possibility to change the default general settings in two different ways: Setup file (best option) gsy-e-setting.json","title":"Backend Simulation Configuration"},{"location":"setup-configuration/#setup-file-best-option","text":"The user can overwrite the configuration settings by changing variables of the ConstSettings class in the setup-file. This class defines the default values for various parameters (general simulation settings, market settings and energy asset configuration). For instance, the user can define multiple configuration parameters in the get_setup function by overwriting the ConstSettings default values. For example, the following parameters can be set : Market_type (if equal to 1: One-Sided Pay-as-Offer , if equal to 2 : Two-Sided Pay-as-Bid , if equal to 3 : Two-Sided Pay-as-Clear ) Grid_fee_type (if equal to 1: Constant grid fee , if equal to 2 : Percentage grid fee ) Here is an example to setup a simulation with the Two-Sided Pay-as-Bid market type, constant grid fee and default min (0cts/kWh) and max to (35cts/kWh) energy rate for all loads : from gsy_framework.constants_limits import ConstSettings def get_setup(config): ConstSettings.MASettings.MARKET_TYPE = 2 ConstSettings.LoadSettings.MIN_ENERGY_RATE = 0 ConstSettings.LoadSettings.MAX_ENERGY_RATE = 35 ConstSettings.MASettings.GRID_FEE_TYPE = 1","title":"Setup file (best option):"},{"location":"setup-configuration/#gsy-e-settingsjson","text":"These general settings can also be parsed via a settings file in JSON format, which contains all constants in the advanced_settings branch. An example can be found here: src/gsy-e/setup/gsy-e-settings.json. The settings JSON file can be parsed via the --settings-file keyword","title":"gsy-e-settings.json"},{"location":"solar-panels/","text":"A photovoltaic (PV) module or a solar panel is an energy asset that converts solar irradiation into electricity. In the Grid Singularity Exchange, the PV digital twin has been preconfigured to include the DC to AC conversion and represent either a single module, an array of modules or an entire solar park (total capacity can be selected in the advanced PV settings). When modelling energy communities, PVs can be added to homes or, in the case of a shared resource, a community. PVs produce electricity to be self-consumed by the asset owners, sold to another member of the community, sold back to the grid, or stored in a battery for use at a later time, depending on what options are available to the owner in a select market. In the Grid Singularity Exchange user interface (Singularity Map), there are three options to model PV generation. The first option is the Custom PV tool, which allows users to quickly simulate PV generation at a specific location and orientation if an actual PV generation profile is not available. This tool uses the backend code of the Energy Data Map provided by rebase.energy . If an exact address-based generation is unavailable, a second option which uses the same tool can be used to upload the city-based synthetic PV profile for that city. The third and most accurate option is for users that have the actual PV data to upload it by using the \u2018upload profile\u2019 option in the custom PV advanced settings. Figure 2.9 : Express Mode PV Options in the Grid Singularity Exchange web-based interface (Singularity Map) PV Configuration Options \u00b6 Express Mode \u00b6 In the express PV configuration mode, the user is provided with a template (synthetic) PV model to include as an asset at a select location in the simulated local energy market by naming the asset and setting its location: Name: select a unique name for the PV; Location: the location selected by the user is automatically uploaded. Advanced Mode \u00b6 In the advanced PV configuration mode, there are settings referring to the Capacity and Profile of the PV and the Trading Strategy as shown in the figure below: Figure 2.10 : PV Advanced Configuration Options in the Grid Singularity Exchange web-based interface (Singularity Map) Capacity and Profile Capacity: set the total kW capacity of the PV system Solar profile: choose one of the following options: Local generation profile: default setting representing the PV production based on asset location, derived by connecting to the Energy Data Map API provided by rebase.energy (also termed Custom PV). City generation profile: synthetic average generation profile for the city, also generated using the Custom PV tool (alternative if address-based location PV generation unavailable) Upload own / custom generation profile in the form of a csv file . Trading Strategy Initial selling rate: set the initial (and consequently the maximum ) rate that the PV offers at the beginning of each market slot in cents/kWh by selecting the Market Maker rate or by entering your own custom rate as \u2018user input\u2019 Final selling rate: set the final rate that the PV offers at the end of each market slot in cents/kWh Rate decrease: enter a value for the explicit rate decrease increment update interval in cents/kWh Linear pricing: If activated, the rate decrease per amount of time (update interval) is calculated automatically in a way that the price decreases linearly over the market slot time. The rate is calculated starting at the Initial selling rate at the start of the market slot and ending at the Final selling rate at the end of the market slot, while updating the rate at each Update Interval: energy_rate_decrease_per_update = (initial_selling_rate - final_selling_rate) / max(int((slot_length / update_interval) -1), 1) ; note: you can derive the bidding behavior from a linear fitted curve of a selling rate ranging from initial_selling_rate to final_selling_rate within the bidding interval. Update interval: set the frequency at which the rate is updated Orientation: If the Local Generation Profile (Custom PV) is selected, the parameters describing the orientation of the solar panels can be set in the basic or advanced mode: Basic: select Flat, Tilted or Facade orientation Advanced: enter the tilt and the azimuth values in degrees Figure 2.11 : Selection of PV orientation in the Grid Singularity Exchange web-based interface (Singularity Map) The integration of the Energy Data Map API with the Grid Singularity Exchange Custom PV Tool feature was designed and developed in the scope of the EU-supported AI4Cities project .","title":"Solar Panels (PVs)"},{"location":"solar-panels/#pv-configuration-options","text":"","title":"PV Configuration Options"},{"location":"solar-panels/#express-mode","text":"In the express PV configuration mode, the user is provided with a template (synthetic) PV model to include as an asset at a select location in the simulated local energy market by naming the asset and setting its location: Name: select a unique name for the PV; Location: the location selected by the user is automatically uploaded.","title":"Express Mode"},{"location":"solar-panels/#advanced-mode","text":"In the advanced PV configuration mode, there are settings referring to the Capacity and Profile of the PV and the Trading Strategy as shown in the figure below: Figure 2.10 : PV Advanced Configuration Options in the Grid Singularity Exchange web-based interface (Singularity Map) Capacity and Profile Capacity: set the total kW capacity of the PV system Solar profile: choose one of the following options: Local generation profile: default setting representing the PV production based on asset location, derived by connecting to the Energy Data Map API provided by rebase.energy (also termed Custom PV). City generation profile: synthetic average generation profile for the city, also generated using the Custom PV tool (alternative if address-based location PV generation unavailable) Upload own / custom generation profile in the form of a csv file . Trading Strategy Initial selling rate: set the initial (and consequently the maximum ) rate that the PV offers at the beginning of each market slot in cents/kWh by selecting the Market Maker rate or by entering your own custom rate as \u2018user input\u2019 Final selling rate: set the final rate that the PV offers at the end of each market slot in cents/kWh Rate decrease: enter a value for the explicit rate decrease increment update interval in cents/kWh Linear pricing: If activated, the rate decrease per amount of time (update interval) is calculated automatically in a way that the price decreases linearly over the market slot time. The rate is calculated starting at the Initial selling rate at the start of the market slot and ending at the Final selling rate at the end of the market slot, while updating the rate at each Update Interval: energy_rate_decrease_per_update = (initial_selling_rate - final_selling_rate) / max(int((slot_length / update_interval) -1), 1) ; note: you can derive the bidding behavior from a linear fitted curve of a selling rate ranging from initial_selling_rate to final_selling_rate within the bidding interval. Update interval: set the frequency at which the rate is updated Orientation: If the Local Generation Profile (Custom PV) is selected, the parameters describing the orientation of the solar panels can be set in the basic or advanced mode: Basic: select Flat, Tilted or Facade orientation Advanced: enter the tilt and the azimuth values in degrees Figure 2.11 : Selection of PV orientation in the Grid Singularity Exchange web-based interface (Singularity Map) The integration of the Energy Data Map API with the Grid Singularity Exchange Custom PV Tool feature was designed and developed in the scope of the EU-supported AI4Cities project .","title":"Advanced Mode"},{"location":"spot-market-types/","text":"In a local energy market (LEM), bids and offers are matched according to the selected clearing mechanism. Studies show that different clearing mechanisms offer diverse benefits and limitations relating to market efficiency , fairness , and user choices . Grid Singularity\u2019s exchange (previously D3A), three spot market types are implemented: One-Sided Pay-as-Offer Market Two-Sided Pay-as-Bid Market Two-Sided Pay-as-Clear Market","title":"Spot Market Types"},{"location":"technical-approach/","text":"The Grid Singularity Exchange provides software tools, enabling prosumers and consumers organised in (or considering joining) energy communities (also known as energy cooperatives, community choice aggregations or microgrids in different regions of the world), with the support of local companies that facilitate data connectivity to smart metres and energy assets (often local suppliers), to simulate and implement peer-to-peer and community energy trading. While community operation requires real data integration, simulations may also be performed by using historical, forecast or synthetic data. Importantly, our open source and modular platform optimises the use of local resources and enables individuals with equitable access to energy trading, at par with large energy suppliers. Grid Singularity\u2019s web-based simulation tool is currently available to any user upon free registration. The user can simulate a local energy market ( energy community ) by configuring a \u201cdigital twin\u201d representation of physical grid and energy markets, with household and community assets, such as consumption assets , solar panels and batteries , and adding market information (utility price, tariffs and any other pricing information to account for grid cost and integrate external supply for trades that cannot be met locally, as well as the applicable market matching and clearing mechanism and asset trading strategies). The purpose of creating simulations is to mimic what an energy community might look like, assessing what assets (type and size) best suit the community needs and how activation in local trading affects individual and community energy cost and environmental impact. Existing community members can use it to assess any changes, such as potentially adding storage assets like a battery. The Grid Singularity simulation results can be analysed with the following key performance indicators: self-consumption, self-sufficiency, energy bill value and savings (more in development). Energy researchers can deploy more advanced simulation features both in the user interface (e.g. use custom PV tool to integrate solar profiles based on location and weather conditions) and by using the more versatile open-source, GPL v.3 backend code of the Grid Singularity Exchange. Furthermore, live testing of different local energy markets can be enabled by connecting a digital energy community (live data streams from real energy assets) to the Grid Singularity Test Network . The Grid Singularity Medium Channel features several studies that assess the financial and social benefits of local trading, and the impact of different energy assets and system actions like applying different grid tariff models . This wiki provides a detailed guide for prosumers and energy communities to set up a simulation , as well as additional guidelines for asset managers and grid operators . Accompanying video tutorials can be found here . Figure . Grid Aware Markets: Trading agents place bids and offers on behalf of assets via the Asset API. Agents trade based on user preferences such as energy source and preferred trading partner. Grid Operators implement dynamic grid tariffs in energy markets through the Grid Operator API. Grid Singularity facilitates an individual or energy asset-centred, bottom-up market design by connecting aggregators and grid operators, through an application interface ( Asset API and Grid Operator API , respectively). More specifically, aggregators connect distributed energy assets of a community (including households, businesses and other energy users), while grid operators account for grid costs and access local flexibility for advanced grid management. Connected energy assets are digitally represented by trading agents pursuing trading strategies currently based on price but with a capability to be based on more advanced user preferences, such as consuming only renewable energy or trading with a preferred partner, achieving diverse degrees of freedom . Assets are typically grouped inside homes based on the owner and trade in a community market. Multiple communities can be connected inside higher markets depending on the geographical reach of the peer-to-peer system and voltage architecture of the grid. Figure . Grid Singularity Exchange: data flows from energy assets over aggregators and trading agents via APIs for matching. Energy Web's open source toolkit can be integrated for decentralised asset registry and data access management functionality. Grid Singularity\u2019s technical approach includes a decentralised, Substrate-based blockchain implementation to advance scalability and security of the exchange (GSy DEX). The Energy Web Chain is the blockchain of choice for GSy DEX, anchored upon Polkadot\u2019s scaling solution. Grid Singularity, an energy technology startup, and the Rocky Mountain Institute, a nonprofit clean technology organisation, jointly founded the Energy Web Foundation (EWF) in January 2017 as a non-profit entrepreneurial foundation building web3 applications for the energy transition. Having significantly contributed to EWF development and the launch of the Energy Web Chain, Grid Singularity\u2019s role today in the Energy Web is supervisory and advisory via Foundation Council. Notably, we do not rely on a proof-of-work mechanism of validation and therefore do not overuse electricity . Our path to decentralisation and the implementation of Symbiotic Energy Markets is described in the following discussion paper . When the Grid Singularity Exchange is deployed as a distributed local energy exchange, the traditional role of the grid operator, which manages the connection to the power grid, and the utility, as a provider of energy, would still continue to be required to integrate the local energy market with the wider grid network. This ensures the reliability of supply in case of a deficit within a community but also export possibilities in case of a surplus. The primary difference is that a utility would no longer be the only market actor with which a household exchanges energy, but one of multiple. To use the Grid Singularity software to operate an energy community, customisation is required to apply local regulation and a partnership with a local company to enable data connectivity and manage billing and other non-trading operations. In the European Union (EU), this includes ensuring support from a distribution systems operator (DSO) to validate the number of participants and the volume of energy exchanged on the affected distribution grid. Notably, most regions today, including EU member states, allow only community trading with a preset, single community-level price rather than actual peer-to-peer trading. For this reason any operational implementation would be limited to the applicable local trading mechanism, reducing the options and thus also the benefits facilitated by the Grid Singularity software tools. Grid Singularity fosters interoperability and open-source development, collaborating with other market actors that provide grid management and asset aggregation services and supporting complementary services such as data and smart trading algorithm that further enhance the efficiency of local energy markets (LEM), optimising the use of local renewable resources and other individual and community benefits. Grid Singularity\u2019s Exchange is a highly innovative and effective grid modernisation solution. First, it empowers customer engagement and provides utmost degrees of freedom in energy markets enhancing individual and community choices (e.g., type of energy consumed or preferred trading partner), lowering barriers and creating incentives for all participants. Second, it creates a resilient market by ensuring equal access, transparent pricing, and trading at optimal market levels (i.e., between assets and buildings or facility and grid). Third, it incentivizes and facilitates the integration of clean distributed energy resources (DERs) onto the grid closer to load centers. Fourth, grid operators can use it to implement flexible grid tariffs to benefit from the local market flexibility to alleviate congestion. Fifth, the Grid Singularity API provides instantaneous granular data to the grid operator\u2013which historically has relied upon changes in detected load and alterations from the forecast\u2013enabling the operator to improve management, flexibility, and grid performance. Sixth, peer-to-peer trading is market-driven , not based upon predetermined pricing, which optimizes local consumption and thus the use of (cheaper) local renewables, increasing affordability, reducing reliance and overall/peak load on the grid, supporting efficient asset utilization, and reducing system losses. Seventh, it increases community self-sufficiency and energy savings , providing emergency power backup, and mitigating the need for new transmission infrastructure. Finally, the peer-to-peer trading system incentivizes private investment in electric system infrastructure by increasing revenue from renewable DERs and providing decision-making tools.","title":"Grid Singularity Technical Approach"},{"location":"trade-profile/","text":"The trade profile shows the energy traded in kilowatt hours (kWh) in the respective market (home market or community market) per 15-minute market slot over a defined time frame (weekly or monthly). The negative side of the y-axis shows the energy sold, and the positive y-axis the energy bought. Different colours represent different market participants (energy assets and homes). Users can view the trade profile of any of the individual homes or the overall local energy market in this chart, including the net energy flow, by clicking on the legend below the graph. As all trades between buyers and sellers are accounted for in a select market, the supply and demand sides which are represented by the negative and positive sides of the y-axis respectively are exact mirrors of each other in terms of volume of energy in kWh. Figure 3.7 : Trade profile chart example showing energy traded for all local energy market participants and the external energy supplier (the grid market) in the Grid Singularity\u2019s simulation interface (Singularity Map). The energy peak percentage calculation is a tool that compares the current energy peak to a baseline. It can be switched on/off by selecting the \ud83c\udd87 or \u2705 button at the bottom of the advanced community settings tab as shown in the figure below. Figure 3.8 : Enabling energy peak percentage metric in the advanced community settings tab in the Grid Singularity\u2019s simulation interface (Singularity Map) The energy peak imports/exports is the maximum value of the aggregate imports/exports of a respective asset or community calculated over a defined timeframe (weekly or monthly). The user is able to set a baseline peak energy import in kWh and a baseline peak energy export in kWh that they may have gotten from another simulation in order to calculate the energy peak percentage, which is a measure of how much the peak imports or exports have changed between a baseline defined in market settings and the simulation.The purpose of the energy peak percentage value is to assess the impact of applied grid fees or different energy storage strategies on the peak imports and exports of a market. Figure 3.9 : Configuring community\u2019s baseline peak imports and exports in the Grid Singularity\u2019s simulation interface (Singularity Map) On the energy peak analysis plot, two lines are shown: the current peak imports (at top) and the current peak exports (at bottom), representing the maximum energy imported and exported for the selected market. Once the simulation has finished running, the energy peak percentage calculation can be visualised or removed by clicking the \u2705 (on) or \ud83c\udd87 (off) button located in the top right corner of the chart as shown in the figure below: Figure 3.10 : Trade profile chart example without energy peak percentage visualisation in the Grid Singularity\u2019s simulation interface (Singularity Map) When activated, only the net external trades of each participant are displayed. The net energy displays the difference between the total import and export for each market slot, useful in understanding the impact to transmission capacity. Figure 3.11 : Trade profile chart example with energy peak percentage visualisation in the Grid Singularity\u2019s simulation interface (Singularity Map) The energy peak percentage value is available in backend and can be calculated manually as follows: Import_peak_percentage = (import_peak_energy_kWh / import_baseline_peak_energy_kWh) * 100 Export_peak_percentage = (export_peak_energy_kWh / export_baseline_peak_energy_kWh) * 100 If the energy peak percentage is below 100% , the peak was reduced vs. the baseline. The energy peak was increased if the energy peak percentage value was above 100% .","title":"Trade Profile and Energy Peak Percentage"},{"location":"trades/","text":"The cumulative trades chart on the left in the figure below shows the amount of energy which was traded between each of the homes (representing households and other energy community participants) and the external suppliers (grid market) in kWh. The trades can be filtered by cumulative or per market slot or by clicking to view an individual home in the chart. In the graph on the right, each bid, offer and trade posted/cleared in the selected market is shown according to its posting/clearing times, allowing the user to analyse how specific offers/bids were or were not matched and validate or further investigate their trading strategy. The x-axis of this graph is the market slot length (15 minutes by default), and the y-axis shows the bid and the offer price. Each market slot of the simulation can be selected and viewed with the drop down function (days) and the slider (hours & minutes). Figure 3.14 : Trades shown in cumulative form (left) and per market slot (right) in the Grid Singularity\u2019s simulation interface (Singularity Map)","title":"Cumulative trades chart and bids and offers graph"},{"location":"two-sided-pay-as-bid/","text":"In the Two-Sided Pay-as-Bid market, buyers are able to place bids in the market, alongside the offers placed by sellers. Each market collects and matches bids and offers issued by trading agents, and dispatches bids and offers to other markets via a MarketAgent, which is created and operated by each market (area). Its role is to forward offers and bids to the connected markets. The auction is continuous , meaning that once an offer or bid is posted, it can be matched right away, even before the end of the market slot. Bids and offers can also be annulled by the trading agent. The market constantly triggers the matching between bids and offers according to the matching algorithm as illustrated in the figure below. Figure 4.2 : Two-Sided Pay-as-Bid Market mechanism.","title":"Two-Sided Pay-as-Bid Market"},{"location":"two-sided-pay-as-clear/","text":"In the Two-Sided Pay-as-Clear market, buyers are able to place bids in the market alongside the offers placed by sellers. The market collects and matches bids and offers issued by trading agents, and dispatches bids and offers to other markets via the MarketAgent (MA). Bids and offers can also be annulled by the trading agent. Market Agents are created and operated by each market (area) to forward bids and offers to the connected markets . Currently, there is a merit-order-effect mechanism implemented for bid and offer matching where bids and offers are aggregated and cleared in a specified clearing interval. At the end of each interval, bids are arranged in a descending order, offers in an ascending order and the equilibrium quantity of energy and price is calculated. The clearing point (the quantity of energy that is accepted trade volume for a specific energy rate clearing price ) is determined by the point where the arranged bid curve for the buyers drops below the offer curve for the sellers. Figure 4.3 : Two-Sided Pay-as-Clear Market mechanism. The highest bids are matched with the lowest offers. The matching rate is the clearing price (cents/kWh). The remaining bids and offers (right of the clearing point in the plot above) are not cleared at this clearing point and remain in the market for later matching.","title":"Two-Sided Pay-as-Clear Market"},{"location":"ui-initialisation/","text":"To start using the Grid Singularity Energy Exchange ), you need to register your account by selecting a user email and password. You will then receive an email with a link to confirm your account. You can design your own project by clicking on \u201cnew project\u201d and then create a new simulation. The first step in setting up a simulation is to define the simulation general and market settings, described in more detail below. The next step is to design your grid. Once you arrive in the grid setup, the first thing that you will have to do is to define the market maker. Subsequently, you can start building the digital twin of your grid including submarkets and relevant energy assets that can all be individually configured. The setup is intended to represent the physical architecture of the real energy market (country, region, neighbourhood, house, etc.). After your grid setup is complete, you can run your simulation. When it is finished you can view multiple scrollable plots and tables on the Results page. For a step-by-step explanation on how to set up your simulation, please watch our tutorial . You can also contact us at contact@gridsingularity.com or on slack Slack Note: For smoother simulations and smaller queues, we have set some boundaries. First, the simulations are limited in their duration. You can currently set the duration from 1 to 7 days . Furthermore, the number of agents per simulation is limited. Each market and asset is represented by an agent and you can define up to 1000 agents . Please see instructions on Backend simulation configuration here .","title":"Ui initialisation"},{"location":"upload-file-formats/","text":"Files can be uploaded to generate custom energy supply or load profiles. The following file formats are supported: Comma Separated Values (.csv) \u00b6 The separation can be done by comma , or semicolon ; . Two time formats are supported, see below. Power set-points are given in Watts . The software handles any conversions to energy (in kWh). All entered csv data values need to be positive hh:mm \u00b6 Example: INTERVAL;POWER(W): 00:00;10 00:15;10 00:30;10 00:45;10 01:00;10 YYYY-MM-DDThh:mm \u00b6 Example: INTERVAL,POWER(W) 2019-01-01T00:00,10.0 2019-01-01T00:15,10.0 2019-01-01T00:30,10.0 2019-01-01T00:45,10.0 2019-01-01T01:00,10.0 Note: If you upload csv files with date information, the start-date of the simulation should be identical in the csv files and simulation settings .","title":"Upload file formats"},{"location":"upload-file-formats/#comma-separated-values-csv","text":"The separation can be done by comma , or semicolon ; . Two time formats are supported, see below. Power set-points are given in Watts . The software handles any conversions to energy (in kWh). All entered csv data values need to be positive","title":"Comma Separated Values (.csv)"},{"location":"upload-file-formats/#hhmm","text":"Example: INTERVAL;POWER(W): 00:00;10 00:15;10 00:30;10 00:45;10 01:00;10","title":"hh:mm"},{"location":"upload-file-formats/#yyyy-mm-ddthhmm","text":"Example: INTERVAL,POWER(W) 2019-01-01T00:00,10.0 2019-01-01T00:15,10.0 2019-01-01T00:30,10.0 2019-01-01T00:45,10.0 2019-01-01T01:00,10.0 Note: If you upload csv files with date information, the start-date of the simulation should be identical in the csv files and simulation settings .","title":"YYYY-MM-DDThh:mm"},{"location":"version-update/","text":"Grid Singularity Exchange Update \u00b6 Please start by opening a terminal and activating the 'gsy-e' virtual environment as described in the Installation Instructions. Then type: git pull origin/master fab sync If fab sync does not work on your machine, please try: pip install -e . Grid Singularity Exchange SDK Update \u00b6 Please start by opening a terminal and activating the Exchange SDK virtual environment as described in the API Installation Instructions. Then type: pip uninstall gsy-e-sdk Press y when prompted. Once the uninstall is complete, type: pip install git+https://github.com/gridsingularity/gsy-e-sdk.git","title":"Version Updates"},{"location":"version-update/#grid-singularity-exchange-update","text":"Please start by opening a terminal and activating the 'gsy-e' virtual environment as described in the Installation Instructions. Then type: git pull origin/master fab sync If fab sync does not work on your machine, please try: pip install -e .","title":"Grid Singularity Exchange Update"},{"location":"version-update/#grid-singularity-exchange-sdk-update","text":"Please start by opening a terminal and activating the Exchange SDK virtual environment as described in the API Installation Instructions. Then type: pip uninstall gsy-e-sdk Press y when prompted. Once the uninstall is complete, type: pip install git+https://github.com/gridsingularity/gsy-e-sdk.git","title":"Grid Singularity Exchange SDK Update"},{"location":"virtual-heat-pump/","text":"Virtual Heat Pump \u00b6 Virtual Heat Pump Model \u00b6 A Virtual Heat Pump (VHP) is akin to a digital twin representing the district heating system role in the electricity market, simulating how the demand for electricity that is satisfied by district heating could be satisfied if a heat pump were used instead. This allows for a comparison of the costs and benefits of the two alternatives, including an assessment on the impact on the grid stability by potentially adding heat pumps to the system. Finally, it facilitates the sizing optimization (the selection of the model, rating or other nameplate parameters) of the heat pump if there is a consideration to replace the district heating connection. The modelled trading strategy assumes that the district heating network connection would be replaced by a ground source heat pump, which includes a water tank storage (reference model illustrated in the figure below). Other parameters of the Virtual Heat Pump can be modified, and are described in detail in the Virtual Heat Pump Code Configuration . Figure 2.29 : Ground source virtual heat pump diagram The heat pump operation steps are the following: Heat from the water pipes in the ground (#1 in Figure 2.29) is transferred to the source side of the heat pump, via the heat exchanger (#2 in Figure 2.29) The heat pump condenser (#3 in Figure 2.29) converts the heat pump liquid medium to gas, thus increasing its temperature. The heat from the condenser side of the heat pump is transferred to the water tank storage via the second heat exchanger (#4 in Figure 2.29). The water tank storage (#5 in Figure 2.29) temperature is increased as a result of the heat produced by the heat pump condenser at step #3 in Figure 2.29. Heat from the water tank storage is used in order to provide the heat demand of the building (#6 in Figure 2.29). Unlike the heat pump model described above, district heating networks use water pipes that are directly connected to the building, and usually the supply temperature, return temperature and water flow are measured in order to facilitate customer billing. The virtual heat pump model can use these district heating measurements to calculate the heat demand of the building. The heat demand is then provided as an input for the VHP model to calculate the energy that needs to be consumed by the heat pump in order to provide the heat demand, taking into account the flexibility that the water tank storage provides. Virtual Heat Pump Model Equations \u00b6 The model of the virtual heat pump comprises a set of mathematical equations that each simulates a different component of a heat pump system. The system of linear equations is optimised, in order to define the state and operation of the simulated heat pump. The optimisation parameter of the proposed model is the target temperature of the storage. The system is allowed to monitor the current temperature of the storage, and try to achieve a target storage temperature that is bounded by the limitations of min / max temperature of the water tank. The output of the proposed model is the calculation of the electricity consumption of the heat pump \\(P_{el-hp}\\) , which can be used in order to participate in the energy market, at the same time incorporating the flexibility provided by the water tank storage. The electricity consumption, which is related to a supplied heat \\(Q_{hp_{out}}\\) and COP, is calculated based on the following equation: \\[Q_{hp_{out}} = P_{el-hp} * COP \\tag{1}\\] The electricity consumption of the heat pump is upper-bounded by the maximum power consumption of the heat pump \\(P_{el-hp} <= P_{el-hp-max}\\) . The assumption is that the losses from the heat exchanger between the heat pump and the storage are ignored, and heat supplied by the heat pump to the storage is roughly equivalent to the heat generated by the heat pump itself: \\(Q_{in} \\small \\cong Q_{hp_{out}}\\) resulting in \\[Q_{hp_{out}} = P_{el-hp} \\cdot COP = Q_{in} \\tag{2}\\] The \\(COP\\) at each time-slot will be calculated as \\[ COP= \\eta T_{condenser} / (T_{condenser} - T_{source}) \\tag{3}\\] Where: \\(\\eta\\) is the empirical calibration coefficient = 0.85 for water to water heat pumps \\(T_{source}\\) is the district heating supply temperature \\(T_{condenser}\\) is the condenser (or sink) temperature For the solution of the former equations the heat generated by the heat pump ( \\(Q_{hp_{out}}\\) ) is needed, and it needs to be associated with the water tank model. The underlying premise is that the input heat to the water tank should be equal to the heat that is extracted from the water tank to cover the heat demand of the building, plus the extra heat stored in the water tank. This relation is reflected by the following equation for the market slot \\(i\\) : \\[Q_{in, i} - Q_{out,i} - Q_{loss,i} = \\rho_i V_i C_p \\cdot \\frac{dT_i}{dt} \\tag{4}\\] Where: \\(Q_{in, i}\\) is the heat generated by the heat pump, in other words the added heat to the water tank storage \\(Q_{out,i}\\) is the heat demand of the building, in other words the heat extracted from the water tank storage \\(Q_{loss,i}\\) is the heat losses due to the water tank storage. For the time being it is ignored \\(\\rho_i\\) \u03c1i is the water density (constant, \\(1 kg/l\\) ) \\(V_i\\) is the water tank volume (in \\(l\\) ) \\(C_p\\) is the water specific heat capacity (constant, \\(4182 J/kg\u00b0C\\) ) \\(\\frac{dT_i}{dt}\\) is the temperature derivative (in \\(\u00b0C/sec\\) ) The temperature derivative is calculated using the temperature difference between the target temperature of the water tank storage ( \\(T_{storage-target}, in Celsius\\) , used as the optimization variable of the system, and provides the flexibility to the heat pump operation) and the current temperature of the water tank storage ( \\(T_{storage-current}\\) in Celcius), divided by the duration of the measurement duration ( \\(t_{measurement}\\) ), in seconds, has to be equal to the market slot duration): \\[\\frac{dT_i}{dt} = (T_{storage-target} - T_{storage-current}) / t_{measurement} \\tag{5}\\] The \\(Q_{out,i}\\) can be calculated using the following equation: \\[Q_{out,i} = \\dot{m}_{DH} C_p (T_{s,i} - T_{r,i}) \\tag{6}\\] Where \\(\\dot{m}_{DH}\\) is the district heating water flow (in \\(kg/sec\\) ) \\(C_p\\) is the water specific heat capacity (constant, \\(4182 J/kg\u00b0C\\) ) \\(T_{s,i}\\) and \\(T_{r,i}\\) are the district heating supply and return temperatures (in \\(\u00b0C\\) ) respectively. The \\(Q_{in,i}\\) can be calculated using the following equation: \\[Q_{in,i} = \\dot{m} C_p (T_{condenser} - T_{storagemean}) \\tag{7}\\] Where: \\(\\dot{m}\\) is the water flow to the tank (in \\(kg/sec\\) ) \\(C_p\\) is the water specific heat capacity (constant, \\(4182 J/kg\u00b0C\\) ) \\(T_{condenser}\\) is the HP condenser setpoint, to be defined by the optimizer each time step. \\(T_{condenser}\\) will be the maximum allowed and not set to a constant value. As an optimization variable input to the system, this value will be changing from the condenser temperature required for the water tank to reach its maximum temperature, to the condenser temperature required to maintain the current temperature, depending on the energy that the heat pump traded / consumed. \\(T_{storagemean}\\) is the volume-averaged water tank storage temperature at the start of the market slot (in \\(\u00b0C\\) ) The system of equations 4, 5, 6, 7 is calculating the value of the condenser temperature ( \\(T_{condenser}\\) ) by using the target storage temperature as the optimization parameter ( \\(T_{storage-target}\\) ). The calculated condenser temperature is then used by equation 3 in order to calculate the \\(COP\\) , which in turn is used in conjunction with \\(Q_{in,i}\\) in equation 2 in order to finally calculate \\(P_{el-hp}\\) .","title":"Virtual Heat Pump"},{"location":"virtual-heat-pump/#virtual-heat-pump","text":"","title":"Virtual Heat Pump"},{"location":"virtual-heat-pump/#virtual-heat-pump-model","text":"A Virtual Heat Pump (VHP) is akin to a digital twin representing the district heating system role in the electricity market, simulating how the demand for electricity that is satisfied by district heating could be satisfied if a heat pump were used instead. This allows for a comparison of the costs and benefits of the two alternatives, including an assessment on the impact on the grid stability by potentially adding heat pumps to the system. Finally, it facilitates the sizing optimization (the selection of the model, rating or other nameplate parameters) of the heat pump if there is a consideration to replace the district heating connection. The modelled trading strategy assumes that the district heating network connection would be replaced by a ground source heat pump, which includes a water tank storage (reference model illustrated in the figure below). Other parameters of the Virtual Heat Pump can be modified, and are described in detail in the Virtual Heat Pump Code Configuration . Figure 2.29 : Ground source virtual heat pump diagram The heat pump operation steps are the following: Heat from the water pipes in the ground (#1 in Figure 2.29) is transferred to the source side of the heat pump, via the heat exchanger (#2 in Figure 2.29) The heat pump condenser (#3 in Figure 2.29) converts the heat pump liquid medium to gas, thus increasing its temperature. The heat from the condenser side of the heat pump is transferred to the water tank storage via the second heat exchanger (#4 in Figure 2.29). The water tank storage (#5 in Figure 2.29) temperature is increased as a result of the heat produced by the heat pump condenser at step #3 in Figure 2.29. Heat from the water tank storage is used in order to provide the heat demand of the building (#6 in Figure 2.29). Unlike the heat pump model described above, district heating networks use water pipes that are directly connected to the building, and usually the supply temperature, return temperature and water flow are measured in order to facilitate customer billing. The virtual heat pump model can use these district heating measurements to calculate the heat demand of the building. The heat demand is then provided as an input for the VHP model to calculate the energy that needs to be consumed by the heat pump in order to provide the heat demand, taking into account the flexibility that the water tank storage provides.","title":"Virtual Heat Pump Model"},{"location":"virtual-heat-pump/#virtual-heat-pump-model-equations","text":"The model of the virtual heat pump comprises a set of mathematical equations that each simulates a different component of a heat pump system. The system of linear equations is optimised, in order to define the state and operation of the simulated heat pump. The optimisation parameter of the proposed model is the target temperature of the storage. The system is allowed to monitor the current temperature of the storage, and try to achieve a target storage temperature that is bounded by the limitations of min / max temperature of the water tank. The output of the proposed model is the calculation of the electricity consumption of the heat pump \\(P_{el-hp}\\) , which can be used in order to participate in the energy market, at the same time incorporating the flexibility provided by the water tank storage. The electricity consumption, which is related to a supplied heat \\(Q_{hp_{out}}\\) and COP, is calculated based on the following equation: \\[Q_{hp_{out}} = P_{el-hp} * COP \\tag{1}\\] The electricity consumption of the heat pump is upper-bounded by the maximum power consumption of the heat pump \\(P_{el-hp} <= P_{el-hp-max}\\) . The assumption is that the losses from the heat exchanger between the heat pump and the storage are ignored, and heat supplied by the heat pump to the storage is roughly equivalent to the heat generated by the heat pump itself: \\(Q_{in} \\small \\cong Q_{hp_{out}}\\) resulting in \\[Q_{hp_{out}} = P_{el-hp} \\cdot COP = Q_{in} \\tag{2}\\] The \\(COP\\) at each time-slot will be calculated as \\[ COP= \\eta T_{condenser} / (T_{condenser} - T_{source}) \\tag{3}\\] Where: \\(\\eta\\) is the empirical calibration coefficient = 0.85 for water to water heat pumps \\(T_{source}\\) is the district heating supply temperature \\(T_{condenser}\\) is the condenser (or sink) temperature For the solution of the former equations the heat generated by the heat pump ( \\(Q_{hp_{out}}\\) ) is needed, and it needs to be associated with the water tank model. The underlying premise is that the input heat to the water tank should be equal to the heat that is extracted from the water tank to cover the heat demand of the building, plus the extra heat stored in the water tank. This relation is reflected by the following equation for the market slot \\(i\\) : \\[Q_{in, i} - Q_{out,i} - Q_{loss,i} = \\rho_i V_i C_p \\cdot \\frac{dT_i}{dt} \\tag{4}\\] Where: \\(Q_{in, i}\\) is the heat generated by the heat pump, in other words the added heat to the water tank storage \\(Q_{out,i}\\) is the heat demand of the building, in other words the heat extracted from the water tank storage \\(Q_{loss,i}\\) is the heat losses due to the water tank storage. For the time being it is ignored \\(\\rho_i\\) \u03c1i is the water density (constant, \\(1 kg/l\\) ) \\(V_i\\) is the water tank volume (in \\(l\\) ) \\(C_p\\) is the water specific heat capacity (constant, \\(4182 J/kg\u00b0C\\) ) \\(\\frac{dT_i}{dt}\\) is the temperature derivative (in \\(\u00b0C/sec\\) ) The temperature derivative is calculated using the temperature difference between the target temperature of the water tank storage ( \\(T_{storage-target}, in Celsius\\) , used as the optimization variable of the system, and provides the flexibility to the heat pump operation) and the current temperature of the water tank storage ( \\(T_{storage-current}\\) in Celcius), divided by the duration of the measurement duration ( \\(t_{measurement}\\) ), in seconds, has to be equal to the market slot duration): \\[\\frac{dT_i}{dt} = (T_{storage-target} - T_{storage-current}) / t_{measurement} \\tag{5}\\] The \\(Q_{out,i}\\) can be calculated using the following equation: \\[Q_{out,i} = \\dot{m}_{DH} C_p (T_{s,i} - T_{r,i}) \\tag{6}\\] Where \\(\\dot{m}_{DH}\\) is the district heating water flow (in \\(kg/sec\\) ) \\(C_p\\) is the water specific heat capacity (constant, \\(4182 J/kg\u00b0C\\) ) \\(T_{s,i}\\) and \\(T_{r,i}\\) are the district heating supply and return temperatures (in \\(\u00b0C\\) ) respectively. The \\(Q_{in,i}\\) can be calculated using the following equation: \\[Q_{in,i} = \\dot{m} C_p (T_{condenser} - T_{storagemean}) \\tag{7}\\] Where: \\(\\dot{m}\\) is the water flow to the tank (in \\(kg/sec\\) ) \\(C_p\\) is the water specific heat capacity (constant, \\(4182 J/kg\u00b0C\\) ) \\(T_{condenser}\\) is the HP condenser setpoint, to be defined by the optimizer each time step. \\(T_{condenser}\\) will be the maximum allowed and not set to a constant value. As an optimization variable input to the system, this value will be changing from the condenser temperature required for the water tank to reach its maximum temperature, to the condenser temperature required to maintain the current temperature, depending on the energy that the heat pump traded / consumed. \\(T_{storagemean}\\) is the volume-averaged water tank storage temperature at the start of the market slot (in \\(\u00b0C\\) ) The system of equations 4, 5, 6, 7 is calculating the value of the condenser temperature ( \\(T_{condenser}\\) ) by using the target storage temperature as the optimization parameter ( \\(T_{storage-target}\\) ). The calculated condenser temperature is then used by equation 3 in order to calculate the \\(COP\\) , which in turn is used in conjunction with \\(Q_{in,i}\\) in equation 2 in order to finally calculate \\(P_{el-hp}\\) .","title":"Virtual Heat Pump Model Equations"},{"location":"vm-installation-instructions/","text":"If the Grid Singularity Exchange is already installed and updated on your virtual machine you can skip to step 4. Step 1: Windows environment settings (not always required, please try starting with Step 2) \u00b6 Enable Intel Virtualization on your computer in BIOS. Go to your Windows Features setting and disable Windows Hypervisor Platform (or Hyper-V) and enable Virtual Machine Platform. Step 2: Install Virtualbox and Vagrant \u00b6 It is recommended to use Chocolatey as a package management tool for Windows. Open your terminal (cmd.exe) as administrator and install chocolatey by running the following command : @\"%SystemRoot%\\System32\\WindowsPowerShell\\v1.0\\powershell.exe\" -NoProfile -InputFormat None -ExecutionPolicy Bypass -Command \"[System.Net.ServicePointManager]::SecurityProtocol = 3072; iex ((New-Object System.Net.WebClient).DownloadString('https://chocolatey.org/install.ps1'))\" && SET \"PATH=%PATH%;%ALLUSERSPROFILE%\\chocolatey\\bin\" Install Virtualbox from a Windows console choco install virtualbox Install Vagrant (this is a software wrapper around virtualbox and other supervisors, that allows easy creation, download, and installation of virtual machines. choco install vagrant vagrant plugin install vagrant-disksize Step 3: Install Grid Singularity Exchange while sharing a folder between guest and host machine via vagrant \u00b6 Create a new-folder that you want to share across guest and host machines. Add the Vagrantfile from Grid Singularity Exchange repository into your newly created folder. Open a terminal and go into your newly-created folder with: cd <path-to-your-folder> If it is your first time do: vagrant up If vagrant was already running, please delete re-initialize with the following steps first : Delete old vagrant images via : vagrant destroy --force Remove residues of old vagrant boxes via : vagrant box remove ubuntu/<your-box-name> --all --force Step 4: Reload your virtual machine: \u00b6 vagrant reload Step 5: Access your virtual machine terminal to run Grid Singularity Exchange: \u00b6 vagrant ssh Step 6: Share folder to Windows host by running these three commands: \u00b6 cp -r /home/vagrant/gsy-e/vagrant/ Share gsy-e-sdk: cp -r /home/vagrant/gsy-e-sdk/vagrant/ If you have results you want to export to Windows : cd /home/vagrant/gsy-e-simulation/ zip -r <your-zip-filename>.zip ./<folder-to-be-zipped>/ cp -r <your-zip-filename>.zip /vagrant/ Step 7: Run a gsy-e simulation \u00b6 Activate the gsy-e environment: source /home/vagrant/envs/gsy-e/bin/activate Run simulation with: cd /vagrant/gsy-e gsy-e run Step 8: Run the Grid Singularity Exchange SDK in Vagrant \u00b6 Activate the Exchange SDK environment: source /home/vagrant/envs/exchange-sdk/bin/activate To run your SDK script, run the following command (template here): python your_sdk_script.py","title":"Windows Installation Instructions"},{"location":"vm-installation-instructions/#step-1-windows-environment-settings-not-always-required-please-try-starting-with-step-2","text":"Enable Intel Virtualization on your computer in BIOS. Go to your Windows Features setting and disable Windows Hypervisor Platform (or Hyper-V) and enable Virtual Machine Platform.","title":"Step 1: Windows environment settings (not always required, please try starting with Step 2)"},{"location":"vm-installation-instructions/#step-2-install-virtualbox-and-vagrant","text":"It is recommended to use Chocolatey as a package management tool for Windows. Open your terminal (cmd.exe) as administrator and install chocolatey by running the following command : @\"%SystemRoot%\\System32\\WindowsPowerShell\\v1.0\\powershell.exe\" -NoProfile -InputFormat None -ExecutionPolicy Bypass -Command \"[System.Net.ServicePointManager]::SecurityProtocol = 3072; iex ((New-Object System.Net.WebClient).DownloadString('https://chocolatey.org/install.ps1'))\" && SET \"PATH=%PATH%;%ALLUSERSPROFILE%\\chocolatey\\bin\" Install Virtualbox from a Windows console choco install virtualbox Install Vagrant (this is a software wrapper around virtualbox and other supervisors, that allows easy creation, download, and installation of virtual machines. choco install vagrant vagrant plugin install vagrant-disksize","title":"Step 2: Install Virtualbox and Vagrant"},{"location":"vm-installation-instructions/#step-3-install-grid-singularity-exchange-while-sharing-a-folder-between-guest-and-host-machine-via-vagrant","text":"Create a new-folder that you want to share across guest and host machines. Add the Vagrantfile from Grid Singularity Exchange repository into your newly created folder. Open a terminal and go into your newly-created folder with: cd <path-to-your-folder> If it is your first time do: vagrant up If vagrant was already running, please delete re-initialize with the following steps first : Delete old vagrant images via : vagrant destroy --force Remove residues of old vagrant boxes via : vagrant box remove ubuntu/<your-box-name> --all --force","title":"Step 3: Install Grid Singularity Exchange while sharing a folder between guest and host machine via vagrant"},{"location":"vm-installation-instructions/#step-4-reload-your-virtual-machine","text":"vagrant reload","title":"Step 4: Reload your virtual machine:"},{"location":"vm-installation-instructions/#step-5-access-your-virtual-machine-terminal-to-run-grid-singularity-exchange","text":"vagrant ssh","title":"Step 5: Access your virtual machine terminal to run Grid Singularity Exchange:"},{"location":"vm-installation-instructions/#step-6-share-folder-to-windows-host-by-running-these-three-commands","text":"cp -r /home/vagrant/gsy-e/vagrant/ Share gsy-e-sdk: cp -r /home/vagrant/gsy-e-sdk/vagrant/ If you have results you want to export to Windows : cd /home/vagrant/gsy-e-simulation/ zip -r <your-zip-filename>.zip ./<folder-to-be-zipped>/ cp -r <your-zip-filename>.zip /vagrant/","title":"Step 6: Share folder to Windows host by running these three commands:"},{"location":"vm-installation-instructions/#step-7-run-a-gsy-e-simulation","text":"Activate the gsy-e environment: source /home/vagrant/envs/gsy-e/bin/activate Run simulation with: cd /vagrant/gsy-e gsy-e run","title":"Step 7: Run a gsy-e simulation"},{"location":"vm-installation-instructions/#step-8-run-the-grid-singularity-exchange-sdk-in-vagrant","text":"Activate the Exchange SDK environment: source /home/vagrant/envs/exchange-sdk/bin/activate To run your SDK script, run the following command (template here): python your_sdk_script.py","title":"Step 8: Run the Grid Singularity Exchange SDK in Vagrant"},{"location":"img/power-plant/","text":"This energy asset is not yet available on the Singularity Map, but it will be available in the near future. It is still available to users on our previous interface (d3a.io) and in our backend. A finite power plant is an energy supplier that offers a configurable amount of power per time slot at a set rate. Asset Configuration Options Name - Must be unique. Energy rate - Selling price of the power plant in cents/kWh. Maximum available power - Maximum power that the power plant can supply in kW","title":"Power plant"}]}